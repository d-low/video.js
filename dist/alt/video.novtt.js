/**
 * @license
 * Video.js 5.0.0-11 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/master/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.videojs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = _dereq_('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":3}],2:[function(_dereq_,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(_dereq_,module,exports){

},{}],4:[function(_dereq_,module,exports){
module.exports = SafeParseTuple

function SafeParseTuple(obj, reviver) {
    var json
    var error = null

    try {
        json = JSON.parse(obj, reviver)
    } catch (err) {
        error = err
    }

    return [error, json]
}

},{}],5:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _button = _dereq_('./button');

var _button2 = _interopRequireDefault(_button);

/* Big Play Button
================================================================================ */
/**
 * Initial play button. Shows before the video has played. The hiding of the
 * big play button is done via CSS and player states.
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var BigPlayButton = (function (_Button) {
  function BigPlayButton() {
    _classCallCheck(this, BigPlayButton);

    if (_Button != null) {
      _Button.apply(this, arguments);
    }
  }

  _inherits(BigPlayButton, _Button);

  _createClass(BigPlayButton, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(BigPlayButton.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-big-play-button',
        innerHTML: '<span aria-hidden="true"></span>',
        'aria-label': 'play video'
      });
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      this.player_.play();
    }
  }]);

  return BigPlayButton;
})(_button2['default']);

_button2['default'].registerComponent('BigPlayButton', BigPlayButton);
exports['default'] = BigPlayButton;
module.exports = exports['default'];

},{"./button":6}],6:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

var _events = _dereq_('./events');

var Events = _interopRequireWildcard(_events);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/* Button - Base class for all buttons
================================================================================ */
/**
 * Base class for all buttons
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var Button = (function (_Component) {
  function Button(player, options) {
    _classCallCheck(this, Button);

    _get(Object.getPrototypeOf(Button.prototype), 'constructor', this).call(this, player, options);

    this.emitTapEvents();

    this.on('tap', this.handleClick);
    this.on('click', this.handleClick);
    this.on('focus', this.handleFocus);
    this.on('blur', this.handleBlur);
  }

  _inherits(Button, _Component);

  _createClass(Button, [{
    key: 'createEl',
    value: function createEl(type, props) {
      // Add standard Aria and Tabindex info
      props = Lib.obj.merge({
        className: this.buildCSSClass(),
        'role': 'button',
        'aria-live': 'polite', // let the screen reader user know that the text of the button may change
        tabIndex: 0
      }, props);

      var el = _get(Object.getPrototypeOf(Button.prototype), 'createEl', this).call(this, type, props);

      // if innerHTML hasn't been overridden (bigPlayButton), add content elements
      if (!props.innerHTML) {
        this.contentEl_ = Lib.createEl('div', {
          className: 'vjs-control-content'
        });

        this.controlText_ = Lib.createEl('span', {
          className: 'vjs-control-text',
          innerHTML: this.localize(this.buttonText) || 'Need Text'
        });

        this.contentEl_.appendChild(this.controlText_);
        el.appendChild(this.contentEl_);
      }

      return el;
    }
  }, {
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-control vjs-button ' + _get(Object.getPrototypeOf(Button.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleClick',

    // Click - Override with specific functionality for button
    value: function handleClick() {}
  }, {
    key: 'handleFocus',

    // Focus - Add keyboard functionality to element
    value: function handleFocus() {
      Events.on(_globalDocument2['default'], 'keydown', Lib.bind(this, this.handleKeyPress));
    }
  }, {
    key: 'handleKeyPress',

    // KeyPress (document level) - Trigger click when keys are pressed
    value: function handleKeyPress(event) {
      // Check for space bar (32) or enter (13) keys
      if (event.which === 32 || event.which === 13) {
        event.preventDefault();
        this.handleClick();
      }
    }
  }, {
    key: 'handleBlur',

    // Blur - Remove keyboard triggers
    value: function handleBlur() {
      Events.off(_globalDocument2['default'], 'keydown', Lib.bind(this, this.handleKeyPress));
    }
  }]);

  return Button;
})(_component2['default']);

_component2['default'].registerComponent('Button', Button);
exports['default'] = Button;
module.exports = exports['default'];

},{"./component":7,"./events":43,"./lib":46,"global/document":1}],7:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/**
 * @fileoverview Player Component - Base class for all UI objects
 *
 */

var _libJs = _dereq_('./lib.js');

var Lib = _interopRequireWildcard(_libJs);

var _utilJs = _dereq_('./util.js');

var VjsUtil = _interopRequireWildcard(_utilJs);

var _eventsJs = _dereq_('./events.js');

var Events = _interopRequireWildcard(_eventsJs);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

/**
 * Base UI Component class
 *
 * Components are embeddable UI objects that are represented by both a
 * javascript object and an element in the DOM. They can be children of other
 * components, and can have many children themselves.
 *
 *     // adding a button to the player
 *     var button = player.addChild('button');
 *     button.el(); // -> button element
 *
 *     <div class="video-js">
 *       <div class="vjs-button">Button</div>
 *     </div>
 *
 * Components are also event emitters.
 *
 *     button.on('click', function(){
 *       console.log('Button Clicked!');
 *     });
 *
 *     button.trigger('customevent');
 *
 * @param {Object} player  Main Player
 * @param {Object=} options
 * @class
 * @constructor
 */

var Component = (function () {
  function Component(player, options, ready) {
    _classCallCheck(this, Component);

    // The component might be the player itself and we can't pass `this` to super
    if (!player && this.play) {
      this.player_ = player = this; // eslint-disable-line
    } else {
      this.player_ = player;
    }

    // Make a copy of prototype.options_ to protect against overriding global defaults
    this.options_ = Lib.obj.copy(this.options_);

    // Updated options with supplied options
    options = this.options(options);

    // Get ID from options or options element if one is supplied
    this.id_ = options.id || options.el && options.el.id;

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      var id = player && player.id && player.id() || 'no_player';
      this.id_ = '' + id + '_component_' + Lib.guid++;
    }

    this.name_ = options.name || null;

    // Create element if one wasn't provided in options
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    if (options.initChildren !== false) {
      this.initChildren();
    }

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }

  _createClass(Component, [{
    key: 'init',

    // Temp for ES6 class transition, remove before 5.0
    value: function init() {
      // console.log('init called on Component');
      Component.apply(this, arguments);
    }
  }, {
    key: 'dispose',

    /**
     * Dispose of the component and all child components
     */
    value: function dispose() {
      this.trigger({ type: 'dispose', bubbles: false });

      // Dispose all children.
      if (this.children_) {
        for (var i = this.children_.length - 1; i >= 0; i--) {
          if (this.children_[i].dispose) {
            this.children_[i].dispose();
          }
        }
      }

      // Delete child references
      this.children_ = null;
      this.childIndex_ = null;
      this.childNameIndex_ = null;

      // Remove all event listeners.
      this.off();

      // Remove element from DOM
      if (this.el_.parentNode) {
        this.el_.parentNode.removeChild(this.el_);
      }

      Lib.removeData(this.el_);
      this.el_ = null;
    }
  }, {
    key: 'player',

    /**
     * Return the component's player
     *
     * @return {Player}
     */
    value: function player() {
      return this.player_;
    }
  }, {
    key: 'options',

    /**
     * Deep merge of options objects
     *
     * Whenever a property is an object on both options objects
     * the two properties will be merged using Lib.obj.deepMerge.
     *
     * This is used for merging options for child components. We
     * want it to be easy to override individual options on a child
     * component without having to rewrite all the other default options.
     *
     *     Parent.prototype.options_ = {
     *       children: {
     *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },
     *         'childTwo': {},
     *         'childThree': {}
     *       }
     *     }
     *     newOptions = {
     *       children: {
     *         'childOne': { 'foo': 'baz', 'abc': '123' }
     *         'childTwo': null,
     *         'childFour': {}
     *       }
     *     }
     *
     *     this.options(newOptions);
     *
     * RESULT
     *
     *     {
     *       children: {
     *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },
     *         'childTwo': null, // Disabled. Won't be initialized.
     *         'childThree': {},
     *         'childFour': {}
     *       }
     *     }
     *
     * @param  {Object} obj Object of new option values
     * @return {Object}     A NEW object of this.options_ and obj merged
     */
    value: function options(obj) {
      if (!obj) {
        return this.options_;
      }

      this.options_ = VjsUtil.mergeOptions(this.options_, obj);
      return this.options_;
    }
  }, {
    key: 'el',

    /**
     * Get the component's DOM element
     *
     *     var domEl = myComponent.el();
     *
     * @return {Element}
     */
    value: function el() {
      return this.el_;
    }
  }, {
    key: 'createEl',

    /**
     * Create the component's DOM element
     *
     * @param  {String=} tagName  Element's node type. e.g. 'div'
     * @param  {Object=} attributes An object of element attributes that should be set on the element
     * @return {Element}
     */
    value: function createEl(tagName, attributes) {
      return Lib.createEl(tagName, attributes);
    }
  }, {
    key: 'localize',
    value: function localize(string) {
      var lang = this.player_.language();
      var languages = this.player_.languages();

      if (languages && languages[lang] && languages[lang][string]) {
        return languages[lang][string];
      }

      return string;
    }
  }, {
    key: 'contentEl',

    /**
     * Return the component's DOM element where children are inserted.
     * Will either be the same as el() or a new element defined in createEl().
     *
     * @return {Element}
     */
    value: function contentEl() {
      return this.contentEl_ || this.el_;
    }
  }, {
    key: 'id',

    /**
     * Get the component's ID
     *
     *     var id = myComponent.id();
     *
     * @return {String}
     */
    value: function id() {
      return this.id_;
    }
  }, {
    key: 'name',

    /**
     * Get the component's name. The name is often used to reference the component.
     *
     *     var name = myComponent.name();
     *
     * @return {String}
     */
    value: function name() {
      return this.name_;
    }
  }, {
    key: 'children',

    /**
     * Get an array of all child components
     *
     *     var kids = myComponent.children();
     *
     * @return {Array} The children
     */
    value: function children() {
      return this.children_;
    }
  }, {
    key: 'getChildById',

    /**
     * Returns a child component with the provided ID
     *
     * @return {Component}
     */
    value: function getChildById(id) {
      return this.childIndex_[id];
    }
  }, {
    key: 'getChild',

    /**
     * Returns a child component with the provided name
     *
     * @return {Component}
     */
    value: function getChild(name) {
      return this.childNameIndex_[name];
    }
  }, {
    key: 'addChild',

    /**
     * Adds a child component inside this component
     *
     *     myComponent.el();
     *     // -> <div class='my-component'></div>
     *     myComponent.children();
     *     // [empty array]
     *
     *     var myButton = myComponent.addChild('MyButton');
     *     // -> <div class='my-component'><div class="my-button">myButton<div></div>
     *     // -> myButton === myComonent.children()[0];
     *
     * Pass in options for child constructors and options for children of the child
     *
     *     var myButton = myComponent.addChild('MyButton', {
     *       text: 'Press Me',
     *       children: {
     *         buttonChildExample: {
     *           buttonChildOption: true
     *         }
     *       }
     *     });
     *
     * @param {String|Component} child The class name or instance of a child to add
     * @param {Object=} options Options, including options to be passed to children of the child.
     * @return {Component} The child component (created by this process if a string was used)
     * @suppress {accessControls|checkRegExp|checkTypes|checkVars|const|constantProperty|deprecated|duplicate|es5Strict|fileoverviewTags|globalThis|invalidCasts|missingProperties|nonStandardJsDocs|strictModuleDepCheck|undefinedNames|undefinedVars|unknownDefines|uselessCode|visibility}
     */
    value: function addChild(child) {
      var options = arguments[1] === undefined ? {} : arguments[1];

      var component = undefined;
      var componentName = undefined;

      // If child is a string, create nt with options
      if (typeof child === 'string') {
        componentName = child;

        // Options can also be specified as a boolean, so convert to an empty object if false.
        if (!options) {
          options = {};
        }

        // Same as above, but true is deprecated so show a warning.
        if (options === true) {
          Lib.log.warn('Initializing a child component with `true` is deprecated. Children should be defined in an array when possible, but if necessary use an object instead of `true`.');
          options = {};
        }

        // If no componentClass in options, assume componentClass is the name lowercased
        // (e.g. playButton)
        var componentClassName = options.componentClass || Lib.capitalize(componentName);

        // Set name through options
        options.name = componentName;

        // Create a new object & element for this controls set
        // If there's no .player_, this is a player
        var ComponentClass = Component.getComponent(componentClassName);

        component = new ComponentClass(this.player_ || this, options);

        // child is a component instance
      } else {
        component = child;
      }

      this.children_.push(component);

      if (typeof component.id === 'function') {
        this.childIndex_[component.id()] = component;
      }

      // If a name wasn't used to create the component, check if we can use the
      // name function of the component
      componentName = componentName || component.name && component.name();

      if (componentName) {
        this.childNameIndex_[componentName] = component;
      }

      // Add the UI object's element to the container div (box)
      // Having an element is not required
      if (typeof component.el === 'function' && component.el()) {
        this.contentEl().appendChild(component.el());
      }

      // Return so it can stored on parent object if desired.
      return component;
    }
  }, {
    key: 'removeChild',

    /**
     * Remove a child component from this component's list of children, and the
     * child component's element from this component's element
     *
     * @param  {Component} component Component to remove
     */
    value: function removeChild(component) {
      if (typeof component === 'string') {
        component = this.getChild(component);
      }

      if (!component || !this.children_) {
        return;
      }

      var childFound = false;

      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i] === component) {
          childFound = true;
          this.children_.splice(i, 1);
          break;
        }
      }

      if (!childFound) {
        return;
      }

      this.childIndex_[component.id()] = null;
      this.childNameIndex_[component.name()] = null;

      var compEl = component.el();

      if (compEl && compEl.parentNode === this.contentEl()) {
        this.contentEl().removeChild(component.el());
      }
    }
  }, {
    key: 'initChildren',

    /**
     * Add and initialize default child components from options
     *
     *     // when an instance of MyComponent is created, all children in options
     *     // will be added to the instance by their name strings and options
     *     MyComponent.prototype.options_.children = {
     *       myChildComponent: {
     *         myChildOption: true
     *       }
     *     }
     *
     *     // Or when creating the component
     *     var myComp = new MyComponent(player, {
     *       children: {
     *         myChildComponent: {
     *           myChildOption: true
     *         }
     *       }
     *     });
     *
     * The children option can also be an Array of child names or
     * child options objects (that also include a 'name' key).
     *
     *     var myComp = new MyComponent(player, {
     *       children: [
     *         'button',
     *         {
     *           name: 'button',
     *           someOtherOption: true
     *         }
     *       ]
     *     });
     *
     */
    value: function initChildren() {
      var _this = this;

      var children = this.options_.children;

      if (children) {
        (function () {
          // `this` is `parent`
          var parentOptions = _this.options();
          var handleAdd = function handleAdd(name, opts) {
            // Allow options for children to be set at the parent options
            // e.g. videojs(id, { controlBar: false });
            // instead of videojs(id, { children: { controlBar: false });
            if (parentOptions[name] !== undefined) {
              opts = parentOptions[name];
            }

            // Allow for disabling default components
            // e.g. options['children']['posterImage'] = false
            if (opts === false) {
              return;
            }

            // Create and add the child component.
            // Add a direct reference to the child by name on the parent instance.
            // If two of the same component are used, different names should be supplied
            // for each
            _this[name] = _this.addChild(name, opts);
          };

          // Allow for an array of children details to passed in the options
          if (Lib.obj.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              var _name = undefined;
              var opts = undefined;

              if (typeof child === 'string') {
                // ['myComponent']
                _name = child;
                opts = {};
              } else {
                // [{ name: 'myComponent', otherOption: true }]
                _name = child.name;
                opts = child;
              }

              handleAdd(_name, opts);
            }
          } else {
            Lib.obj.each(children, handleAdd);
          }
        })();
      }
    }
  }, {
    key: 'buildCSSClass',

    /**
     * Allows sub components to stack CSS class names
     *
     * @return {String} The constructed class name
     */
    value: function buildCSSClass() {
      // Child classes can include a function that does:
      // return 'CLASS NAME' + this._super();
      return '';
    }
  }, {
    key: 'on',

    /**
     * Add an event listener to this component's element
     *
     *     var myFunc = function(){
     *       var myComponent = this;
     *       // Do something when the event is fired
     *     };
     *
     *     myComponent.on('eventType', myFunc);
     *
     * The context of myFunc will be myComponent unless previously bound.
     *
     * Alternatively, you can add a listener to another element or component.
     *
     *     myComponent.on(otherElement, 'eventName', myFunc);
     *     myComponent.on(otherComponent, 'eventName', myFunc);
     *
     * The benefit of using this over `VjsEvents.on(otherElement, 'eventName', myFunc)`
     * and `otherComponent.on('eventName', myFunc)` is that this way the listeners
     * will be automatically cleaned up when either component is disposed.
     * It will also bind myComponent as the context of myFunc.
     *
     * **NOTE**: When using this on elements in the page other than window
     * and document (both permanent), if you remove the element from the DOM
     * you need to call `myComponent.trigger(el, 'dispose')` on it to clean up
     * references to it and allow the browser to garbage collect it.
     *
     * @param  {String|Component} first   The event type or other component
     * @param  {Function|String}      second  The event handler or event type
     * @param  {Function}             third   The event handler
     * @return {Component}        self
     */
    value: function on(first, second, third) {
      var _this2 = this;

      if (typeof first === 'string' || Lib.obj.isArray(first)) {
        Events.on(this.el_, first, Lib.bind(this, second));

        // Targeting another component or element
      } else {
        (function () {
          var target = first;
          var type = second;
          var fn = Lib.bind(_this2, third);

          // When this component is disposed, remove the listener from the other component
          var removeOnDispose = function removeOnDispose() {
            return _this2.off(target, type, fn);
          };

          // Use the same function ID so we can remove it later it using the ID
          // of the original listener
          removeOnDispose.guid = fn.guid;
          _this2.on('dispose', removeOnDispose);

          // If the other component is disposed first we need to clean the reference
          // to the other component in this component's removeOnDispose listener
          // Otherwise we create a memory leak.
          var cleanRemover = function cleanRemover() {
            return _this2.off('dispose', removeOnDispose);
          };

          // Add the same function ID so we can easily remove it later
          cleanRemover.guid = fn.guid;

          // Check if this is a DOM node
          if (first.nodeName) {
            // Add the listener to the other element
            Events.on(target, type, fn);
            Events.on(target, 'dispose', cleanRemover);

            // Should be a component
            // Not using `instanceof Component` because it makes mock players difficult
          } else if (typeof first.on === 'function') {
            // Add the listener to the other component
            target.on(type, fn);
            target.on('dispose', cleanRemover);
          }
        })();
      }

      return this;
    }
  }, {
    key: 'off',

    /**
     * Remove an event listener from this component's element
     *
     *     myComponent.off('eventType', myFunc);
     *
     * If myFunc is excluded, ALL listeners for the event type will be removed.
     * If eventType is excluded, ALL listeners will be removed from the component.
     *
     * Alternatively you can use `off` to remove listeners that were added to other
     * elements or components using `myComponent.on(otherComponent...`.
     * In this case both the event type and listener function are REQUIRED.
     *
     *     myComponent.off(otherElement, 'eventType', myFunc);
     *     myComponent.off(otherComponent, 'eventType', myFunc);
     *
     * @param  {String=|Component}  first  The event type or other component
     * @param  {Function=|String}       second The listener function or event type
     * @param  {Function=}              third  The listener for other component
     * @return {Component}
     */
    value: function off(first, second, third) {
      if (!first || typeof first === 'string' || Lib.obj.isArray(first)) {
        Events.off(this.el_, first, second);
      } else {
        var target = first;
        var type = second;
        // Ensure there's at least a guid, even if the function hasn't been used
        var fn = Lib.bind(this, third);

        // Remove the dispose listener on this component,
        // which was given the same guid as the event listener
        this.off('dispose', fn);

        if (first.nodeName) {
          // Remove the listener
          Events.off(target, type, fn);
          // Remove the listener for cleaning the dispose listener
          Events.off(target, 'dispose', fn);
        } else {
          target.off(type, fn);
          target.off('dispose', fn);
        }
      }

      return this;
    }
  }, {
    key: 'one',

    /**
     * Add an event listener to be triggered only once and then removed
     *
     *     myComponent.one('eventName', myFunc);
     *
     * Alternatively you can add a listener to another element or component
     * that will be triggered only once.
     *
     *     myComponent.one(otherElement, 'eventName', myFunc);
     *     myComponent.one(otherComponent, 'eventName', myFunc);
     *
     * @param  {String|Component}  first   The event type or other component
     * @param  {Function|String}       second  The listener function or event type
     * @param  {Function=}             third   The listener function for other component
     * @return {Component}
     */
    value: function one(first, second, third) {
      var _this3 = this;

      var _arguments = arguments;

      if (typeof first === 'string' || Lib.obj.isArray(first)) {
        Events.one(this.el_, first, Lib.bind(this, second));
      } else {
        (function () {
          var target = first;
          var type = second;
          var fn = Lib.bind(_this3, third);

          var newFunc = function newFunc() {
            _this3.off(target, type, newFunc);
            fn.apply(null, _arguments);
          };

          // Keep the same function ID so we can remove it later
          newFunc.guid = fn.guid;

          _this3.on(target, type, newFunc);
        })();
      }

      return this;
    }
  }, {
    key: 'trigger',

    /**
     * Trigger an event on an element
     *
     *     myComponent.trigger('eventName');
     *     myComponent.trigger({'type':'eventName'});
     *
     * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute
     * @return {Component}       self
     */
    value: function trigger(event) {
      Events.trigger(this.el_, event);
      return this;
    }
  }, {
    key: 'ready',

    /**
     * Bind a listener to the component's ready state
     *
     * Different from event listeners in that if the ready event has already happened
     * it will trigger the function immediately.
     *
     * @param  {Function} fn Ready listener
     * @return {Component}
     */
    value: function ready(fn) {
      if (fn) {
        if (this.isReady_) {
          fn.call(this);
        } else {
          this.readyQueue_ = this.readyQueue_ || [];
          this.readyQueue_.push(fn);
        }
      }
      return this;
    }
  }, {
    key: 'triggerReady',

    /**
     * Trigger the ready listeners
     *
     * @return {Component}
     */
    value: function triggerReady() {
      this.isReady_ = true;

      var readyQueue = this.readyQueue_;

      if (readyQueue && readyQueue.length > 0) {

        for (var i = 0; i < readyQueue.length; i++) {
          readyQueue[i].call(this);
        }

        // Reset Ready Queue
        this.readyQueue_ = [];

        // Allow for using event listeners also, in case you want to do something everytime a source is ready.
        this.trigger('ready');
      }
    }
  }, {
    key: 'hasClass',

    /**
     * Check if a component's element has a CSS class name
     *
     * @param {String} classToCheck Classname to check
     * @return {Component}
     */
    value: function hasClass(classToCheck) {
      return Lib.hasClass(this.el_, classToCheck);
    }
  }, {
    key: 'addClass',

    /**
     * Add a CSS class name to the component's element
     *
     * @param {String} classToAdd Classname to add
     * @return {Component}
     */
    value: function addClass(classToAdd) {
      Lib.addClass(this.el_, classToAdd);
      return this;
    }
  }, {
    key: 'removeClass',

    /**
     * Remove a CSS class name from the component's element
     *
     * @param {String} classToRemove Classname to remove
     * @return {Component}
     */
    value: function removeClass(classToRemove) {
      Lib.removeClass(this.el_, classToRemove);
      return this;
    }
  }, {
    key: 'show',

    /**
     * Show the component element if hidden
     *
     * @return {Component}
     */
    value: function show() {
      this.removeClass('vjs-hidden');
      return this;
    }
  }, {
    key: 'hide',

    /**
     * Hide the component element if currently showing
     *
     * @return {Component}
     */
    value: function hide() {
      this.addClass('vjs-hidden');
      return this;
    }
  }, {
    key: 'lockShowing',

    /**
     * Lock an item in its visible state
     * To be used with fadeIn/fadeOut.
     *
     * @return {Component}
     * @private
     */
    value: function lockShowing() {
      this.addClass('vjs-lock-showing');
      return this;
    }
  }, {
    key: 'unlockShowing',

    /**
     * Unlock an item to be hidden
     * To be used with fadeIn/fadeOut.
     *
     * @return {Component}
     * @private
     */
    value: function unlockShowing() {
      this.removeClass('vjs-lock-showing');
      return this;
    }
  }, {
    key: 'width',

    /**
     * Set or get the width of the component (CSS values)
     *
     * Setting the video tag dimension values only works with values in pixels.
     * Percent values will not work.
     * Some percents can be used, but width()/height() will return the number + %,
     * not the actual computed width/height.
     *
     * @param  {Number|String=} num   Optional width number
     * @param  {Boolean} skipListeners Skip the 'resize' event trigger
     * @return {Component} This component, when setting the width
     * @return {Number|String} The width, when getting
     */
    value: function width(num, skipListeners) {
      return this.dimension('width', num, skipListeners);
    }
  }, {
    key: 'height',

    /**
     * Get or set the height of the component (CSS values)
     *
     * Setting the video tag dimension values only works with values in pixels.
     * Percent values will not work.
     * Some percents can be used, but width()/height() will return the number + %,
     * not the actual computed width/height.
     *
     * @param  {Number|String=} num     New component height
     * @param  {Boolean=} skipListeners Skip the resize event trigger
     * @return {Component} This component, when setting the height
     * @return {Number|String} The height, when getting
     */
    value: function height(num, skipListeners) {
      return this.dimension('height', num, skipListeners);
    }
  }, {
    key: 'dimensions',

    /**
     * Set both width and height at the same time
     *
     * @param  {Number|String} width
     * @param  {Number|String} height
     * @return {Component} The component
     */
    value: function dimensions(width, height) {
      // Skip resize listeners on width for optimization
      return this.width(width, true).height(height);
    }
  }, {
    key: 'dimension',

    /**
     * Get or set width or height
     *
     * This is the shared code for the width() and height() methods.
     * All for an integer, integer + 'px' or integer + '%';
     *
     * Known issue: Hidden elements officially have a width of 0. We're defaulting
     * to the style.width value and falling back to computedStyle which has the
     * hidden element issue. Info, but probably not an efficient fix:
     * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/
     *
     * @param  {String} widthOrHeight  'width' or 'height'
     * @param  {Number|String=} num     New dimension
     * @param  {Boolean=} skipListeners Skip resize event trigger
     * @return {Component} The component if a dimension was set
     * @return {Number|String} The dimension if nothing was set
     * @private
     */
    value: function dimension(widthOrHeight, num, skipListeners) {
      if (num !== undefined) {
        // Set to zero if null or literally NaN (NaN !== NaN)
        if (num === null || num !== num) {
          num = 0;
        }

        // Check if using css width/height (% or px) and adjust
        if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
          this.el_.style[widthOrHeight] = num;
        } else if (num === 'auto') {
          this.el_.style[widthOrHeight] = '';
        } else {
          this.el_.style[widthOrHeight] = num + 'px';
        }

        // skipListeners allows us to avoid triggering the resize event when setting both width and height
        if (!skipListeners) {
          this.trigger('resize');
        }

        // Return component
        return this;
      }

      // Not setting a value, so getting it
      // Make sure element exists
      if (!this.el_) {
        return 0;
      }

      // Get dimension value from style
      var val = this.el_.style[widthOrHeight];
      var pxIndex = val.indexOf('px');

      if (pxIndex !== -1) {
        // Return the pixel value with no 'px'
        return parseInt(val.slice(0, pxIndex), 10);
      }

      // No px so using % or no style was set, so falling back to offsetWidth/height
      // If component has display:none, offset will return 0
      // TODO: handle display:none and no dimension style using px
      return parseInt(this.el_['offset' + Lib.capitalize(widthOrHeight)], 10);

      // ComputedStyle version.
      // Only difference is if the element is hidden it will return
      // the percent value (e.g. '100%'')
      // instead of zero like offsetWidth returns.
      // var val = Lib.getComputedStyleValue(this.el_, widthOrHeight);
      // var pxIndex = val.indexOf('px');

      // if (pxIndex !== -1) {
      //   return val.slice(0, pxIndex);
      // } else {
      //   return val;
      // }
    }
  }, {
    key: 'emitTapEvents',

    /**
     * Emit 'tap' events when touch events are supported
     *
     * This is used to support toggling the controls through a tap on the video.
     *
     * We're requiring them to be enabled because otherwise every component would
     * have this extra overhead unnecessarily, on mobile devices where extra
     * overhead is especially bad.
     * @private
     */
    value: function emitTapEvents() {
      // Track the start time so we can determine how long the touch lasted
      var touchStart = 0;
      var firstTouch = null;

      // Maximum movement allowed during a touch event to still be considered a tap
      // Other popular libs use anywhere from 2 (hammer.js) to 15, so 10 seems like a nice, round number.
      var tapMovementThreshold = 10;

      // The maximum length a touch can be while still being considered a tap
      var touchTimeThreshold = 200;

      var couldBeTap = undefined;

      this.on('touchstart', function (event) {
        // If more than one finger, don't consider treating this as a click
        if (event.touches.length === 1) {
          firstTouch = Lib.obj.copy(event.touches[0]);
          // Record start time so we can detect a tap vs. "touch and hold"
          touchStart = new Date().getTime();
          // Reset couldBeTap tracking
          couldBeTap = true;
        }
      });

      this.on('touchmove', function (event) {
        // If more than one finger, don't consider treating this as a click
        if (event.touches.length > 1) {
          couldBeTap = false;
        } else if (firstTouch) {
          // Some devices will throw touchmoves for all but the slightest of taps.
          // So, if we moved only a small distance, this could still be a tap
          var xdiff = event.touches[0].pageX - firstTouch.pageX;
          var ydiff = event.touches[0].pageY - firstTouch.pageY;
          var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);

          if (touchDistance > tapMovementThreshold) {
            couldBeTap = false;
          }
        }
      });

      var noTap = function noTap() {
        couldBeTap = false;
      };

      // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
      this.on('touchleave', noTap);
      this.on('touchcancel', noTap);

      // When the touch ends, measure how long it took and trigger the appropriate
      // event
      this.on('touchend', function (event) {
        firstTouch = null;
        // Proceed only if the touchmove/leave/cancel event didn't happen
        if (couldBeTap === true) {
          // Measure how long the touch lasted
          var touchTime = new Date().getTime() - touchStart;

          // Make sure the touch was less than the threshold to be considered a tap
          if (touchTime < touchTimeThreshold) {
            // Don't let browser turn this into a click
            event.preventDefault();
            this.trigger('tap');
            // It may be good to copy the touchend event object and change the
            // type to tap, if the other event properties aren't exact after
            // Lib.fixEvent runs (e.g. event.target)
          }
        }
      });
    }
  }, {
    key: 'enableTouchActivity',

    /**
     * Report user touch activity when touch events occur
     *
     * User activity is used to determine when controls should show/hide. It's
     * relatively simple when it comes to mouse events, because any mouse event
     * should show the controls. So we capture mouse events that bubble up to the
     * player and report activity when that happens.
     *
     * With touch events it isn't as easy. We can't rely on touch events at the
     * player level, because a tap (touchstart + touchend) on the video itself on
     * mobile devices is meant to turn controls off (and on). User activity is
     * checked asynchronously, so what could happen is a tap event on the video
     * turns the controls off, then the touchend event bubbles up to the player,
     * which if it reported user activity, would turn the controls right back on.
     * (We also don't want to completely block touch events from bubbling up)
     *
     * Also a touchmove, touch+hold, and anything other than a tap is not supposed
     * to turn the controls back on on a mobile device.
     *
     * Here we're setting the default component behavior to report user activity
     * whenever touch events happen, and this can be turned off by components that
     * want touch events to act differently.
     */
    value: function enableTouchActivity() {
      // Don't continue if the root player doesn't support reporting user activity
      if (!this.player() || !this.player().reportUserActivity) {
        return;
      }

      // listener for reporting that the user is active
      var report = Lib.bind(this.player(), this.player().reportUserActivity);

      var touchHolding = undefined;

      this.on('touchstart', function () {
        report();
        // For as long as the they are touching the device or have their mouse down,
        // we consider them active even if they're not moving their finger or mouse.
        // So we want to continue to update that they are active
        this.clearInterval(touchHolding);
        // report at the same interval as activityCheck
        touchHolding = this.setInterval(report, 250);
      });

      var touchEnd = function touchEnd(event) {
        report();
        // stop the interval that maintains activity if the touch is holding
        this.clearInterval(touchHolding);
      };

      this.on('touchmove', report);
      this.on('touchend', touchEnd);
      this.on('touchcancel', touchEnd);
    }
  }, {
    key: 'setTimeout',

    /**
     * Creates timeout and sets up disposal automatically.
     * @param {Function} fn The function to run after the timeout.
     * @param {Number} timeout Number of ms to delay before executing specified function.
     * @return {Number} Returns the timeout ID
     */
    value: function setTimeout(fn, timeout) {
      fn = Lib.bind(this, fn);

      // window.setTimeout would be preferable here, but due to some bizarre issue with Sinon and/or Phantomjs, we can't.
      var timeoutId = _globalWindow2['default'].setTimeout(fn, timeout);

      var disposeFn = function disposeFn() {
        this.clearTimeout(timeoutId);
      };

      disposeFn.guid = 'vjs-timeout-' + timeoutId;

      this.on('dispose', disposeFn);

      return timeoutId;
    }
  }, {
    key: 'clearTimeout',

    /**
     * Clears a timeout and removes the associated dispose listener
     * @param {Number} timeoutId The id of the timeout to clear
     * @return {Number} Returns the timeout ID
     */
    value: function clearTimeout(timeoutId) {
      _globalWindow2['default'].clearTimeout(timeoutId);

      var disposeFn = function disposeFn() {};

      disposeFn.guid = 'vjs-timeout-' + timeoutId;

      this.off('dispose', disposeFn);

      return timeoutId;
    }
  }, {
    key: 'setInterval',

    /**
     * Creates an interval and sets up disposal automatically.
     * @param {Function} fn The function to run every N seconds.
     * @param {Number} interval Number of ms to delay before executing specified function.
     * @return {Number} Returns the interval ID
     */
    value: function setInterval(fn, interval) {
      fn = Lib.bind(this, fn);

      var intervalId = _globalWindow2['default'].setInterval(fn, interval);

      var disposeFn = function disposeFn() {
        this.clearInterval(intervalId);
      };

      disposeFn.guid = 'vjs-interval-' + intervalId;

      this.on('dispose', disposeFn);

      return intervalId;
    }
  }, {
    key: 'clearInterval',

    /**
     * Clears an interval and removes the associated dispose listener
     * @param {Number} intervalId The id of the interval to clear
     * @return {Number} Returns the interval ID
     */
    value: function clearInterval(intervalId) {
      _globalWindow2['default'].clearInterval(intervalId);

      var disposeFn = function disposeFn() {};

      disposeFn.guid = 'vjs-interval-' + intervalId;

      this.off('dispose', disposeFn);

      return intervalId;
    }
  }], [{
    key: 'registerComponent',
    value: function registerComponent(name, comp) {
      if (!Component.components_) {
        Component.components_ = {};
      }

      Component.components_[name] = comp;
      return comp;
    }
  }, {
    key: 'getComponent',
    value: function getComponent(name) {
      if (Component.components_ && Component.components_[name]) {
        return Component.components_[name];
      }

      if (_globalWindow2['default'] && _globalWindow2['default'].videojs && _globalWindow2['default'].videojs[name]) {
        Lib.log.warn('The ' + name + ' component was added to the videojs object when it should be registered using videojs.registerComponent(name, component)');
        return _globalWindow2['default'].videojs[name];
      }
    }
  }, {
    key: 'extend',
    value: function extend(props) {
      props = props || {};
      // Set up the constructor using the supplied init method
      // or using the init of the parent object
      // Make sure to check the unobfuscated version for external libs
      var init = props.init || props.init || this.prototype.init || this.prototype.init || function () {};
      // In Resig's simple class inheritance (previously used) the constructor
      //  is a function that calls `this.init.apply(arguments)`
      // However that would prevent us from using `ParentObject.call(this);`
      //  in a Child constructor because the `this` in `this.init`
      //  would still refer to the Child and cause an infinite loop.
      // We would instead have to do
      //    `ParentObject.prototype.init.apply(this, arguments);`
      //  Bleh. We're not creating a _super() function, so it's good to keep
      //  the parent constructor reference simple.
      var subObj = function subObj() {
        init.apply(this, arguments);
      };

      // Inherit from this object's prototype
      subObj.prototype = Lib.obj.create(this.prototype);
      // Reset the constructor property for subObj otherwise
      // instances of subObj would have the constructor of the parent Object
      subObj.prototype.constructor = subObj;

      // Make the class extendable
      subObj.extend = Component.extend;
      // Make a function for creating instances
      // subObj.create = CoreObject.create;

      // Extend subObj's prototype with functions and other properties from props
      for (var _name2 in props) {
        if (props.hasOwnProperty(_name2)) {
          subObj.prototype[_name2] = props[_name2];
        }
      }

      return subObj;
    }
  }]);

  return Component;
})();

Component.registerComponent('Component', Component);
exports['default'] = Component;
module.exports = exports['default'];

},{"./events.js":43,"./lib.js":46,"./util.js":70,"global/window":2}],8:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _libJs = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_libJs);

// Required children

var _playToggleJs = _dereq_('./play-toggle.js');

var _playToggleJs2 = _interopRequireDefault(_playToggleJs);

var _timeControlsCurrentTimeDisplayJs = _dereq_('./time-controls/current-time-display.js');

var _timeControlsCurrentTimeDisplayJs2 = _interopRequireDefault(_timeControlsCurrentTimeDisplayJs);

var _timeControlsDurationDisplayJs = _dereq_('./time-controls/duration-display.js');

var _timeControlsDurationDisplayJs2 = _interopRequireDefault(_timeControlsDurationDisplayJs);

var _timeControlsTimeDividerJs = _dereq_('./time-controls/time-divider.js');

var _timeControlsTimeDividerJs2 = _interopRequireDefault(_timeControlsTimeDividerJs);

var _timeControlsRemainingTimeDisplayJs = _dereq_('./time-controls/remaining-time-display.js');

var _timeControlsRemainingTimeDisplayJs2 = _interopRequireDefault(_timeControlsRemainingTimeDisplayJs);

var _liveDisplayJs = _dereq_('./live-display.js');

var _liveDisplayJs2 = _interopRequireDefault(_liveDisplayJs);

var _progressControlProgressControlJs = _dereq_('./progress-control/progress-control.js');

var _progressControlProgressControlJs2 = _interopRequireDefault(_progressControlProgressControlJs);

var _fullscreenToggleJs = _dereq_('./fullscreen-toggle.js');

var _fullscreenToggleJs2 = _interopRequireDefault(_fullscreenToggleJs);

var _volumeControlVolumeControlJs = _dereq_('./volume-control/volume-control.js');

var _volumeControlVolumeControlJs2 = _interopRequireDefault(_volumeControlVolumeControlJs);

var _volumeMenuButtonJs = _dereq_('./volume-menu-button.js');

var _volumeMenuButtonJs2 = _interopRequireDefault(_volumeMenuButtonJs);

var _muteToggleJs = _dereq_('./mute-toggle.js');

var _muteToggleJs2 = _interopRequireDefault(_muteToggleJs);

var _textTrackControlsChaptersButtonJs = _dereq_('./text-track-controls/chapters-button.js');

var _textTrackControlsChaptersButtonJs2 = _interopRequireDefault(_textTrackControlsChaptersButtonJs);

var _textTrackControlsSubtitlesButtonJs = _dereq_('./text-track-controls/subtitles-button.js');

var _textTrackControlsSubtitlesButtonJs2 = _interopRequireDefault(_textTrackControlsSubtitlesButtonJs);

var _textTrackControlsCaptionsButtonJs = _dereq_('./text-track-controls/captions-button.js');

var _textTrackControlsCaptionsButtonJs2 = _interopRequireDefault(_textTrackControlsCaptionsButtonJs);

var _playbackRateMenuPlaybackRateMenuButtonJs = _dereq_('./playback-rate-menu/playback-rate-menu-button.js');

var _playbackRateMenuPlaybackRateMenuButtonJs2 = _interopRequireDefault(_playbackRateMenuPlaybackRateMenuButtonJs);

var _spacerControlsCustomControlSpacerJs = _dereq_('./spacer-controls/custom-control-spacer.js');

var _spacerControlsCustomControlSpacerJs2 = _interopRequireDefault(_spacerControlsCustomControlSpacerJs);

/**
 * Container of main controls
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 * @extends Component
 */

var ControlBar = (function (_Component) {
  function ControlBar() {
    _classCallCheck(this, ControlBar);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(ControlBar, _Component);

  _createClass(ControlBar, [{
    key: 'createEl',
    value: function createEl() {
      return Lib.createEl('div', {
        className: 'vjs-control-bar'
      });
    }
  }]);

  return ControlBar;
})(_componentJs2['default']);

ControlBar.prototype.options_ = {
  loadEvent: 'play',
  children: ['playToggle', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'muteToggle', 'volumeControl', 'chaptersButton', 'subtitlesButton', 'captionsButton', 'volumeMenuButton', 'fullscreenToggle']
};

_componentJs2['default'].registerComponent('ControlBar', ControlBar);
exports['default'] = ControlBar;
module.exports = exports['default'];

},{"../component.js":7,"../lib.js":46,"./fullscreen-toggle.js":9,"./live-display.js":10,"./mute-toggle.js":11,"./play-toggle.js":12,"./playback-rate-menu/playback-rate-menu-button.js":13,"./progress-control/progress-control.js":17,"./spacer-controls/custom-control-spacer.js":20,"./text-track-controls/captions-button.js":23,"./text-track-controls/chapters-button.js":24,"./text-track-controls/subtitles-button.js":27,"./time-controls/current-time-display.js":30,"./time-controls/duration-display.js":31,"./time-controls/remaining-time-display.js":32,"./time-controls/time-divider.js":33,"./volume-control/volume-control.js":35,"./volume-menu-button.js":38}],9:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _button = _dereq_('../button');

var _button2 = _interopRequireDefault(_button);

/**
 * Toggle fullscreen video
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @extends vjs.Button
 */

var FullscreenToggle = (function (_Button) {
  function FullscreenToggle() {
    _classCallCheck(this, FullscreenToggle);

    if (_Button != null) {
      _Button.apply(this, arguments);
    }
  }

  _inherits(FullscreenToggle, _Button);

  _createClass(FullscreenToggle, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-fullscreen-control ' + _get(Object.getPrototypeOf(FullscreenToggle.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      if (!this.player_.isFullscreen()) {
        this.player_.requestFullscreen();
        this.controlText_.innerHTML = this.localize('Non-Fullscreen');
      } else {
        this.player_.exitFullscreen();
        this.controlText_.innerHTML = this.localize('Fullscreen');
      }
    }
  }]);

  return FullscreenToggle;
})(_button2['default']);

FullscreenToggle.prototype.buttonText = 'Fullscreen';

_button2['default'].registerComponent('FullscreenToggle', FullscreenToggle);
exports['default'] = FullscreenToggle;
module.exports = exports['default'];

},{"../button":6}],10:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

/**
 * Displays the live indicator
 * TODO - Future make it click to snap to live
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var LiveDisplay = (function (_Component) {
  function LiveDisplay() {
    _classCallCheck(this, LiveDisplay);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(LiveDisplay, _Component);

  _createClass(LiveDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(LiveDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-live-control vjs-control'
      });

      this.contentEl_ = Lib.createEl('div', {
        className: 'vjs-live-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE'),
        'aria-live': 'off'
      });

      el.appendChild(this.contentEl_);

      return el;
    }
  }]);

  return LiveDisplay;
})(_component2['default']);

_component2['default'].registerComponent('LiveDisplay', LiveDisplay);
exports['default'] = LiveDisplay;
module.exports = exports['default'];

},{"../component":7,"../lib":46}],11:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _button = _dereq_('../button');

var _button2 = _interopRequireDefault(_button);

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

/**
 * A button component for muting the audio
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var MuteToggle = (function (_Button) {
  function MuteToggle(player, options) {
    _classCallCheck(this, MuteToggle);

    _get(Object.getPrototypeOf(MuteToggle.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'volumechange', this.update);

    // hide mute toggle if the current tech doesn't support volume control
    if (player.tech && player.tech['featuresVolumeControl'] === false) {
      this.addClass('vjs-hidden');
    }

    this.on(player, 'loadstart', function () {
      if (player.tech['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }

  _inherits(MuteToggle, _Button);

  _createClass(MuteToggle, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(MuteToggle.prototype), 'createEl', this).call(this, 'div', {
        className: this.buildCSSClass(),
        innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
      });
    }
  }, {
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-mute-control ' + _get(Object.getPrototypeOf(MuteToggle.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  }, {
    key: 'update',
    value: function update() {
      var vol = this.player_.volume(),
          level = 3;

      if (vol === 0 || this.player_.muted()) {
        level = 0;
      } else if (vol < 0.33) {
        level = 1;
      } else if (vol < 0.67) {
        level = 2;
      }

      // Don't rewrite the button text if the actual text doesn't change.
      // This causes unnecessary and confusing information for screen reader users.
      // This check is needed because this function gets called every time the volume level is changed.
      var toMute = this.player_.muted() ? 'Unmute' : 'Mute';
      var localizedMute = this.localize(toMute);
      if (this.el_.children[0].children[0].innerHTML !== localizedMute) {
        this.el_.children[0].children[0].innerHTML = localizedMute;
      }

      /* TODO improve muted icon classes */
      for (var i = 0; i < 4; i++) {
        Lib.removeClass(this.el_, 'vjs-vol-' + i);
      }
      Lib.addClass(this.el_, 'vjs-vol-' + level);
    }
  }]);

  return MuteToggle;
})(_button2['default']);

_component2['default'].registerComponent('MuteToggle', MuteToggle);
exports['default'] = MuteToggle;
module.exports = exports['default'];

},{"../button":6,"../component":7,"../lib":46}],12:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _button = _dereq_('../button');

var _button2 = _interopRequireDefault(_button);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

/**
 * Button to toggle between play and pause
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var PlayToggle = (function (_Button) {
  function PlayToggle(player, options) {
    _classCallCheck(this, PlayToggle);

    _get(Object.getPrototypeOf(PlayToggle.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'play', this.handlePlay);
    this.on(player, 'pause', this.handlePause);
  }

  _inherits(PlayToggle, _Button);

  _createClass(PlayToggle, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-play-control ' + _get(Object.getPrototypeOf(PlayToggle.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleClick',

    // handleClick - Toggle between play and pause
    value: function handleClick() {
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    }
  }, {
    key: 'handlePlay',

    // handlePlay - Add the vjs-playing class to the element so it can change appearance
    value: function handlePlay() {
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');
      this.el_.children[0].children[0].innerHTML = this.localize('Pause'); // change the button text to "Pause"
    }
  }, {
    key: 'handlePause',

    // handlePause - Add the vjs-paused class to the element so it can change appearance
    value: function handlePause() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      this.el_.children[0].children[0].innerHTML = this.localize('Play'); // change the button text to "Play"
    }
  }]);

  return PlayToggle;
})(_button2['default']);

PlayToggle.prototype.buttonText = 'Play';

_button2['default'].registerComponent('PlayToggle', PlayToggle);
exports['default'] = PlayToggle;
module.exports = exports['default'];

},{"../button":6,"../lib":46}],13:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _menuMenuButtonJs = _dereq_('../../menu/menu-button.js');

var _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);

var _menuMenuJs = _dereq_('../../menu/menu.js');

var _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);

var _playbackRateMenuItemJs = _dereq_('./playback-rate-menu-item.js');

var _playbackRateMenuItemJs2 = _interopRequireDefault(_playbackRateMenuItemJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * The component for controlling the playback rate
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var PlaybackRateMenuButton = (function (_MenuButton) {
  function PlaybackRateMenuButton(player, options) {
    _classCallCheck(this, PlaybackRateMenuButton);

    _get(Object.getPrototypeOf(PlaybackRateMenuButton.prototype), 'constructor', this).call(this, player, options);

    this.updateVisibility();
    this.updateLabel();

    this.on(player, 'loadstart', this.updateVisibility);
    this.on(player, 'ratechange', this.updateLabel);
  }

  _inherits(PlaybackRateMenuButton, _MenuButton);

  _createClass(PlaybackRateMenuButton, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(PlaybackRateMenuButton.prototype), 'createEl', this).call(this);

      this.labelEl_ = Lib.createEl('div', {
        className: 'vjs-playback-rate-value',
        innerHTML: 1
      });

      el.appendChild(this.labelEl_);

      return el;
    }
  }, {
    key: 'createMenu',

    // Menu creation
    value: function createMenu() {
      var menu = new _menuMenuJs2['default'](this.player());
      var rates = this.player().options()['playbackRates'];

      if (rates) {
        for (var i = rates.length - 1; i >= 0; i--) {
          menu.addChild(new _playbackRateMenuItemJs2['default'](this.player(), { 'rate': rates[i] + 'x' }));
        }
      }

      return menu;
    }
  }, {
    key: 'updateARIAAttributes',
    value: function updateARIAAttributes() {
      // Current playback rate
      this.el().setAttribute('aria-valuenow', this.player().playbackRate());
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      // select next rate option
      var currentRate = this.player().playbackRate();
      var rates = this.player().options()['playbackRates'];
      // this will select first one if the last one currently selected
      var newRate = rates[0];
      for (var i = 0; i < rates.length; i++) {
        if (rates[i] > currentRate) {
          newRate = rates[i];
          break;
        }
      }
      this.player().playbackRate(newRate);
    }
  }, {
    key: 'playbackRateSupported',
    value: function playbackRateSupported() {
      return this.player().tech && this.player().tech['featuresPlaybackRate'] && this.player().options()['playbackRates'] && this.player().options()['playbackRates'].length > 0;
    }
  }, {
    key: 'updateVisibility',

    /**
     * Hide playback rate controls when they're no playback rate options to select
     */
    value: function updateVisibility() {
      if (this.playbackRateSupported()) {
        this.removeClass('vjs-hidden');
      } else {
        this.addClass('vjs-hidden');
      }
    }
  }, {
    key: 'updateLabel',

    /**
     * Update button label when rate changed
     */
    value: function updateLabel() {
      if (this.playbackRateSupported()) {
        this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
      }
    }
  }]);

  return PlaybackRateMenuButton;
})(_menuMenuButtonJs2['default']);

PlaybackRateMenuButton.prototype.buttonText = 'Playback Rate';
PlaybackRateMenuButton.prototype.className = 'vjs-playback-rate';

_menuMenuButtonJs2['default'].registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);
exports['default'] = PlaybackRateMenuButton;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu-button.js":49,"../../menu/menu.js":51,"./playback-rate-menu-item.js":14}],14:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _menuMenuItemJs = _dereq_('../../menu/menu-item.js');

var _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);

/**
 * The specific menu item type for selecting a playback rate
 *
 * @constructor
 */

var PlaybackRateMenuItem = (function (_MenuItem) {
  function PlaybackRateMenuItem(player, options) {
    _classCallCheck(this, PlaybackRateMenuItem);

    var label = options['rate'];
    var rate = parseFloat(label, 10);

    // Modify options for parent MenuItem class's init.
    options['label'] = label;
    options['selected'] = rate === 1;
    _get(Object.getPrototypeOf(PlaybackRateMenuItem.prototype), 'constructor', this).call(this, player, options);

    this.label = label;
    this.rate = rate;

    this.on(player, 'ratechange', this.update);
  }

  _inherits(PlaybackRateMenuItem, _MenuItem);

  _createClass(PlaybackRateMenuItem, [{
    key: 'handleClick',
    value: function handleClick() {
      _get(Object.getPrototypeOf(PlaybackRateMenuItem.prototype), 'handleClick', this).call(this);
      this.player().playbackRate(this.rate);
    }
  }, {
    key: 'update',
    value: function update() {
      this.selected(this.player().playbackRate() === this.rate);
    }
  }]);

  return PlaybackRateMenuItem;
})(_menuMenuItemJs2['default']);

PlaybackRateMenuItem.prototype.contentElType = 'button';

_menuMenuItemJs2['default'].registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);
exports['default'] = PlaybackRateMenuItem;
module.exports = exports['default'];

},{"../../menu/menu-item.js":50}],15:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * Shows load progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var LoadProgressBar = (function (_Component) {
  function LoadProgressBar(player, options) {
    _classCallCheck(this, LoadProgressBar);

    _get(Object.getPrototypeOf(LoadProgressBar.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'progress', this.update);
  }

  _inherits(LoadProgressBar, _Component);

  _createClass(LoadProgressBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(LoadProgressBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-load-progress',
        innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
      });
    }
  }, {
    key: 'update',
    value: function update() {
      var buffered = this.player_.buffered();
      var duration = this.player_.duration();
      var bufferedEnd = this.player_.bufferedEnd();
      var children = this.el_.children;

      // get the percent width of a time compared to the total end
      var percentify = function percentify(time, end) {
        var percent = time / end || 0; // no NaN
        return (percent >= 1 ? 1 : percent) * 100 + '%';
      };

      // update the width of the progress bar
      this.el_.style.width = percentify(bufferedEnd, duration);

      // add child elements to represent the individual buffered time ranges
      for (var i = 0; i < buffered.length; i++) {
        var start = buffered.start(i);
        var end = buffered.end(i);
        var part = children[i];

        if (!part) {
          part = this.el_.appendChild(Lib.createEl());
        }

        // set the percent based on the width of the progress bar (bufferedEnd)
        part.style.left = percentify(start, bufferedEnd);
        part.style.width = percentify(end - start, bufferedEnd);
      }

      // remove unused buffered range elements
      for (var i = children.length; i > buffered.length; i--) {
        this.el_.removeChild(children[i - 1]);
      }
    }
  }]);

  return LoadProgressBar;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('LoadProgressBar', LoadProgressBar);
exports['default'] = LoadProgressBar;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib.js":46}],16:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * Shows play progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var PlayProgressBar = (function (_Component) {
  function PlayProgressBar() {
    _classCallCheck(this, PlayProgressBar);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(PlayProgressBar, _Component);

  _createClass(PlayProgressBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(PlayProgressBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-play-progress',
        innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
      });
    }
  }]);

  return PlayProgressBar;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('PlayProgressBar', PlayProgressBar);
exports['default'] = PlayProgressBar;
module.exports = exports['default'];

},{"../../component.js":7}],17:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _seekBarJs = _dereq_('./seek-bar.js');

var _seekBarJs2 = _interopRequireDefault(_seekBarJs);

/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var ProgressControl = (function (_Component) {
  function ProgressControl() {
    _classCallCheck(this, ProgressControl);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(ProgressControl, _Component);

  _createClass(ProgressControl, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(ProgressControl.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-progress-control vjs-control'
      });
    }
  }]);

  return ProgressControl;
})(_componentJs2['default']);

ProgressControl.prototype.options_ = {
  children: {
    'seekBar': {}
  }
};

_componentJs2['default'].registerComponent('ProgressControl', ProgressControl);
exports['default'] = ProgressControl;
module.exports = exports['default'];

},{"../../component.js":7,"./seek-bar.js":18}],18:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _sliderSliderJs = _dereq_('../../slider/slider.js');

var _sliderSliderJs2 = _interopRequireDefault(_sliderSliderJs);

var _loadProgressBarJs = _dereq_('./load-progress-bar.js');

var _loadProgressBarJs2 = _interopRequireDefault(_loadProgressBarJs);

var _playProgressBarJs = _dereq_('./play-progress-bar.js');

var _playProgressBarJs2 = _interopRequireDefault(_playProgressBarJs);

var _seekHandleJs = _dereq_('./seek-handle.js');

var _seekHandleJs2 = _interopRequireDefault(_seekHandleJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * Seek Bar and holder for the progress bars
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var SeekBar = (function (_Slider) {
  function SeekBar(player, options) {
    _classCallCheck(this, SeekBar);

    _get(Object.getPrototypeOf(SeekBar.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'timeupdate', this.updateARIAAttributes);
    player.ready(Lib.bind(this, this.updateARIAAttributes));
  }

  _inherits(SeekBar, _Slider);

  _createClass(SeekBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(SeekBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-progress-holder',
        'aria-label': 'video progress bar'
      });
    }
  }, {
    key: 'updateARIAAttributes',
    value: function updateARIAAttributes() {
      // Allows for smooth scrubbing, when player can't keep up.
      var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      this.el_.setAttribute('aria-valuenow', Lib.round(this.getPercent() * 100, 2)); // machine readable value of progress bar (percentage complete)
      this.el_.setAttribute('aria-valuetext', Lib.formatTime(time, this.player_.duration())); // human readable value of progress bar (time complete)
    }
  }, {
    key: 'getPercent',
    value: function getPercent() {
      var percent = this.player_.currentTime() / this.player_.duration();
      return percent >= 1 ? 1 : percent;
    }
  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      _get(Object.getPrototypeOf(SeekBar.prototype), 'handleMouseDown', this).call(this, event);

      this.player_.scrubbing(true);

      this.videoWasPlaying = !this.player_.paused();
      this.player_.pause();
    }
  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      var newTime = this.calculateDistance(event) * this.player_.duration();

      // Don't let video end while scrubbing.
      if (newTime === this.player_.duration()) {
        newTime = newTime - 0.1;
      }

      // Set new time (tell player to seek to new time)
      this.player_.currentTime(newTime);
    }
  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp(event) {
      _get(Object.getPrototypeOf(SeekBar.prototype), 'handleMouseUp', this).call(this, event);

      this.player_.scrubbing(false);
      if (this.videoWasPlaying) {
        this.player_.play();
      }
    }
  }, {
    key: 'stepForward',
    value: function stepForward() {
      this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users
    }
  }, {
    key: 'stepBack',
    value: function stepBack() {
      this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users
    }
  }]);

  return SeekBar;
})(_sliderSliderJs2['default']);

SeekBar.prototype.options_ = {
  children: {
    'loadProgressBar': {},
    'playProgressBar': {},
    'seekHandle': {}
  },
  'barName': 'playProgressBar',
  'handleName': 'seekHandle'
};

SeekBar.prototype.playerEvent = 'timeupdate';

_sliderSliderJs2['default'].registerComponent('SeekBar', SeekBar);
exports['default'] = SeekBar;
module.exports = exports['default'];

},{"../../lib.js":46,"../../slider/slider.js":58,"./load-progress-bar.js":15,"./play-progress-bar.js":16,"./seek-handle.js":19}],19:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _sliderSliderHandleJs = _dereq_('../../slider/slider-handle.js');

var _sliderSliderHandleJs2 = _interopRequireDefault(_sliderSliderHandleJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * The Seek Handle shows the current position of the playhead during playback,
 * and can be dragged to adjust the playhead.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var SeekHandle = (function (_SliderHandle) {
  function SeekHandle(player, options) {
    _classCallCheck(this, SeekHandle);

    _get(Object.getPrototypeOf(SeekHandle.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(SeekHandle, _SliderHandle);

  _createClass(SeekHandle, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl() {
      return _get(Object.getPrototypeOf(SeekHandle.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-seek-handle',
        'aria-live': 'off'
      });
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      var time = this.player_.scrubbing ? this.player_.getCache().currentTime : this.player_.currentTime();
      this.el_.innerHTML = '<span class="vjs-control-text">' + Lib.formatTime(time, this.player_.duration()) + '</span>';
    }
  }]);

  return SeekHandle;
})(_sliderSliderHandleJs2['default']);

/**
 * The default value for the handle content, which may be read by screen readers
 *
 * @type {String}
 * @private
 */
SeekHandle.prototype.defaultValue = '00:00';

_sliderSliderHandleJs2['default'].registerComponent('SeekHandle', SeekHandle);
exports['default'] = SeekHandle;
module.exports = exports['default'];

},{"../../lib.js":46,"../../slider/slider-handle.js":57}],20:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _spacerJs = _dereq_('./spacer.js');

var _spacerJs2 = _interopRequireDefault(_spacerJs);

/**
 * Spacer specifically meant to be used as an insertion point for new plugins, etc.
 *
 * @param {Player|Object} player
 * @param {Obect=} options
 */

var CustomControlSpacer = (function (_Spacer) {
  function CustomControlSpacer() {
    _classCallCheck(this, CustomControlSpacer);

    if (_Spacer != null) {
      _Spacer.apply(this, arguments);
    }
  }

  _inherits(CustomControlSpacer, _Spacer);

  _createClass(CustomControlSpacer, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-custom-control-spacer ' + _get(Object.getPrototypeOf(CustomControlSpacer.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(CustomControlSpacer.prototype), 'createEl', this).call(this, {
        className: this.buildCSSClass()
      });
    }
  }]);

  return CustomControlSpacer;
})(_spacerJs2['default']);

_spacerJs2['default'].registerComponent('CustomControlSpacer', CustomControlSpacer);

exports['default'] = CustomControlSpacer;
module.exports = exports['default'];

},{"./spacer.js":21}],21:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * Just an empty spacer element that can be used as an append point for plugins, etc.
 * Also can be used to create space between elements when necessary.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 */

var Spacer = (function (_Component) {
  function Spacer() {
    _classCallCheck(this, Spacer);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(Spacer, _Component);

  _createClass(Spacer, [{
    key: 'buildCSSClass',
    value: function buildCSSClass() {
      return 'vjs-spacer ' + _get(Object.getPrototypeOf(Spacer.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl(props) {
      return _get(Object.getPrototypeOf(Spacer.prototype), 'createEl', this).call(this, 'div', {
        className: this.buildCSSClass()
      });
    }
  }]);

  return Spacer;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('Spacer', Spacer);

exports['default'] = Spacer;
module.exports = exports['default'];

},{"../../component.js":7}],22:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');

var _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);

var CaptionSettingsMenuItem = (function (_TextTrackMenuItem) {
  function CaptionSettingsMenuItem(player, options) {
    _classCallCheck(this, CaptionSettingsMenuItem);

    options['track'] = {
      'kind': options['kind'],
      'player': player,
      'label': options['kind'] + ' settings',
      'default': false,
      mode: 'disabled'
    };

    _get(Object.getPrototypeOf(CaptionSettingsMenuItem.prototype), 'constructor', this).call(this, player, options);
    this.addClass('vjs-texttrack-settings');
  }

  _inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);

  _createClass(CaptionSettingsMenuItem, [{
    key: 'handleClick',
    value: function handleClick() {
      this.player().getChild('textTrackSettings').show();
    }
  }]);

  return CaptionSettingsMenuItem;
})(_textTrackMenuItemJs2['default']);

_textTrackMenuItemJs2['default'].registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);
exports['default'] = CaptionSettingsMenuItem;
module.exports = exports['default'];

},{"./text-track-menu-item.js":29}],23:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _textTrackButtonJs = _dereq_('./text-track-button.js');

var _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);

var _captionSettingsMenuItemJs = _dereq_('./caption-settings-menu-item.js');

var _captionSettingsMenuItemJs2 = _interopRequireDefault(_captionSettingsMenuItemJs);

/**
 * The button component for toggling and selecting captions
 *
 * @constructor
 */

var CaptionsButton = (function (_TextTrackButton) {
  function CaptionsButton(player, options, ready) {
    _classCallCheck(this, CaptionsButton);

    _get(Object.getPrototypeOf(CaptionsButton.prototype), 'constructor', this).call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Captions Menu');
  }

  _inherits(CaptionsButton, _TextTrackButton);

  _createClass(CaptionsButton, [{
    key: 'update',
    value: function update() {
      var threshold = 2;
      _get(Object.getPrototypeOf(CaptionsButton.prototype), 'update', this).call(this);

      // if native, then threshold is 1 because no settings button
      if (this.player().tech && this.player().tech['featuresNativeTextTracks']) {
        threshold = 1;
      }

      if (this.items && this.items.length > threshold) {
        this.show();
      } else {
        this.hide();
      }
    }
  }, {
    key: 'createItems',
    value: function createItems() {
      var items = [];

      if (!(this.player().tech && this.player().tech['featuresNativeTextTracks'])) {
        items.push(new _captionSettingsMenuItemJs2['default'](this.player_, { 'kind': this.kind_ }));
      }

      return _get(Object.getPrototypeOf(CaptionsButton.prototype), 'createItems', this).call(this, items);
    }
  }]);

  return CaptionsButton;
})(_textTrackButtonJs2['default']);

CaptionsButton.prototype.kind_ = 'captions';
CaptionsButton.prototype.buttonText = 'Captions';
CaptionsButton.prototype.className = 'vjs-captions-button';

_textTrackButtonJs2['default'].registerComponent('CaptionsButton', CaptionsButton);
exports['default'] = CaptionsButton;
module.exports = exports['default'];

},{"./caption-settings-menu-item.js":22,"./text-track-button.js":28}],24:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _textTrackButtonJs = _dereq_('./text-track-button.js');

var _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);

var _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');

var _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);

var _chaptersTrackMenuItemJs = _dereq_('./chapters-track-menu-item.js');

var _chaptersTrackMenuItemJs2 = _interopRequireDefault(_chaptersTrackMenuItemJs);

var _menuMenuJs = _dereq_('../../menu/menu.js');

var _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

// Chapters act much differently than other text tracks
// Cues are navigation vs. other tracks of alternative languages
/**
 * The button component for toggling and selecting chapters
 *
 * @constructor
 */

var ChaptersButton = (function (_TextTrackButton) {
  function ChaptersButton(player, options, ready) {
    _classCallCheck(this, ChaptersButton);

    _get(Object.getPrototypeOf(ChaptersButton.prototype), 'constructor', this).call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Chapters Menu');
  }

  _inherits(ChaptersButton, _TextTrackButton);

  _createClass(ChaptersButton, [{
    key: 'createItems',

    // Create a menu item for each text track
    value: function createItems() {
      var items = [];

      var tracks = this.player_.textTracks();

      if (!tracks) {
        return items;
      }

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (track['kind'] === this.kind_) {
          items.push(new _textTrackMenuItemJs2['default'](this.player_, {
            'track': track
          }));
        }
      }

      return items;
    }
  }, {
    key: 'createMenu',
    value: function createMenu() {
      var tracks = this.player_.textTracks() || [];
      var chaptersTrack = undefined;
      var items = this.items = [];

      for (var i = 0, l = tracks.length; i < l; i++) {
        var track = tracks[i];
        if (track['kind'] === this.kind_) {
          if (!track.cues) {
            track['mode'] = 'hidden';
            /* jshint loopfunc:true */
            // TODO see if we can figure out a better way of doing this https://github.com/videojs/video.js/issues/1864
            _globalWindow2['default'].setTimeout(Lib.bind(this, function () {
              this.createMenu();
            }), 100);
            /* jshint loopfunc:false */
          } else {
            chaptersTrack = track;
            break;
          }
        }
      }

      var menu = this.menu;
      if (menu === undefined) {
        menu = new _menuMenuJs2['default'](this.player_);
        menu.contentEl().appendChild(Lib.createEl('li', {
          className: 'vjs-menu-title',
          innerHTML: Lib.capitalize(this.kind_),
          tabindex: -1
        }));
      }

      if (chaptersTrack) {
        var cues = chaptersTrack['cues'],
            cue = undefined;

        for (var i = 0, l = cues.length; i < l; i++) {
          cue = cues[i];

          var mi = new _chaptersTrackMenuItemJs2['default'](this.player_, {
            'track': chaptersTrack,
            'cue': cue
          });

          items.push(mi);

          menu.addChild(mi);
        }
        this.addChild(menu);
      }

      if (this.items.length > 0) {
        this.show();
      }

      return menu;
    }
  }]);

  return ChaptersButton;
})(_textTrackButtonJs2['default']);

ChaptersButton.prototype.kind_ = 'chapters';
ChaptersButton.prototype.buttonText = 'Chapters';
ChaptersButton.prototype.className = 'vjs-chapters-button';

_textTrackButtonJs2['default'].registerComponent('ChaptersButton', ChaptersButton);
exports['default'] = ChaptersButton;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu.js":51,"./chapters-track-menu-item.js":25,"./text-track-button.js":28,"./text-track-menu-item.js":29,"global/window":2}],25:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _menuMenuItemJs = _dereq_('../../menu/menu-item.js');

var _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * @constructor
 */

var ChaptersTrackMenuItem = (function (_MenuItem) {
  function ChaptersTrackMenuItem(player, options) {
    _classCallCheck(this, ChaptersTrackMenuItem);

    var track = options['track'];
    var cue = options['cue'];
    var currentTime = player.currentTime();

    // Modify options for parent MenuItem class's init.
    options['label'] = cue.text;
    options['selected'] = cue['startTime'] <= currentTime && currentTime < cue['endTime'];
    _get(Object.getPrototypeOf(ChaptersTrackMenuItem.prototype), 'constructor', this).call(this, player, options);

    this.track = track;
    this.cue = cue;
    track.addEventListener('cuechange', Lib.bind(this, this.update));
  }

  _inherits(ChaptersTrackMenuItem, _MenuItem);

  _createClass(ChaptersTrackMenuItem, [{
    key: 'handleClick',
    value: function handleClick() {
      _get(Object.getPrototypeOf(ChaptersTrackMenuItem.prototype), 'handleClick', this).call(this);
      this.player_.currentTime(this.cue.startTime);
      this.update(this.cue.startTime);
    }
  }, {
    key: 'update',
    value: function update() {
      var cue = this.cue;
      var currentTime = this.player_.currentTime();

      // vjs.log(currentTime, cue.startTime);
      this.selected(cue['startTime'] <= currentTime && currentTime < cue['endTime']);
    }
  }]);

  return ChaptersTrackMenuItem;
})(_menuMenuItemJs2['default']);

_menuMenuItemJs2['default'].registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);
exports['default'] = ChaptersTrackMenuItem;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu-item.js":50}],26:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');

var _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);

/**
 * A special menu item for turning of a specific type of text track
 *
 * @constructor
 */

var OffTextTrackMenuItem = (function (_TextTrackMenuItem) {
  function OffTextTrackMenuItem(player, options) {
    _classCallCheck(this, OffTextTrackMenuItem);

    // Create pseudo track info
    // Requires options['kind']
    options['track'] = {
      'kind': options['kind'],
      'player': player,
      'label': options['kind'] + ' off',
      'default': false,
      'mode': 'disabled'
    };

    _get(Object.getPrototypeOf(OffTextTrackMenuItem.prototype), 'constructor', this).call(this, player, options);
    this.selected(true);
  }

  _inherits(OffTextTrackMenuItem, _TextTrackMenuItem);

  _createClass(OffTextTrackMenuItem, [{
    key: 'handleTracksChange',
    value: function handleTracksChange(event) {
      var tracks = this.player().textTracks();
      var selected = true;

      for (var i = 0, l = tracks.length; i < l; i++) {
        var track = tracks[i];
        if (track['kind'] === this.track['kind'] && track['mode'] === 'showing') {
          selected = false;
          break;
        }
      }

      this.selected(selected);
    }
  }]);

  return OffTextTrackMenuItem;
})(_textTrackMenuItemJs2['default']);

_textTrackMenuItemJs2['default'].registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);
exports['default'] = OffTextTrackMenuItem;
module.exports = exports['default'];

},{"./text-track-menu-item.js":29}],27:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _textTrackButtonJs = _dereq_('./text-track-button.js');

var _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);

/**
 * The button component for toggling and selecting subtitles
 *
 * @constructor
 */

var SubtitlesButton = (function (_TextTrackButton) {
  function SubtitlesButton(player, options, ready) {
    _classCallCheck(this, SubtitlesButton);

    _get(Object.getPrototypeOf(SubtitlesButton.prototype), 'constructor', this).call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Subtitles Menu');
  }

  _inherits(SubtitlesButton, _TextTrackButton);

  return SubtitlesButton;
})(_textTrackButtonJs2['default']);

SubtitlesButton.prototype.kind_ = 'subtitles';
SubtitlesButton.prototype.buttonText = 'Subtitles';
SubtitlesButton.prototype.className = 'vjs-subtitles-button';

_textTrackButtonJs2['default'].registerComponent('SubtitlesButton', SubtitlesButton);
exports['default'] = SubtitlesButton;
module.exports = exports['default'];

},{"./text-track-button.js":28}],28:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x2,
    property = _x3,
    receiver = _x4; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _menuMenuButtonJs = _dereq_('../../menu/menu-button.js');

var _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

var _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');

var _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);

var _offTextTrackMenuItemJs = _dereq_('./off-text-track-menu-item.js');

var _offTextTrackMenuItemJs2 = _interopRequireDefault(_offTextTrackMenuItemJs);

/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @constructor
 */

var TextTrackButton = (function (_MenuButton) {
  function TextTrackButton(player, options) {
    _classCallCheck(this, TextTrackButton);

    _get(Object.getPrototypeOf(TextTrackButton.prototype), 'constructor', this).call(this, player, options);

    var tracks = this.player_.textTracks();

    if (this.items.length <= 1) {
      this.hide();
    }

    if (!tracks) {
      return;
    }

    var updateHandler = Lib.bind(this, this.update);
    tracks.addEventListener('removetrack', updateHandler);
    tracks.addEventListener('addtrack', updateHandler);

    this.player_.on('dispose', function () {
      tracks.removeEventListener('removetrack', updateHandler);
      tracks.removeEventListener('addtrack', updateHandler);
    });
  }

  _inherits(TextTrackButton, _MenuButton);

  _createClass(TextTrackButton, [{
    key: 'createItems',

    // Create a menu item for each text track
    value: function createItems() {
      var items = arguments[0] === undefined ? [] : arguments[0];

      // Add an OFF menu item to turn all tracks off
      items.push(new _offTextTrackMenuItemJs2['default'](this.player_, { 'kind': this.kind_ }));

      var tracks = this.player_.textTracks();

      if (!tracks) {
        return items;
      }

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        // only add tracks that are of the appropriate kind and have a label
        if (track['kind'] === this.kind_) {
          items.push(new _textTrackMenuItemJs2['default'](this.player_, {
            'track': track
          }));
        }
      }

      return items;
    }
  }]);

  return TextTrackButton;
})(_menuMenuButtonJs2['default']);

_menuMenuButtonJs2['default'].registerComponent('TextTrackButton', TextTrackButton);
exports['default'] = TextTrackButton;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu-button.js":49,"./off-text-track-menu-item.js":26,"./text-track-menu-item.js":29}],29:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _menuMenuItemJs = _dereq_('../../menu/menu-item.js');

var _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * The specific menu item type for selecting a language within a text track kind
 *
 * @constructor
 */

var TextTrackMenuItem = (function (_MenuItem) {
  function TextTrackMenuItem(player, options) {
    var _this2 = this;

    _classCallCheck(this, TextTrackMenuItem);

    var track = options['track'];
    var tracks = player.textTracks();

    // Modify options for parent MenuItem class's init.
    options['label'] = track['label'] || track['language'] || 'Unknown';
    options['selected'] = track['default'] || track['mode'] === 'showing';
    _get(Object.getPrototypeOf(TextTrackMenuItem.prototype), 'constructor', this).call(this, player, options);

    this.track = track;

    if (tracks) {
      (function () {
        var changeHandler = Lib.bind(_this2, _this2.handleTracksChange);

        tracks.addEventListener('change', changeHandler);
        _this2.on('dispose', function () {
          tracks.removeEventListener('change', changeHandler);
        });
      })();
    }

    // iOS7 doesn't dispatch change events to TextTrackLists when an
    // associated track's mode changes. Without something like
    // Object.observe() (also not present on iOS7), it's not
    // possible to detect changes to the mode attribute and polyfill
    // the change event. As a poor substitute, we manually dispatch
    // change events whenever the controls modify the mode.
    if (tracks && tracks.onchange === undefined) {
      (function () {
        var event = undefined;

        _this2.on(['tap', 'click'], function () {
          if (typeof _globalWindow2['default'].Event !== 'object') {
            // Android 2.3 throws an Illegal Constructor error for window.Event
            try {
              event = new _globalWindow2['default'].Event('change');
            } catch (err) {}
          }

          if (!event) {
            event = _globalDocument2['default'].createEvent('Event');
            event.initEvent('change', true, true);
          }

          tracks.dispatchEvent(event);
        });
      })();
    }
  }

  _inherits(TextTrackMenuItem, _MenuItem);

  _createClass(TextTrackMenuItem, [{
    key: 'handleClick',
    value: function handleClick(event) {
      var kind = this.track['kind'];
      var tracks = this.player_.textTracks();

      _get(Object.getPrototypeOf(TextTrackMenuItem.prototype), 'handleClick', this).call(this, event);

      if (!tracks) return;

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        if (track['kind'] !== kind) {
          continue;
        }

        if (track === this.track) {
          track['mode'] = 'showing';
        } else {
          track['mode'] = 'disabled';
        }
      }
    }
  }, {
    key: 'handleTracksChange',
    value: function handleTracksChange(event) {
      this.selected(this.track['mode'] === 'showing');
    }
  }]);

  return TextTrackMenuItem;
})(_menuMenuItemJs2['default']);

_menuMenuItemJs2['default'].registerComponent('TextTrackMenuItem', TextTrackMenuItem);
exports['default'] = TextTrackMenuItem;
module.exports = exports['default'];

},{"../../lib.js":46,"../../menu/menu-item.js":50,"global/document":1,"global/window":2}],30:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * Displays the current time
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var CurrentTimeDisplay = (function (_Component) {
  function CurrentTimeDisplay(player, options) {
    _classCallCheck(this, CurrentTimeDisplay);

    _get(Object.getPrototypeOf(CurrentTimeDisplay.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(CurrentTimeDisplay, _Component);

  _createClass(CurrentTimeDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(CurrentTimeDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-current-time vjs-time-control vjs-control'
      });

      this.contentEl_ = Lib.createEl('div', {
        className: 'vjs-current-time-display',
        innerHTML: '<span class="vjs-control-text">Current Time </span>' + '0:00', // label the current time for screen reader users
        'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
      });

      el.appendChild(this.contentEl_);
      return el;
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      // Allows for smooth scrubbing, when player can't keep up.
      var time = this.player_.scrubbing ? this.player_.getCache().currentTime : this.player_.currentTime();
      var localizedText = this.localize('Current Time');
      var formattedTime = Lib.formatTime(time, this.player_.duration());
      this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> ' + formattedTime;
    }
  }]);

  return CurrentTimeDisplay;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);
exports['default'] = CurrentTimeDisplay;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib.js":46}],31:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * Displays the duration
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var DurationDisplay = (function (_Component) {
  function DurationDisplay(player, options) {
    _classCallCheck(this, DurationDisplay);

    _get(Object.getPrototypeOf(DurationDisplay.prototype), 'constructor', this).call(this, player, options);

    // this might need to be changed to 'durationchange' instead of 'timeupdate' eventually,
    // however the durationchange event fires before this.player_.duration() is set,
    // so the value cannot be written out using this method.
    // Once the order of durationchange and this.player_.duration() being set is figured out,
    // this can be updated.
    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(DurationDisplay, _Component);

  _createClass(DurationDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(DurationDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-duration vjs-time-control vjs-control'
      });

      this.contentEl_ = Lib.createEl('div', {
        className: 'vjs-duration-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> 0:00', // label the duration time for screen reader users
        'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
      });

      el.appendChild(this.contentEl_);
      return el;
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      var duration = this.player_.duration();
      if (duration) {
        var localizedText = this.localize('Duration Time');
        var formattedTime = Lib.formatTime(duration);
        this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> ' + formattedTime; // label the duration time for screen reader users
      }
    }
  }]);

  return DurationDisplay;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('DurationDisplay', DurationDisplay);
exports['default'] = DurationDisplay;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib.js":46}],32:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _lib = _dereq_('../../lib');

var Lib = _interopRequireWildcard(_lib);

/**
 * Displays the time left in the video
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var RemainingTimeDisplay = (function (_Component) {
  function RemainingTimeDisplay(player, options) {
    _classCallCheck(this, RemainingTimeDisplay);

    _get(Object.getPrototypeOf(RemainingTimeDisplay.prototype), 'constructor', this).call(this, player, options);

    this.on(player, 'timeupdate', this.updateContent);
  }

  _inherits(RemainingTimeDisplay, _Component);

  _createClass(RemainingTimeDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(RemainingTimeDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-remaining-time vjs-time-control vjs-control'
      });

      this.contentEl_ = Lib.createEl('div', {
        className: 'vjs-remaining-time-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> -0:00', // label the remaining time for screen reader users
        'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
      });

      el.appendChild(this.contentEl_);
      return el;
    }
  }, {
    key: 'updateContent',
    value: function updateContent() {
      if (this.player_.duration()) {
        var localizedText = this.localize('Remaining Time');
        var formattedTime = Lib.formatTime(this.player_.remainingTime());
        this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> -' + formattedTime;
      }

      // Allows for smooth scrubbing, when player can't keep up.
      // var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
      // this.contentEl_.innerHTML = vjs.formatTime(time, this.player_.duration());
    }
  }]);

  return RemainingTimeDisplay;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);
exports['default'] = RemainingTimeDisplay;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib":46}],33:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * The separator between the current time and duration
 *
 * Can be hidden if it's not needed in the design.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var TimeDivider = (function (_Component) {
  function TimeDivider() {
    _classCallCheck(this, TimeDivider);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(TimeDivider, _Component);

  _createClass(TimeDivider, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(TimeDivider.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-time-control vjs-time-divider',
        innerHTML: '<div><span>/</span></div>'
      });
    }
  }]);

  return TimeDivider;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('TimeDivider', TimeDivider);
exports['default'] = TimeDivider;
module.exports = exports['default'];

},{"../../component.js":7}],34:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _sliderSliderJs = _dereq_('../../slider/slider.js');

var _sliderSliderJs2 = _interopRequireDefault(_sliderSliderJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

// Required children

var _volumeHandleJs = _dereq_('./volume-handle.js');

var _volumeHandleJs2 = _interopRequireDefault(_volumeHandleJs);

var _volumeLevelJs = _dereq_('./volume-level.js');

var _volumeLevelJs2 = _interopRequireDefault(_volumeLevelJs);

/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeBar = (function (_Slider) {
  function VolumeBar(player, options) {
    _classCallCheck(this, VolumeBar);

    _get(Object.getPrototypeOf(VolumeBar.prototype), 'constructor', this).call(this, player, options);
    this.on(player, 'volumechange', this.updateARIAAttributes);
    player.ready(Lib.bind(this, this.updateARIAAttributes));
  }

  _inherits(VolumeBar, _Slider);

  _createClass(VolumeBar, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeBar.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-bar',
        'aria-label': 'volume level'
      });
    }
  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      if (this.player_.muted()) {
        this.player_.muted(false);
      }

      this.player_.volume(this.calculateDistance(event));
    }
  }, {
    key: 'getPercent',
    value: function getPercent() {
      if (this.player_.muted()) {
        return 0;
      } else {
        return this.player_.volume();
      }
    }
  }, {
    key: 'stepForward',
    value: function stepForward() {
      this.player_.volume(this.player_.volume() + 0.1);
    }
  }, {
    key: 'stepBack',
    value: function stepBack() {
      this.player_.volume(this.player_.volume() - 0.1);
    }
  }, {
    key: 'updateARIAAttributes',
    value: function updateARIAAttributes() {
      // Current value of volume bar as a percentage
      this.el_.setAttribute('aria-valuenow', Lib.round(this.player_.volume() * 100, 2));
      this.el_.setAttribute('aria-valuetext', Lib.round(this.player_.volume() * 100, 2) + '%');
    }
  }]);

  return VolumeBar;
})(_sliderSliderJs2['default']);

VolumeBar.prototype.options_ = {
  children: {
    'volumeLevel': {},
    'volumeHandle': {}
  },
  'barName': 'volumeLevel',
  'handleName': 'volumeHandle'
};

VolumeBar.prototype.playerEvent = 'volumechange';

_sliderSliderJs2['default'].registerComponent('VolumeBar', VolumeBar);
exports['default'] = VolumeBar;
module.exports = exports['default'];

},{"../../lib.js":46,"../../slider/slider.js":58,"./volume-handle.js":36,"./volume-level.js":37}],35:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _libJs = _dereq_('../../lib.js');

var Lib = _interopRequireWildcard(_libJs);

// Required children

var _volumeBarJs = _dereq_('./volume-bar.js');

var _volumeBarJs2 = _interopRequireDefault(_volumeBarJs);

/**
 * The component for controlling the volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeControl = (function (_Component) {
  function VolumeControl(player, options) {
    _classCallCheck(this, VolumeControl);

    _get(Object.getPrototypeOf(VolumeControl.prototype), 'constructor', this).call(this, player, options);

    // hide volume controls when they're not supported by the current tech
    if (player.tech && player.tech['featuresVolumeControl'] === false) {
      this.addClass('vjs-hidden');
    }
    this.on(player, 'loadstart', function () {
      if (player.tech['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }

  _inherits(VolumeControl, _Component);

  _createClass(VolumeControl, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeControl.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-control vjs-control'
      });
    }
  }]);

  return VolumeControl;
})(_componentJs2['default']);

VolumeControl.prototype.options_ = {
  children: {
    'volumeBar': {}
  }
};

_componentJs2['default'].registerComponent('VolumeControl', VolumeControl);
exports['default'] = VolumeControl;
module.exports = exports['default'];

},{"../../component.js":7,"../../lib.js":46,"./volume-bar.js":34}],36:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _sliderSliderHandleJs = _dereq_('../../slider/slider-handle.js');

var _sliderSliderHandleJs2 = _interopRequireDefault(_sliderSliderHandleJs);

/**
 * The volume handle can be dragged to adjust the volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeHandle = (function (_SliderHandle) {
  function VolumeHandle() {
    _classCallCheck(this, VolumeHandle);

    if (_SliderHandle != null) {
      _SliderHandle.apply(this, arguments);
    }
  }

  _inherits(VolumeHandle, _SliderHandle);

  _createClass(VolumeHandle, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeHandle.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-handle'
      });
    }
  }]);

  return VolumeHandle;
})(_sliderSliderHandleJs2['default']);

VolumeHandle.prototype.defaultValue = '00:00';

_sliderSliderHandleJs2['default'].registerComponent('VolumeHandle', VolumeHandle);
exports['default'] = VolumeHandle;
module.exports = exports['default'];

},{"../../slider/slider-handle.js":57}],37:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * Shows volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var VolumeLevel = (function (_Component) {
  function VolumeLevel() {
    _classCallCheck(this, VolumeLevel);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(VolumeLevel, _Component);

  _createClass(VolumeLevel, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeLevel.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-level',
        innerHTML: '<span class="vjs-control-text"></span>'
      });
    }
  }]);

  return VolumeLevel;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('VolumeLevel', VolumeLevel);
exports['default'] = VolumeLevel;
module.exports = exports['default'];

},{"../../component.js":7}],38:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _buttonJs = _dereq_('../button.js');

var _buttonJs2 = _interopRequireDefault(_buttonJs);

var _menuMenuJs = _dereq_('../menu/menu.js');

var _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);

var _menuMenuButtonJs = _dereq_('../menu/menu-button.js');

var _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);

var _muteToggleJs = _dereq_('./mute-toggle.js');

var _muteToggleJs2 = _interopRequireDefault(_muteToggleJs);

var _libJs = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_libJs);

var _volumeControlVolumeBarJs = _dereq_('./volume-control/volume-bar.js');

var _volumeControlVolumeBarJs2 = _interopRequireDefault(_volumeControlVolumeBarJs);

/**
 * Menu button with a popup for showing the volume slider.
 * @constructor
 */

var VolumeMenuButton = (function (_MenuButton) {
  function VolumeMenuButton(player, options) {
    _classCallCheck(this, VolumeMenuButton);

    _get(Object.getPrototypeOf(VolumeMenuButton.prototype), 'constructor', this).call(this, player, options);

    // Same listeners as MuteToggle
    this.on(player, 'volumechange', this.volumeUpdate);

    // hide mute toggle if the current tech doesn't support volume control
    if (player.tech && player.tech['featuresVolumeControl'] === false) {
      this.addClass('vjs-hidden');
    }
    this.on(player, 'loadstart', function () {
      if (player.tech['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
    this.addClass('vjs-menu-button');
  }

  _inherits(VolumeMenuButton, _MenuButton);

  _createClass(VolumeMenuButton, [{
    key: 'createMenu',
    value: function createMenu() {
      var menu = new _menuMenuJs2['default'](this.player_, {
        contentElType: 'div'
      });

      // The volumeBar is vertical by default in the base theme when used with a VolumeMenuButton
      var options = this.options_['volumeBar'] || {};
      options['vertical'] = options['vertical'] || true;

      var vc = new _volumeControlVolumeBarJs2['default'](this.player_, options);

      vc.on('focus', function () {
        menu.lockShowing();
      });
      vc.on('blur', function () {
        menu.unlockShowing();
      });
      menu.addChild(vc);
      return menu;
    }
  }, {
    key: 'handleClick',
    value: function handleClick() {
      _muteToggleJs2['default'].prototype.handleClick.call(this);
      _get(Object.getPrototypeOf(VolumeMenuButton.prototype), 'handleClick', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(VolumeMenuButton.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-volume-menu-button vjs-menu-button vjs-control vjs-button',
        innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
      });
    }
  }]);

  return VolumeMenuButton;
})(_menuMenuButtonJs2['default']);

VolumeMenuButton.prototype.volumeUpdate = _muteToggleJs2['default'].prototype.update;

_buttonJs2['default'].registerComponent('VolumeMenuButton', VolumeMenuButton);
exports['default'] = VolumeMenuButton;
module.exports = exports['default'];

},{"../button.js":6,"../lib.js":46,"../menu/menu-button.js":49,"../menu/menu.js":51,"./mute-toggle.js":11,"./volume-control/volume-bar.js":34}],39:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

/**
 * Core Object/Class for objects that use inheritance + constructors
 *
 * To create a class that can be subclassed itself, extend the CoreObject class.
 *
 *     var Animal = CoreObject.extend();
 *     var Horse = Animal.extend();
 *
 * The constructor can be defined through the init property of an object argument.
 *
 *     var Animal = CoreObject.extend({
 *       init: function(name, sound){
 *         this.name = name;
 *       }
 *     });
 *
 * Other methods and properties can be added the same way, or directly to the
 * prototype.
 *
 *    var Animal = CoreObject.extend({
 *       init: function(name){
 *         this.name = name;
 *       },
 *       getName: function(){
 *         return this.name;
 *       },
 *       sound: '...'
 *    });
 *
 *    Animal.prototype.makeSound = function(){
 *      alert(this.sound);
 *    };
 *
 * To create an instance of a class, use the create method.
 *
 *    var fluffy = Animal.create('Fluffy');
 *    fluffy.getName(); // -> Fluffy
 *
 * Methods and properties can be overridden in subclasses.
 *
 *     var Horse = Animal.extend({
 *       sound: 'Neighhhhh!'
 *     });
 *
 *     var horsey = Horse.create('Horsey');
 *     horsey.getName(); // -> Horsey
 *     horsey.makeSound(); // -> Alert: Neighhhhh!
 *
 * @class
 * @constructor
 */
var CoreObject = function CoreObject() {};
// Manually exporting vjs['CoreObject'] here for Closure Compiler
// because of the use of the extend/create class methods
// If we didn't do this, those functions would get flattened to something like
// `a = ...` and `this.prototype` would refer to the global object instead of
// CoreObject

/**
 * Create a new object that inherits from this Object
 *
 *     var Animal = CoreObject.extend();
 *     var Horse = Animal.extend();
 *
 * @param {Object} props Functions and properties to be applied to the
 *                       new object's prototype
 * @return {CoreObject} An object that inherits from CoreObject
 * @this {*}
 */
CoreObject.extend = function () {
  var props = arguments[0] === undefined ? {} : arguments[0];

  // Set up the constructor using the supplied init method
  // or using the init of the parent object
  // Make sure to check the unobfuscated version for external libs
  var init = props['init'] || props.init || this.prototype['init'] || this.prototype.init || function () {};
  // In Resig's simple class inheritance (previously used) the constructor
  //  is a function that calls `this.init.apply(arguments)`
  // However that would prevent us from using `ParentObject.call(this);`
  //  in a Child constructor because the `this` in `this.init`
  //  would still refer to the Child and cause an infinite loop.
  // We would instead have to do
  //    `ParentObject.prototype.init.apply(this, arguments);`
  //  Bleh. We're not creating a _super() function, so it's good to keep
  //  the parent constructor reference simple.
  var subObj = function subObj() {
    init.apply(this, arguments);
  };

  // Inherit from this object's prototype
  subObj.prototype = Lib.obj.create(this.prototype);
  // Reset the constructor property for subObj otherwise
  // instances of subObj would have the constructor of the parent Object
  subObj.prototype.constructor = subObj;

  // Make the class extendable
  subObj.extend = CoreObject.extend;
  // Make a function for creating instances
  subObj.create = CoreObject.create;

  // Extend subObj's prototype with functions and other properties from props
  for (var name in props) {
    if (props.hasOwnProperty(name)) {
      subObj.prototype[name] = props[name];
    }
  }

  return subObj;
};

/**
 * Create a new instance of this Object class
 *
 *     var myAnimal = Animal.create();
 *
 * @return {CoreObject} An instance of a CoreObject subclass
 * @this {*}
 */
CoreObject.create = function () {
  // Create a new object that inherits from this object's prototype
  var inst = Lib.obj.create(this.prototype);

  // Apply this constructor function to the new object
  this.apply(inst, arguments);

  // Return the new object
  return inst;
};

exports['default'] = CoreObject;
module.exports = exports['default'];

},{"./lib":46}],40:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * @fileoverview Main function src.
 */

var _player = _dereq_('./player');

var _player2 = _interopRequireDefault(_player);

var _plugins = _dereq_('./plugins');

var _plugins2 = _interopRequireDefault(_plugins);

var _options = _dereq_('./options');

var _options2 = _interopRequireDefault(_options);

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

var _util = _dereq_('./util');

var VjsUtil = _interopRequireWildcard(_util);

var _coreObject = _dereq_('./core-object');

var _coreObject2 = _interopRequireDefault(_coreObject);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 *
 * **ALIASES** videojs, _V_ (deprecated)
 *
 * The `vjs` function can be used to initialize or retrieve a player.
 *
 *     var myPlayer = vjs('my_video_id');
 *
 * @param  {String|Element} id      Video element or video element ID
 * @param  {Object=} options        Optional options object for config/settings
 * @param  {Function=} ready        Optional ready callback
 * @return {Player}             A player instance
 * @namespace
 */
var videojs = function videojs(id, options, ready) {
  var tag; // Element of ID

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (_player2['default'].players[id]) {

      // If options or ready funtion are passed, warn
      if (options) {
        Lib.log.warn('Player "' + id + '" is already initialised. Options will not be applied.');
      }

      if (ready) {
        _player2['default'].players[id].ready(ready);
      }

      return _player2['default'].players[id];

      // Otherwise get element for ID
    } else {
      tag = Lib.el(id);
    }

    // ID is a media element
  } else {
    tag = id;
  }

  // Check for a useable element
  if (!tag || !tag.nodeName) {
    // re: nodeName, could be a box div also
    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns
  }

  // Element may have a player attr referring to an already created player instance.
  // If not, set up a new player and return the instance.
  return tag['player'] || new _player2['default'](tag, options, ready);
};

// CDN Version. Used to target right flash swf.
videojs.CDN_VERSION = '5.0';
videojs.ACCESS_PROTOCOL = 'https:' === _globalDocument2['default'].location.protocol ? 'https://' : 'http://';

/**
* Full player version
* @type {string}
*/
videojs['VERSION'] = '5.0.0-11';

// Set CDN Version of swf
// The added (+) blocks the replace from changing this _VERSION_NO_PATCH_ string
if (videojs.CDN_VERSION !== '__VERSION_' + 'NO_PATCH__') {
  _options2['default']['flash']['swf'] = '' + videojs.ACCESS_PROTOCOL + 'vjs.zencdn.net/' + videojs.CDN_VERSION + '/video-js.swf';
}

/**
 * Utility function for adding languages to the default options. Useful for
 * amending multiple language support at runtime.
 *
 * Example: videojs.addLanguage('es', {'Hello':'Hola'});
 *
 * @param  {String} code The language code or dictionary property
 * @param  {Object} data The data values to be translated
 * @return {Object} The resulting global languages dictionary object
 */
videojs.addLanguage = function (code, data) {
  if (_options2['default']['languages'][code] !== undefined) {
    _options2['default']['languages'][code] = VjsUtil.mergeOptions(_options2['default']['languages'][code], data);
  } else {
    _options2['default']['languages'][code] = data;
  }
  return _options2['default']['languages'];
};

/**
 * Custom Universal Module Definition (UMD)
 *
 * Video.js will never be a non-browser lib so we can simplify UMD a bunch and
 * still support requirejs and browserify. This also needs to be closure
 * compiler compatible, so string keys are used.
 */
if (typeof define === 'function' && define['amd']) {
  define('videojs', [], function () {
    return videojs;
  });

  // checking that module is an object too because of umdjs/umd#35
} else if (typeof exports === 'object' && typeof module === 'object') {
  module['exports'] = videojs;
}

exports['default'] = videojs;
module.exports = exports['default'];

},{"./core-object":39,"./lib":46,"./options":52,"./player":53,"./plugins":54,"./util":70,"global/document":1}],41:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

/**
 * Display that an error has occurred making the video unplayable
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var ErrorDisplay = (function (_Component) {
  function ErrorDisplay(player, options) {
    _classCallCheck(this, ErrorDisplay);

    _get(Object.getPrototypeOf(ErrorDisplay.prototype), 'constructor', this).call(this, player, options);

    this.update();
    this.on(player, 'error', this.update);
  }

  _inherits(ErrorDisplay, _Component);

  _createClass(ErrorDisplay, [{
    key: 'createEl',
    value: function createEl() {
      var el = _get(Object.getPrototypeOf(ErrorDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-error-display'
      });

      this.contentEl_ = Lib.createEl('div');
      el.appendChild(this.contentEl_);

      return el;
    }
  }, {
    key: 'update',
    value: function update() {
      if (this.player().error()) {
        this.contentEl_.innerHTML = this.localize(this.player().error().message);
      }
    }
  }]);

  return ErrorDisplay;
})(_component2['default']);

_component2['default'].registerComponent('ErrorDisplay', ErrorDisplay);
exports['default'] = ErrorDisplay;
module.exports = exports['default'];

},{"./component":7,"./lib":46}],42:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _events = _dereq_('./events');

var Events = _interopRequireWildcard(_events);

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

var EventEmitter = function EventEmitter() {};

EventEmitter.prototype.allowedEvents_ = {};

EventEmitter.prototype.on = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;
  this.addEventListener = Function.prototype;
  Events.on(this, type, fn);
  this.addEventListener = ael;
};
EventEmitter.prototype.addEventListener = EventEmitter.prototype.on;

EventEmitter.prototype.off = function (type, fn) {
  Events.off(this, type, fn);
};
EventEmitter.prototype.removeEventListener = EventEmitter.prototype.off;

EventEmitter.prototype.one = function (type, fn) {
  Events.one(this, type, fn);
};

EventEmitter.prototype.trigger = function (event) {
  var type = event.type || event;

  if (typeof event === 'string') {
    event = {
      type: type
    };
  }
  event = Events.fixEvent(event);

  if (this.allowedEvents_[type] && this['on' + type]) {
    this['on' + type](event);
  }

  Events.trigger(this, event);
};
// The standard DOM EventTarget.dispatchEvent() is aliased to trigger()
EventEmitter.prototype.dispatchEvent = EventEmitter.prototype.trigger;

exports['default'] = EventEmitter;
module.exports = exports['default'];

},{"./events":43,"./lib":46}],43:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

/**
 * @fileoverview Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 */

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * Fix a native event to have standard property values
 * @param  {Object} event Event object to fix
 * @return {Object}
 * @private
 */
var fixEvent = function fixEvent(event) {

  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || _globalWindow2['default'].event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key === 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || _globalDocument2['default'];
    }

    // Handle which other element the event is related to
    event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      event.defaultPrevented = true;
    };

    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX != null) {
      var doc = _globalDocument2['default'].documentElement,
          body = _globalDocument2['default'].body;

      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button != null) {
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
    }
  }

  // Returns fixed-up instance
  return event;
};

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 * @param  {Element|Object}   elem Element or object to bind listeners to
 * @param  {String|Array}   type Type of event to bind to.
 * @param  {Function} fn   Event listener.
 * @private
 */
var on = function on(elem, type, fn) {
  if (Lib.obj.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn);
  }

  var data = Lib.getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) data.handlers = {};

  if (!data.handlers[type]) data.handlers[type] = [];

  if (!fn.guid) fn.guid = Lib.guid++;

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event) {

      if (data.disabled) return;
      event = fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            handlersCopy[m].call(elem, event);
          }
        }
      }
    };
  }

  if (data.handlers[type].length === 1) {
    if (elem.addEventListener) {
      elem.addEventListener(type, data.dispatcher, false);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
};

/**
 * Removes event listeners from an element
 * @param  {Element|Object}   elem Object to remove listeners from
 * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
 * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
 * @private
 */
var off = function off(elem, type, fn) {
  // Don't want to add a cache object through getData if not needed
  if (!Lib.hasData(elem)) return;

  var data = Lib.getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) {
    return;
  }

  if (Lib.obj.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn);
  }

  // Utility function
  var removeType = function removeType(t) {
    data.handlers[t] = [];
    cleanUpEvents(elem, t);
  };

  // Are we removing all bound events?
  if (!type) {
    for (var t in data.handlers) {
      removeType(t);
    }return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) return;

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  cleanUpEvents(elem, type);
};

/**
 * Clean up the listener cache and dispatchers
 * @param  {Element|Object} elem Element to clean up
 * @param  {String} type Type of event to clean up
 * @private
 */
var cleanUpEvents = function cleanUpEvents(elem, type) {
  var data = Lib.getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (Lib.isEmpty(data.handlers)) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;

    // data.handlers = null;
    // data.dispatcher = null;
    // data.disabled = null;
  }

  // Finally remove the expando if there is no data left
  if (Lib.isEmpty(data)) {
    Lib.removeData(elem);
  }
};

/**
 * Trigger an event for an element
 * @param  {Element|Object}      elem  Element to trigger an event on
 * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
 * @private
 */
var trigger = function trigger(elem, event) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasData first.
  var elemData = Lib.hasData(elem) ? Lib.getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  // type = event.type || event,
  // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type: event, target: elem };
  }
  // Normalizes the event properties.
  event = fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
  // recursively calls this function to bubble the event up the DOM.
  if (parent && !event.isPropagationStopped() && event.bubbles !== false) {
    trigger(parent, event);

    // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = Lib.getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
};

/**
 * Trigger a listener only once for an event
 * @param  {Element|Object}   elem Element or object to
 * @param  {String|Array}   type
 * @param  {Function} fn
 * @private
 */
var one = function one(elem, type, fn) {
  if (Lib.obj.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn);
  }
  var func = function func() {
    off(elem, type, func);
    fn.apply(this, arguments);
  };
  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || Lib.guid++;
  on(elem, type, func);
};

/**
 * Loops through an array of event types and calls the requested method for each type.
 * @param  {Function} fn   The event method we want to use.
 * @param  {Element|Object} elem Element or object to bind listeners to
 * @param  {String}   type Type of event to bind to.
 * @param  {Function} callback   Event listener.
 * @private
 */
function _handleMultipleEvents(fn, elem, type, callback) {
  Lib.arr.forEach(type, function (type) {
    fn(elem, type, callback); //Call the event method for each one of the types
  });
}

exports.on = on;
exports.off = off;
exports.cleanUpEvents = cleanUpEvents;
exports.fixEvent = fixEvent;
exports.one = one;
exports.trigger = trigger;

},{"./lib":46,"global/document":1,"global/window":2}],44:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

/**
 * A combination of node inherits and babel's inherits (after transpile).
 * Both work the same but node adds `super_` to the subClass
 * and Bable adds the superClass as __proto__. Both seem useful.
 */
var _inherits = function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    // node
    subClass.super_ = superClass;
  }
};

/**
 * Function for subclassing using the same inheritance that
 * videojs uses internally
 *
 * ```
 * var Button = videojs.getComponent('Button');
 *
 * var MyButton = videojs.extends(Button, {
 *   constructor: function(player, options) {
 *     Button.call(this, player, options);
 *   },
 *
 *   onClick: function() {
 *     // doSomething
 *   }
 * });
 * ```
 */
var extendsFn = function extendsFn(superClass) {
  var subClassMethods = arguments[1] === undefined ? {} : arguments[1];

  var subClass = function subClass() {
    superClass.apply(this, arguments);
  };
  var methods = {};

  if (subClassMethods.constructor !== Object.prototype.constructor) {
    subClass = subClassMethods.constructor;
    methods = subClassMethods;
  } else if (typeof subClassMethods === 'function') {
    subClass = subClassMethods;
  }

  _inherits(subClass, superClass);

  // Extend subObj's prototype with functions and other properties from props
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }

  return subClass;
};

exports['default'] = extendsFn;
module.exports = exports['default'];

},{"./lib":46}],45:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * Store the browser-specific methods for the fullscreen API
 * @type {Object|undefined}
 * @private
 */
var FullscreenApi = {};

// browser API methods
// map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js
var apiMap = [
// Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],
// WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Old WebKit (Safari 5.1)
['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],
// Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];

var specApi = apiMap[0];
var browserApi = undefined;

// determine the supported set of functions
for (var i = 0; i < apiMap.length; i++) {
  // check for exitFullscreen function
  if (apiMap[i][1] in _globalDocument2['default']) {
    browserApi = apiMap[i];
    break;
  }
}

// map the browser API names to the spec API names
if (browserApi) {
  for (var i = 0; i < browserApi.length; i++) {
    FullscreenApi[specApi[i]] = browserApi[i];
  }
}

exports['default'] = FullscreenApi;
module.exports = exports['default'];

},{"global/document":1}],46:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var navigator = _globalWindow2['default'].navigator;

var hasOwnProp = Object.prototype.hasOwnProperty;

/**
 * Creates an element and applies properties.
 * @param  {String=} tagName    Name of tag to be created.
 * @param  {Object=} properties Element properties to be applied.
 * @return {Element}
 * @private
 */
var createEl = function createEl() {
  var tagName = arguments[0] === undefined ? 'div' : arguments[0];
  var properties = arguments[1] === undefined ? {} : arguments[1];

  var el = _globalDocument2['default'].createElement(tagName);

  obj.each(properties, function (propName, val) {
    // Not remembering why we were checking for dash
    // but using setAttribute means you have to use getAttribute

    // The check for dash checks for the aria-* attributes, like aria-label, aria-valuemin.
    // The additional check for "role" is because the default method for adding attributes does not
    // add the attribute "role". My guess is because it's not a valid attribute in some namespaces, although
    // browsers handle the attribute just fine. The W3C allows for aria-* attributes to be used in pre-HTML5 docs.
    // http://www.w3.org/TR/wai-aria-primer/#ariahtml. Using setAttribute gets around this problem.
    if (propName.indexOf('aria-') !== -1 || propName === 'role') {
      el.setAttribute(propName, val);
    } else {
      el[propName] = val;
    }
  });

  return el;
};

/**
 * Uppercase the first letter of a string
 * @param  {String} string String to be uppercased
 * @return {String}
 * @private
 */
var capitalize = function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
};

/**
 * Object functions container
 * @type {Object}
 * @private
 */
var obj = {};

/**
 * Object.create shim for prototypal inheritance
 *
 * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
 *
 * @function
 * @param  {Object}   obj Object to use as prototype
 * @private
 */
obj.create = Object.create || function (obj) {
  //Create a new function called 'F' which is just an empty object.
  function F() {}

  //the prototype of the 'F' function should point to the
  //parameter of the anonymous function.
  F.prototype = obj;

  //create a new constructor function based off of the 'F' function.
  return new F();
};

/**
 * Loop through each property in an object and call a function
 * whose arguments are (key,value)
 * @param  {Object}   obj Object of properties
 * @param  {Function} fn  Function to be called on each property.
 * @this {*}
 * @private
 */
obj.each = function (obj, fn, context) {
  for (var key in obj) {
    if (hasOwnProp.call(obj, key)) {
      fn.call(context || this, key, obj[key]);
    }
  }
};

/**
 * Merge two objects together and return the original.
 * @param  {Object} obj1
 * @param  {Object} obj2
 * @return {Object}
 * @private
 */
obj.merge = function (obj1, obj2) {
  if (!obj2) {
    return obj1;
  }
  for (var key in obj2) {
    if (hasOwnProp.call(obj2, key)) {
      obj1[key] = obj2[key];
    }
  }
  return obj1;
};

/**
 * Merge two objects, and merge any properties that are objects
 * instead of just overwriting one. Uses to merge options hashes
 * where deeper default settings are important.
 * @param  {Object} obj1 Object to override
 * @param  {Object} obj2 Overriding object
 * @return {Object}      New object. Obj1 and Obj2 will be untouched.
 * @private
 */
obj.deepMerge = function (obj1, obj2) {
  var key, val1, val2;

  // make a copy of obj1 so we're not overwriting original values.
  // like prototype.options_ and all sub options objects
  obj1 = obj.copy(obj1);

  for (key in obj2) {
    if (hasOwnProp.call(obj2, key)) {
      val1 = obj1[key];
      val2 = obj2[key];

      // Check if both properties are pure objects and do a deep merge if so
      if (obj.isPlain(val1) && obj.isPlain(val2)) {
        obj1[key] = obj.deepMerge(val1, val2);
      } else {
        obj1[key] = obj2[key];
      }
    }
  }
  return obj1;
};

/**
 * Make a copy of the supplied object
 * @param  {Object} obj Object to copy
 * @return {Object}     Copy of object
 * @private
 */
obj.copy = function (objToCopy) {
  return obj.merge({}, objToCopy);
};

/**
 * Check if an object is plain, and not a dom node or any object sub-instance
 * @param  {Object} obj Object to check
 * @return {Boolean}     True if plain, false otherwise
 * @private
 */
obj.isPlain = function (obj) {
  return !!obj && typeof obj === 'object' && obj.toString() === '[object Object]' && obj.constructor === Object;
};

/**
 * Check if an object is Array
*  Since instanceof Array will not work on arrays created in another frame we need to use Array.isArray, but since IE8 does not support Array.isArray we need this shim
 * @param  {Object} obj Object to check
 * @return {Boolean}     True if plain, false otherwise
 * @private
 */
obj.isArray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
};

/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
   It also stores a unique id on the function so it can be easily removed from events
 * @param  {*}   context The object to bind as scope
 * @param  {Function} fn      The function to be bound to a scope
 * @param  {Number=}   uid     An optional unique ID for the function to be set
 * @return {Function}
 * @private
 */
var bind = function bind(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) {
    fn.guid = (exports.guid = guid += 1, guid - 1);
  }

  // Create the new function that changes the context
  var ret = function ret() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  ret.guid = uid ? uid + '_' + fn.guid : fn.guid;

  return ret;
};

/**
 * Element Data Store. Allows for binding data to an element without putting it directly on the element.
 * Ex. Event listeners are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 * @type {Object}
 * @private
 */
var cache = {};

/**
 * Unique ID for an element or function
 * @type {Number}
 * @private
 */
var guid = 1;

/**
 * Unique attribute name to store an element's guid in
 * @type {String}
 * @constant
 * @private
 */
var expando = 'vdata' + new Date().getTime();

/**
 * Returns the cache object where data for an element is stored
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @private
 */
var getData = function getData(el) {
  var id = el[expando];
  if (!id) {
    id = el[expando] = (exports.guid = guid += 1, guid - 1);
  }
  if (!cache[id]) {
    cache[id] = {};
  }
  return cache[id];
};

/**
 * Returns the cache object where data for an element is stored
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @private
 */
var hasData = function hasData(el) {
  var id = el[expando];
  return !(!id || isEmpty(cache[id]));
};

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 * @param  {Element} el Remove data for an element
 * @private
 */
var removeData = function removeData(el) {
  var id = el[expando];
  if (!id) {
    return;
  }
  // Remove all stored data
  // Changed to = null
  // http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
  // cache[id] = null;
  delete cache[id];

  // Remove the expando property from the DOM node
  try {
    delete el[expando];
  } catch (e) {
    if (el.removeAttribute) {
      el.removeAttribute(expando);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[expando] = null;
    }
  }
};

/**
 * Check if an object is empty
 * @param  {Object}  obj The object to check for emptiness
 * @return {Boolean}
 * @private
 */
var isEmpty = function isEmpty(obj) {
  for (var prop in obj) {
    // Inlude null properties as empty.
    if (obj[prop] !== null) {
      return false;
    }
  }
  return true;
};

/**
 * Check if an element has a CSS class
 * @param {Element} element Element to check
 * @param {String} classToCheck Classname to check
 * @private
 */
var hasClass = function hasClass(element, classToCheck) {
  return (' ' + element.className + ' ').indexOf(' ' + classToCheck + ' ') !== -1;
};

/**
 * Add a CSS class name to an element
 * @param {Element} element    Element to add class name to
 * @param {String} classToAdd Classname to add
 * @private
 */
var addClass = function addClass(element, classToAdd) {
  if (!hasClass(element, classToAdd)) {
    element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;
  }
};

/**
 * Remove a CSS class name from an element
 * @param {Element} element    Element to remove from class name
 * @param {String} classToAdd Classname to remove
 * @private
 */
var removeClass = function removeClass(element, classToRemove) {
  if (!hasClass(element, classToRemove)) {
    return;
  }

  var classNames = element.className.split(' ');

  // no arr.indexOf in ie8, and we don't want to add a big shim
  for (var i = classNames.length - 1; i >= 0; i--) {
    if (classNames[i] === classToRemove) {
      classNames.splice(i, 1);
    }
  }

  element.className = classNames.join(' ');
};

/**
 * Element for testing browser HTML5 video capabilities
 * @type {Element}
 * @constant
 * @private
 */
var TEST_VID = createEl('video');
var track = _globalDocument2['default'].createElement('track');
track.kind = 'captions';
track.srclang = 'en';
track.label = 'English';
TEST_VID.appendChild(track);

/**
 * Useragent for browser testing.
 * @type {String}
 * @constant
 * @private
 */
var USER_AGENT = navigator.userAgent;

/**
 * Device is an iPhone
 * @type {Boolean}
 * @constant
 * @private
 */
var IS_IPHONE = /iPhone/i.test(USER_AGENT);
var IS_IPAD = /iPad/i.test(USER_AGENT);
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

var IOS_VERSION = (function () {
  var match = USER_AGENT.match(/OS (\d+)_/i);
  if (match && match[1]) {
    return match[1];
  }
})();

var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = (function () {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
      major,
      minor;

  if (!match) {
    return null;
  }

  major = match[1] && parseFloat(match[1]);
  minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  } else {
    return null;
  }
})();
// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;

var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_CHROME = /Chrome/i.test(USER_AGENT);
var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);

var TOUCH_ENABLED = !!('ontouchstart' in _globalWindow2['default'] || _globalWindow2['default'].DocumentTouch && _globalDocument2['default'] instanceof _globalWindow2['default'].DocumentTouch);
var BACKGROUND_SIZE_SUPPORTED = ('backgroundSize' in TEST_VID.style);

/**
 * Apply attributes to an HTML element.
 * @param  {Element} el         Target element.
 * @param  {Object=} attributes Element attributes to be applied.
 * @private
 */
var setElementAttributes = function setElementAttributes(el, attributes) {
  obj.each(attributes, function (attrName, attrValue) {
    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? '' : attrValue);
    }
  });
};

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 * @param  {Element} tag Element from which to get tag attributes
 * @return {Object}
 * @private
 */
var getElementAttributes = function getElementAttributes(tag) {
  var obj, knownBooleans, attrs, attrName, attrVal;

  obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  knownBooleans = ',' + 'autoplay,controls,loop,muted,default' + ',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      attrName = attrs[i].name;
      attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = attrVal !== null ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
};

/**
 * Get the computed style value for an element
 * From http://robertnyman.com/2006/04/24/get-the-rendered-style-of-an-element/
 * @param  {Element} el        Element to get style value for
 * @param  {String} strCssRule Style name
 * @return {String}            Style value
 * @private
 */
var getComputedDimension = function getComputedDimension(el, strCssRule) {
  var strValue = '';
  if (_globalDocument2['default'].defaultView && _globalDocument2['default'].defaultView.getComputedStyle) {
    strValue = _globalDocument2['default'].defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);
  } else if (el.currentStyle) {
    // IE8 Width/Height support
    var upperCasedRule = strCssRule.substr(0, 1).toUpperCase() + strCssRule.substr(1);
    strValue = el['client' + upperCasedRule] + 'px';
  }
  return strValue;
};

/**
 * Insert an element as the first child node of another
 * @param  {Element} child   Element to insert
 * @param  {[type]} parent Element to insert child into
 * @private
 */
var insertFirst = function insertFirst(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
};

/**
 * Object to hold browser support information
 * @type {Object}
 * @private
 */
var browser = {};

/**
 * Shorthand for document.getElementById()
 * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.
 * @param  {String} id  Element ID
 * @return {Element}    Element with supplied ID
 * @private
 */
var el = function el(id) {
  if (id.indexOf('#') === 0) {
    id = id.slice(1);
  }

  return _globalDocument2['default'].getElementById(id);
};

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 * @param  {Number} seconds Number of seconds to be turned into a string
 * @param  {Number} guide   Number (in seconds) to model the string after
 * @return {String}         Time formatted as H:MM:SS or M:SS
 * @private
 */
var formatTime = function formatTime(seconds) {
  var guide = arguments[1] === undefined ? seconds : arguments[1];
  return (function () {
    var s = Math.floor(seconds % 60);
    var m = Math.floor(seconds / 60 % 60);
    var h = Math.floor(seconds / 3600);
    var gm = Math.floor(guide / 60 % 60);
    var gh = Math.floor(guide / 3600);

    // handle invalid times
    if (isNaN(seconds) || seconds === Infinity) {
      // '-' is false for all relational operators (e.g. <, >=) so this setting
      // will add the minimum number of fields specified by the guide
      h = m = s = '-';
    }

    // Check if we need to show hours
    h = h > 0 || gh > 0 ? h + ':' : '';

    // If hours are showing, we may need to add a leading zero.
    // Always show at least one digit of minutes.
    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

    // Check if leading zero is need for seconds
    s = s < 10 ? '0' + s : s;

    return h + m + s;
  })();
};

// Attempt to block the ability to select text while dragging controls
var blockTextSelection = function blockTextSelection() {
  _globalDocument2['default'].body.focus();
  _globalDocument2['default'].onselectstart = function () {
    return false;
  };
};
// Turn off text selection blocking
var unblockTextSelection = function unblockTextSelection() {
  _globalDocument2['default'].onselectstart = function () {
    return true;
  };
};

/**
 * Trim whitespace from the ends of a string.
 * @param  {String} string String to trim
 * @return {String}        Trimmed string
 * @private
 */
var trim = function trim(str) {
  return (str + '').replace(/^\s+|\s+$/g, '');
};

/**
 * Should round off a number to a decimal place
 * @param  {Number} num Number to round
 * @param  {Number} dec Number of decimal places to round to
 * @return {Number}     Rounded number
 * @private
 */
var round = function round(num) {
  var dec = arguments[1] === undefined ? 0 : arguments[1];

  return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
};

/**
 * Should create a fake TimeRange object
 * Mimics an HTML5 time range instance, which has functions that
 * return the start and end times for a range
 * TimeRanges are returned by the buffered() method
 * @param  {Number} start Start time in seconds
 * @param  {Number} end   End time in seconds
 * @return {Object}       Fake TimeRange object
 * @private
 */
var createTimeRange = function createTimeRange(_start, _end) {
  return {
    length: 1,
    start: function start() {
      return _start;
    },
    end: function end() {
      return _end;
    }
  };
};

/**
 * Add to local storage (maybe removable)
 * @private
 */
var setLocalStorage = function setLocalStorage(key, value) {
  try {
    // IE was throwing errors referencing the var anywhere without this
    var _localStorage = _globalWindow2['default'].localStorage || false;
    if (!_localStorage) {
      return;
    }
    _localStorage[key] = value;
  } catch (e) {
    if (e.code === 22 || e.code === 1014) {
      // Webkit == 22 / Firefox == 1014
      log('LocalStorage Full (VideoJS)', e);
    } else {
      if (e.code === 18) {
        log('LocalStorage not allowed (VideoJS)', e);
      } else {
        log('LocalStorage Error (VideoJS)', e);
      }
    }
  }
};

/**
 * Get absolute version of relative URL. Used to tell flash correct URL.
 * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 * @param  {String} url URL to make absolute
 * @return {String}     Absolute URL
 * @private
 */
var getAbsoluteURL = function getAbsoluteURL(url) {
  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    url = createEl('div', {
      innerHTML: '<a href="' + url + '">x</a>'
    }).firstChild.href;
  }

  return url;
};

/**
 * Resolve and parse the elements of a URL
 * @param  {String} url The url to parse
 * @return {Object}     An object of url details
 */
var parseUrl = function parseUrl(url) {
  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  var a = createEl('a', { href: url });

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  var addToBody = a.host === '' && a.protocol !== 'file:';
  var div = undefined;
  if (addToBody) {
    div = createEl('div');
    div.innerHTML = '<a href="' + url + '"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    _globalDocument2['default'].body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  var details = {};
  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  // IE9 adds the port to the host property unlike everyone else. If
  // a port identifier is added for standard ports, strip it.
  if (details.protocol === 'http:') {
    details.host = details.host.replace(/:80$/, '');
  }
  if (details.protocol === 'https:') {
    details.host = details.host.replace(/:443$/, '');
  }

  if (addToBody) {
    _globalDocument2['default'].body.removeChild(div);
  }

  return details;
};

/**
 * Log messages to the console and history based on the type of message
 *
 * @param  {String} type The type of message, or `null` for `log`
 * @param  {[type]} args The args to be passed to the log
 * @private
 */
function _logType(type, args) {
  // convert args to an array to get array functions
  var argsArray = Array.prototype.slice.call(args);
  // if there's no console then don't try to output messages
  // they will still be stored in Lib.log.history
  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  var noop = function noop() {};

  var console = _globalWindow2['default']['console'] || {
    'log': noop,
    'warn': noop,
    'error': noop
  };

  if (type) {
    // add the type to the front of the message
    argsArray.unshift(type.toUpperCase() + ':');
  } else {
    // default to log with no prefix
    type = 'log';
  }

  // add to history
  log.history.push(argsArray);

  // add console prefix after adding to history
  argsArray.unshift('VIDEOJS:');

  // call appropriate log function
  if (console[type].apply) {
    console[type].apply(console, argsArray);
  } else {
    // ie8 doesn't allow error.apply, but it will just join() the array anyway
    console[type](argsArray.join(' '));
  }
}

/**
 * Log plain debug messages
 */
var log = function log() {
  _logType(null, arguments);
};

/**
 * Keep a history of log messages
 * @type {Array}
 */
log.history = [];

/**
 * Log error messages
 */
log.error = function () {
  _logType('error', arguments);
};

/**
 * Log warning messages
 */
log.warn = function () {
  _logType('warn', arguments);
};

// Offset Left
// getBoundingClientRect technique from John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/
var findPosition = function findPosition(el) {
  var box = undefined;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  var docEl = _globalDocument2['default'].documentElement;
  var body = _globalDocument2['default'].body;

  var clientLeft = docEl.clientLeft || body.clientLeft || 0;
  var scrollLeft = _globalWindow2['default'].pageXOffset || body.scrollLeft;
  var left = box.left + scrollLeft - clientLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var scrollTop = _globalWindow2['default'].pageYOffset || body.scrollTop;
  var top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: round(left),
    top: round(top)
  };
};

/**
 * Array functions container
 * @type {Object}
 * @private
 */
var arr = {};

/*
 * Loops through an array and runs a function for each item inside it.
 * @param  {Array}    array       The array
 * @param  {Function} callback    The function to be run for each item
 * @param  {*}        thisArg     The `this` binding of callback
 * @returns {Array}               The array
 * @private
 */
arr.forEach = function (array, callback, thisArg) {
  thisArg = thisArg || this;

  if (obj.isArray(array) && callback instanceof Function) {
    for (var i = 0, len = array.length; i < len; ++i) {
      callback.call(thisArg, array[i], i, array);
    }
  }

  return array;
};

/**
 * Returns the extension of the passed file name. It will return an empty string if you pass an invalid path
 *
 * @param {String}    path    The fileName path like '/path/to/file.mp4'
 * @returns {String}          The extension in lower case or an empty string if no extension could be found.
 */
var getFileExtension = function getFileExtension(path) {
  if (typeof path === 'string') {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
    var pathParts = splitPathRe.exec(path);

    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }

  return '';
};

exports.createEl = createEl;
exports.capitalize = capitalize;
exports.obj = obj;
exports.isNaN = isNaN;
exports.bind = bind;
exports.cache = cache;
exports.guid = guid;
exports.expando = expando;
exports.getData = getData;
exports.hasData = hasData;
exports.removeData = removeData;
exports.isEmpty = isEmpty;
exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.TEST_VID = TEST_VID;
exports.USER_AGENT = USER_AGENT;
exports.IS_IPHONE = IS_IPHONE;
exports.IS_IPAD = IS_IPAD;
exports.IS_IPOD = IS_IPOD;
exports.IS_IOS = IS_IOS;
exports.IOS_VERSION = IOS_VERSION;
exports.IS_ANDROID = IS_ANDROID;
exports.ANDROID_VERSION = ANDROID_VERSION;
exports.IS_OLD_ANDROID = IS_OLD_ANDROID;
exports.IS_FIREFOX = IS_FIREFOX;
exports.IS_IE8 = IS_IE8;
exports.IS_CHROME = IS_CHROME;
exports.TOUCH_ENABLED = TOUCH_ENABLED;
exports.BACKGROUND_SIZE_SUPPORTED = BACKGROUND_SIZE_SUPPORTED;
exports.setElementAttributes = setElementAttributes;
exports.getElementAttributes = getElementAttributes;
exports.getComputedDimension = getComputedDimension;
exports.insertFirst = insertFirst;
exports.browser = browser;
exports.el = el;
exports.formatTime = formatTime;
exports.blockTextSelection = blockTextSelection;
exports.unblockTextSelection = unblockTextSelection;
exports.trim = trim;
exports.round = round;
exports.createTimeRange = createTimeRange;
exports.setLocalStorage = setLocalStorage;
exports.getAbsoluteURL = getAbsoluteURL;
exports.parseUrl = parseUrl;
exports.log = log;
exports.findPosition = findPosition;
exports.arr = arr;
exports.getFileExtension = getFileExtension;

},{"global/document":1,"global/window":2}],47:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

/* Loading Spinner
================================================================================ */
/**
 * Loading spinner for waiting events
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var LoadingSpinner = (function (_Component) {
  function LoadingSpinner() {
    _classCallCheck(this, LoadingSpinner);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(LoadingSpinner, _Component);

  _createClass(LoadingSpinner, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(LoadingSpinner.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-loading-spinner'
      });
    }
  }]);

  return LoadingSpinner;
})(_component2['default']);

_component2['default'].registerComponent('LoadingSpinner', LoadingSpinner);
exports['default'] = LoadingSpinner;
module.exports = exports['default'];

},{"./component":7}],48:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

/**
 * Custom MediaError to mimic the HTML5 MediaError
 * @param {Number} code The media error code
 */
var MediaError = function MediaError(code) {
  if (typeof code === 'number') {
    this.code = code;
  } else if (typeof code === 'string') {
    // default code is zero, so this is a custom error
    this.message = code;
  } else if (typeof code === 'object') {
    // object
    Lib.obj.merge(this, code);
  }

  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || '';
  }
};

/**
 * The error code that refers two one of the defined
 * MediaError types
 * @type {Number}
 */
MediaError.prototype.code = 0;

/**
 * An optional message to be shown with the error.
 * Message is not part of the HTML5 video spec
 * but allows for more informative custom errors.
 * @type {String}
 */
MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins
 * to allow even more detail about the error.
 * For example the HLS plugin might provide the specific
 * HTTP status code that was returned when the error
 * occurred, then allowing a custom error overlay
 * to display more information.
 * @type {[type]}
 */
MediaError.prototype.status = null;

MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', // = 0
'MEDIA_ERR_ABORTED', // = 1
'MEDIA_ERR_NETWORK', // = 2
'MEDIA_ERR_DECODE', // = 3
'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4
'MEDIA_ERR_ENCRYPTED' // = 5
];

MediaError.defaultMessages = {
  1: 'You aborted the video playback',
  2: 'A network error caused the video download to fail part-way.',
  3: 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',
  4: 'The video could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The video is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}

exports['default'] = MediaError;
module.exports = exports['default'];

},{"./lib":46}],49:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _buttonJs = _dereq_('../button.js');

var _buttonJs2 = _interopRequireDefault(_buttonJs);

var _menuJs = _dereq_('./menu.js');

var _menuJs2 = _interopRequireDefault(_menuJs);

var _libJs = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * A button class with a popup menu
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var MenuButton = (function (_Button) {
  function MenuButton(player, options) {
    _classCallCheck(this, MenuButton);

    _get(Object.getPrototypeOf(MenuButton.prototype), 'constructor', this).call(this, player, options);

    this.update();

    this.on('keydown', this.handleKeyPress);
    this.el_.setAttribute('aria-haspopup', true);
    this.el_.setAttribute('role', 'button');
  }

  _inherits(MenuButton, _Button);

  _createClass(MenuButton, [{
    key: 'update',
    value: function update() {
      var menu = this.createMenu();

      if (this.menu) {
        this.removeChild(this.menu);
      }

      this.menu = menu;
      this.addChild(menu);

      /**
       * Track the state of the menu button
       * @type {Boolean}
       * @private
       */
      this.buttonPressed_ = false;

      if (this.items && this.items.length === 0) {
        this.hide();
      } else if (this.items && this.items.length > 1) {
        this.show();
      }
    }
  }, {
    key: 'createMenu',
    value: function createMenu() {
      var menu = new _menuJs2['default'](this.player_);

      // Add a title list item to the top
      if (this.options().title) {
        menu.contentEl().appendChild(Lib.createEl('li', {
          className: 'vjs-menu-title',
          innerHTML: Lib.capitalize(this.options().title),
          tabindex: -1
        }));
      }

      this.items = this['createItems']();

      if (this.items) {
        // Add menu items to the menu
        for (var i = 0; i < this.items.length; i++) {
          menu.addItem(this.items[i]);
        }
      }

      return menu;
    }
  }, {
    key: 'createItems',

    /**
     * Create the list of menu items. Specific to each subclass.
     */
    value: function createItems() {}
  }, {
    key: 'buildCSSClass',

    /** @inheritDoc */
    value: function buildCSSClass() {
      return '' + this.className + ' vjs-menu-button ' + _get(Object.getPrototypeOf(MenuButton.prototype), 'buildCSSClass', this).call(this);
    }
  }, {
    key: 'handleFocus',

    // Focus - Add keyboard functionality to element
    // This function is not needed anymore. Instead, the keyboard functionality is handled by
    // treating the button as triggering a submenu. When the button is pressed, the submenu
    // appears. Pressing the button again makes the submenu disappear.
    value: function handleFocus() {}
  }, {
    key: 'handleBlur',

    // Can't turn off list display that we turned on with focus, because list would go away.
    value: function handleBlur() {}
  }, {
    key: 'handleClick',
    value: function handleClick() {
      // When you click the button it adds focus, which will show the menu indefinitely.
      // So we'll remove focus when the mouse leaves the button.
      // Focus is needed for tab navigation.
      this.one('mouseout', Lib.bind(this, function () {
        this.menu.unlockShowing();
        this.el_.blur();
      }));
      if (this.buttonPressed_) {
        this.unpressButton();
      } else {
        this.pressButton();
      }
    }
  }, {
    key: 'handleKeyPress',
    value: function handleKeyPress(event) {

      // Check for space bar (32) or enter (13) keys
      if (event.which === 32 || event.which === 13) {
        if (this.buttonPressed_) {
          this.unpressButton();
        } else {
          this.pressButton();
        }
        event.preventDefault();
        // Check for escape (27) key
      } else if (event.which === 27) {
        if (this.buttonPressed_) {
          this.unpressButton();
        }
        event.preventDefault();
      }
    }
  }, {
    key: 'pressButton',
    value: function pressButton() {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.el_.setAttribute('aria-pressed', true);
      if (this.items && this.items.length > 0) {
        this.items[0].el().focus(); // set the focus to the title of the submenu
      }
    }
  }, {
    key: 'unpressButton',
    value: function unpressButton() {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.el_.setAttribute('aria-pressed', false);
    }
  }]);

  return MenuButton;
})(_buttonJs2['default']);

_buttonJs2['default'].registerComponent('MenuButton', MenuButton);
exports['default'] = MenuButton;
module.exports = exports['default'];

},{"../button.js":6,"../lib.js":46,"./menu.js":51}],50:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _buttonJs = _dereq_('../button.js');

var _buttonJs2 = _interopRequireDefault(_buttonJs);

var _libJs = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * The component for a menu item. `<li>`
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var MenuItem = (function (_Button) {
  function MenuItem(player, options) {
    _classCallCheck(this, MenuItem);

    _get(Object.getPrototypeOf(MenuItem.prototype), 'constructor', this).call(this, player, options);
    this.selected(options['selected']);
  }

  _inherits(MenuItem, _Button);

  _createClass(MenuItem, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl(type, props) {
      return _get(Object.getPrototypeOf(MenuItem.prototype), 'createEl', this).call(this, 'li', Lib.obj.merge({
        className: 'vjs-menu-item',
        innerHTML: this.localize(this.options_['label'])
      }, props));
    }
  }, {
    key: 'handleClick',

    /**
     * Handle a click on the menu item, and set it to selected
     */
    value: function handleClick() {
      this.selected(true);
    }
  }, {
    key: 'selected',

    /**
     * Set this menu item as selected or not
     * @param  {Boolean} selected
     */
    value: function selected(_selected) {
      if (_selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-selected', true);
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-selected', false);
      }
    }
  }]);

  return MenuItem;
})(_buttonJs2['default']);

_buttonJs2['default'].registerComponent('MenuItem', MenuItem);
exports['default'] = MenuItem;
module.exports = exports['default'];

},{"../button.js":6,"../lib.js":46}],51:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _libJs = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_libJs);

var _eventsJs = _dereq_('../events.js');

var Events = _interopRequireWildcard(_eventsJs);

/* Menu
================================================================================ */
/**
 * The Menu component is used to build pop up menus, including subtitle and
 * captions selection menus.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @class
 * @constructor
 */

var Menu = (function (_Component) {
  function Menu() {
    _classCallCheck(this, Menu);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(Menu, _Component);

  _createClass(Menu, [{
    key: 'addItem',

    /**
     * Add a menu item to the menu
     * @param {Object|String} component Component or component type to add
     */
    value: function addItem(component) {
      this.addChild(component);
      component.on('click', Lib.bind(this, function () {
        this.unlockShowing();
      }));
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      var contentElType = this.options().contentElType || 'ul';
      this.contentEl_ = Lib.createEl(contentElType, {
        className: 'vjs-menu-content'
      });
      var el = _get(Object.getPrototypeOf(Menu.prototype), 'createEl', this).call(this, 'div', {
        append: this.contentEl_,
        className: 'vjs-menu'
      });
      el.appendChild(this.contentEl_);

      // Prevent clicks from bubbling up. Needed for Menu Buttons,
      // where a click on the parent is significant
      Events.on(el, 'click', function (event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      });

      return el;
    }
  }]);

  return Menu;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('Menu', Menu);
exports['default'] = Menu;
module.exports = exports['default'];

},{"../component.js":7,"../events.js":43,"../lib.js":46}],52:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var navigator = _globalWindow2['default'].navigator;

/**
 * Global Player instance options, surfaced from Player.prototype.options_
 * options = Player.prototype.options_
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 */
exports['default'] = {
  // Default order of fallback technology
  'techOrder': ['html5', 'flash'],
  // techOrder: ['flash','html5'],

  'html5': {},
  'flash': {},

  // Default of web browser is 300x150. Should rely on source width/height.
  'width': 300,
  'height': 150,
  // defaultVolume: 0.85,
  'defaultVolume': 0, // The freakin seaguls are driving me crazy!

  // default inactivity timeout
  'inactivityTimeout': 2000,

  // default playback rates
  'playbackRates': [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // Included control sets
  'children': {
    'mediaLoader': {},
    'posterImage': {},
    'textTrackDisplay': {},
    'loadingSpinner': {},
    'bigPlayButton': {},
    'controlBar': {},
    'errorDisplay': {},
    'textTrackSettings': {}
  },

  'language': _globalDocument2['default'].getElementsByTagName('html')[0].getAttribute('lang') || navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',

  // locales and their language translations
  'languages': {},

  // Default message to show when a video cannot be played.
  'notSupportedMessage': 'No compatible source was found for this video.'
};
module.exports = exports['default'];

},{"global/document":1,"global/window":2}],53:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x2,
    property = _x3,
    receiver = _x4; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('./component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _libJs = _dereq_('./lib.js');

var Lib = _interopRequireWildcard(_libJs);

var _eventsJs = _dereq_('./events.js');

var Events = _interopRequireWildcard(_eventsJs);

var _fullscreenApiJs = _dereq_('./fullscreen-api.js');

var _fullscreenApiJs2 = _interopRequireDefault(_fullscreenApiJs);

var _mediaErrorJs = _dereq_('./media-error.js');

var _mediaErrorJs2 = _interopRequireDefault(_mediaErrorJs);

var _optionsJs = _dereq_('./options.js');

var _optionsJs2 = _interopRequireDefault(_optionsJs);

var _safeJsonParseTuple = _dereq_('safe-json-parse/tuple');

var _safeJsonParseTuple2 = _interopRequireDefault(_safeJsonParseTuple);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

// Include required child components

var _techLoaderJs = _dereq_('./tech/loader.js');

var _techLoaderJs2 = _interopRequireDefault(_techLoaderJs);

var _posterImageJs = _dereq_('./poster-image.js');

var _posterImageJs2 = _interopRequireDefault(_posterImageJs);

var _tracksTextTrackDisplayJs = _dereq_('./tracks/text-track-display.js');

var _tracksTextTrackDisplayJs2 = _interopRequireDefault(_tracksTextTrackDisplayJs);

var _loadingSpinnerJs = _dereq_('./loading-spinner.js');

var _loadingSpinnerJs2 = _interopRequireDefault(_loadingSpinnerJs);

var _bigPlayButtonJs = _dereq_('./big-play-button.js');

var _bigPlayButtonJs2 = _interopRequireDefault(_bigPlayButtonJs);

var _controlBarControlBarJs = _dereq_('./control-bar/control-bar.js');

var _controlBarControlBarJs2 = _interopRequireDefault(_controlBarControlBarJs);

var _errorDisplayJs = _dereq_('./error-display.js');

var _errorDisplayJs2 = _interopRequireDefault(_errorDisplayJs);

var _tracksTextTrackSettingsJs = _dereq_('./tracks/text-track-settings.js');

var _tracksTextTrackSettingsJs2 = _interopRequireDefault(_tracksTextTrackSettingsJs);

// Require html5 for disposing the original video tag

var _techHtml5Js = _dereq_('./tech/html5.js');

var _techHtml5Js2 = _interopRequireDefault(_techHtml5Js);

/**
 * An instance of the `Player` class is created when any of the Video.js setup methods are used to initialize a video.
 *
 * ```js
 * var myPlayer = videojs('example_video_1');
 * ```
 *
 * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.
 *
 * ```html
 * <video id="example_video_1" data-setup='{}' controls>
 *   <source src="my-source.mp4" type="video/mp4">
 * </video>
 * ```
 *
 * After an instance has been created it can be accessed globally using `Video('example_video_1')`.
 *
 * @class
 * @extends Component
 */

var Player = (function (_Component) {

  /**
   * player's constructor function
   *
   * @constructs
   * @method init
   * @param {Element} tag        The original video tag used for configuring options
   * @param {Object=} options    Player options
   * @param {Function=} ready    Ready callback function
   */

  function Player(tag, options, ready) {
    _classCallCheck(this, Player);

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + Lib.guid++;

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = Lib.obj.merge(Player.getTagSettings(tag), options);

    // Delay the initialization of children because we need to set up
    // player properties first, and can't use `this` before `super()`
    options.initChildren = false;

    // Same with creating the element
    options.createEl = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // Run base component initializing with new options
    _get(Object.getPrototypeOf(Player.prototype), 'constructor', this).call(this, null, options, ready);

    // if the global option object was accidentally blown away by
    // someone, bail early with an informative error
    if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {
      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
    }

    this.tag = tag; // Store the original tag used to set options

    // Store the tag attributes used to restore html5 element
    this.tagAttributes = tag && Lib.getElementAttributes(tag);

    // Update Current Language
    this.language_ = options['language'] || _optionsJs2['default']['language'];

    // Update Supported Languages
    this.languages_ = options['languages'] || _optionsJs2['default']['languages'];

    // Cache for video property values.
    this.cache_ = {};

    // Set poster
    this.poster_ = options['poster'] || '';

    // Set controls
    this.controls_ = !!options['controls'];
    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;

    /**
    * Store the internal state of scrubbing
    * @private
    * @return {Boolean} True if the user is scrubbing
    */
    this.scrubbing_ = false;

    this.el_ = this.createEl();

    // Load plugins
    if (options['plugins']) {
      Lib.obj.each(options['plugins'], function (key, val) {
        this[key](val);
      }, this);
    }

    this.initChildren();

    // Set isAudio based on whether or not an audio tag was used
    this.isAudio(tag.nodeName.toLowerCase() === 'audio');

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (this.controls()) {
      this.addClass('vjs-controls-enabled');
    } else {
      this.addClass('vjs-controls-disabled');
    }

    if (this.isAudio()) {
      this.addClass('vjs-audio');
    }

    if (this.flexNotSupported_()) {
      this.addClass('vjs-no-flex');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (Lib.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // Make player easily findable by ID
    Player.players[this.id_] = this;

    // When the player is first initialized, trigger activity so components
    // like the control bar show themselves if needed
    this.userActive_ = true;
    this.reportUserActivity();
    this.listenForUserActivity();

    this.on('fullscreenchange', this.handleFullscreenChange);
    this.on('stageclick', this.handleStageClick);
  }

  _inherits(Player, _Component);

  _createClass(Player, [{
    key: 'dispose',

    /**
     * Destroys the video player and does any necessary cleanup
     *
     *     myPlayer.dispose();
     *
     * This is especially helpful if you are dynamically adding and removing videos
     * to/from the DOM.
     */
    value: function dispose() {
      this.trigger('dispose');
      // prevent dispose from being called twice
      this.off('dispose');

      // Kill reference to this player
      Player.players[this.id_] = null;
      if (this.tag && this.tag['player']) {
        this.tag['player'] = null;
      }
      if (this.el_ && this.el_['player']) {
        this.el_['player'] = null;
      }

      if (this.tech) {
        this.tech.dispose();
      }

      _get(Object.getPrototypeOf(Player.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      var el = this.el_ = _get(Object.getPrototypeOf(Player.prototype), 'createEl', this).call(this, 'div');
      var tag = this.tag;

      // Remove width/height attrs from tag so CSS can make it 100% width/height
      tag.removeAttribute('width');
      tag.removeAttribute('height');

      // Copy over all the attributes from the tag, including ID and class
      // ID will now reference player box, not the video tag
      var attrs = Lib.getElementAttributes(tag);
      Lib.obj.each(attrs, function (attr) {
        // workaround so we don't totally break IE7
        // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
        if (attr === 'class') {
          el.className = attrs[attr];
        } else {
          el.setAttribute(attr, attrs[attr]);
        }
      });

      // Update tag id/class for use as HTML5 playback tech
      // Might think we should do this after embedding in container so .vjs-tech class
      // doesn't flash 100% width/height, but class only applies with .video-js parent
      tag.id += '_html5_api';
      tag.className = 'vjs-tech';

      // Make player findable on elements
      tag['player'] = el['player'] = this;
      // Default state of video is paused
      this.addClass('vjs-paused');

      // Make box use width/height of tag, or rely on default implementation
      // Enforce with CSS since width/height attrs don't work on divs
      this.width(this.options_['width'], true); // (true) Skip resize listener on load
      this.height(this.options_['height'], true);

      // Lib.insertFirst seems to cause the networkState to flicker from 3 to 2, so
      // keep track of the original for later so we can know if the source originally failed
      tag.initNetworkState_ = tag.networkState;

      // Wrap video tag in div (el/box) container
      if (tag.parentNode) {
        tag.parentNode.insertBefore(el, tag);
      }
      Lib.insertFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.

      this.el_ = el;

      return el;
    }
  }, {
    key: 'loadTech',

    /**
     * Load the Media Playback Technology (tech)
     * Load/Create an instance of playback technology including element and API methods
     * And append playback element in player div.
     */
    value: function loadTech(techName, source) {

      // Pause and remove current playback technology
      if (this.tech) {
        this.unloadTech();
      }

      // get rid of the HTML5 video tag as soon as we are using another tech
      if (techName !== 'Html5' && this.tag) {
        _componentJs2['default'].getComponent('Html5').disposeMediaElement(this.tag);
        this.tag.player = null;
        this.tag = null;
      }

      this.techName = techName;

      // Turn off API access because we're loading a new tech that might load asynchronously
      this.isReady_ = false;

      var techReady = Lib.bind(this, function () {
        this.triggerReady();
      });

      // Grab tech-specific options from player options and add source and parent element to use.
      var techOptions = Lib.obj.merge({
        'source': source,
        'playerId': this.id(),
        'textTracks': this.textTracks_
      }, this.options_[techName.toLowerCase()]);

      if (this.tag) {
        techOptions.tag = this.tag;
      }

      if (source) {
        this.currentType_ = source.type;
        if (source.src === this.cache_.src && this.cache_.currentTime > 0) {
          techOptions['startTime'] = this.cache_.currentTime;
        }

        this.cache_.src = source.src;
      }

      // Initialize tech instance
      var techComponent = _componentJs2['default'].getComponent(techName);
      this.tech = new techComponent(techOptions);

      this.on(this.tech, 'ready', this.handleTechReady);
      this.on(this.tech, 'usenativecontrols', this.handleTechUseNativeControls);

      // Listen to every HTML5 events and trigger them back on the player for the plugins
      this.on(this.tech, 'loadstart', this.handleTechLoadStart);
      this.on(this.tech, 'waiting', this.handleTechWaiting);
      this.on(this.tech, 'canplay', this.handleTechCanPlay);
      this.on(this.tech, 'canplaythrough', this.handleTechCanPlayThrough);
      this.on(this.tech, 'playing', this.handleTechPlaying);
      this.on(this.tech, 'ended', this.handleTechEnded);
      this.on(this.tech, 'seeking', this.handleTechSeeking);
      this.on(this.tech, 'seeked', this.handleTechSeeked);
      this.on(this.tech, 'play', this.handleTechPlay);
      this.on(this.tech, 'firstplay', this.handleTechFirstPlay);
      this.on(this.tech, 'pause', this.handleTechPause);
      this.on(this.tech, 'progress', this.handleTechProgress);
      this.on(this.tech, 'durationchange', this.handleTechDurationChange);
      this.on(this.tech, 'fullscreenchange', this.handleTechFullscreenChange);
      this.on(this.tech, 'error', this.handleTechError);
      this.on(this.tech, 'suspend', this.handleTechSuspend);
      this.on(this.tech, 'abort', this.handleTechAbort);
      this.on(this.tech, 'emptied', this.handleTechEmptied);
      this.on(this.tech, 'stalled', this.handleTechStalled);
      this.on(this.tech, 'loadedmetadata', this.handleTechLoadedMetaData);
      this.on(this.tech, 'metadataupdate', this.handleMetaDataUpdate);
      this.on(this.tech, 'loadeddata', this.handleTechLoadedData);
      this.on(this.tech, 'timeupdate', this.handleTechTimeUpdate);
      this.on(this.tech, 'ratechange', this.handleTechRateChange);
      this.on(this.tech, 'volumechange', this.handleTechVolumeChange);
      this.on(this.tech, 'texttrackchange', this.onTextTrackChange);

      if (this.controls() && !this.usingNativeControls()) {
        this.addTechControlsListeners();
      }

      // Add the tech element in the DOM if it was not already there
      // Make sure to not insert the original video element if using Html5
      if (this.tech.el().parentNode !== this.el() && (techName !== 'Html5' || !this.tag)) {
        Lib.insertFirst(this.tech.el(), this.el());
      }

      // Get rid of the original video tag reference after the first tech is loaded
      if (this.tag) {
        this.tag.player = null;
        this.tag = null;
      }

      this.tech.ready(techReady);
    }
  }, {
    key: 'unloadTech',
    value: function unloadTech() {
      // Save the current text tracks so that we can reuse the same text tracks with the next tech
      this.textTracks_ = this.textTracks();

      this.isReady_ = false;

      this.tech.dispose();

      this.tech = false;
    }
  }, {
    key: 'addTechControlsListeners',
    value: function addTechControlsListeners() {
      // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
      // trigger mousedown/up.
      // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
      // Any touch events are set to block the mousedown event from happening
      this.on(this.tech, 'mousedown', this.handleTechClick);

      // If the controls were hidden we don't want that to change without a tap event
      // so we'll check if the controls were already showing before reporting user
      // activity
      this.on(this.tech, 'touchstart', this.handleTechTouchStart);
      this.on(this.tech, 'touchmove', this.handleTechTouchMove);
      this.on(this.tech, 'touchend', this.handleTechTouchEnd);

      // Turn on component tap events
      this.tech.emitTapEvents();

      // The tap listener needs to come after the touchend listener because the tap
      // listener cancels out any reportedUserActivity when setting userActive(false)
      this.on(this.tech, 'tap', this.handleTechTap);
    }
  }, {
    key: 'removeTechControlsListeners',

    /**
     * Remove the listeners used for click and tap controls. This is needed for
     * toggling to controls disabled, where a tap/touch should do nothing.
     */
    value: function removeTechControlsListeners() {
      // We don't want to just use `this.off()` because there might be other needed
      // listeners added by techs that extend this.
      this.off(this.tech, 'tap', this.handleTechTap);
      this.off(this.tech, 'touchstart', this.handleTechTouchStart);
      this.off(this.tech, 'touchmove', this.handleTechTouchMove);
      this.off(this.tech, 'touchend', this.handleTechTouchEnd);
      this.off(this.tech, 'mousedown', this.handleTechClick);
    }
  }, {
    key: 'handleTechReady',

    /**
     * Player waits for the tech to be ready
     * @private
     */
    value: function handleTechReady() {
      this.triggerReady();

      // Chrome and Safari both have issues with autoplay.
      // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
      // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
      // This fixes both issues. Need to wait for API, so it updates displays correctly
      if (this.tag && this.options_.autoplay && this.paused()) {
        delete this.tag.poster; // Chrome Fix. Fixed in Chrome v16.
        this.play();
      }
    }
  }, {
    key: 'handleTechUseNativeControls',

    /**
     * Fired when the native controls are used
     * @private
     */
    value: function handleTechUseNativeControls() {
      this.usingNativeControls(true);
    }
  }, {
    key: 'handleTechLoadStart',

    /**
     * Fired when the user agent begins looking for media data
     * @event loadstart
     */
    value: function handleTechLoadStart() {
      // TODO: Update to use `emptied` event instead. See #1277.

      this.removeClass('vjs-ended');

      // reset the error state
      this.error(null);

      // If it's already playing we want to trigger a firstplay event now.
      // The firstplay event relies on both the play and loadstart events
      // which can happen in any order for a new source
      if (!this.paused()) {
        this.trigger('loadstart');
        this.trigger('firstplay');
      } else {
        // reset the hasStarted state
        this.hasStarted(false);
        this.trigger('loadstart');
      }
    }
  }, {
    key: 'hasStarted',
    value: function hasStarted(_hasStarted) {
      if (_hasStarted !== undefined) {
        // only update if this is a new value
        if (this.hasStarted_ !== _hasStarted) {
          this.hasStarted_ = _hasStarted;
          if (_hasStarted) {
            this.addClass('vjs-has-started');
            // trigger the firstplay event if this newly has played
            this.trigger('firstplay');
          } else {
            this.removeClass('vjs-has-started');
          }
        }
        return this;
      }
      return !!this.hasStarted_;
    }
  }, {
    key: 'handleTechPlay',

    /**
     * Fired whenever the media begins or resumes playback
     * @event play
     */
    value: function handleTechPlay() {
      this.removeClass('vjs-ended');
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');

      // hide the poster when the user hits play
      // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play
      this.hasStarted(true);

      this.trigger('play');
    }
  }, {
    key: 'handleTechWaiting',

    /**
     * Fired whenever the media begins waiting
     * @event waiting
     */
    value: function handleTechWaiting() {
      this.addClass('vjs-waiting');
      this.trigger('waiting');
    }
  }, {
    key: 'handleTechCanPlay',

    /**
     * A handler for events that signal that waiting has ended
     * which is not consistent between browsers. See #1351
     * @event canplay
     */
    value: function handleTechCanPlay() {
      this.removeClass('vjs-waiting');
      this.trigger('canplay');
    }
  }, {
    key: 'handleTechCanPlayThrough',

    /**
     * A handler for events that signal that waiting has ended
     * which is not consistent between browsers. See #1351
     * @event canplaythrough
     */
    value: function handleTechCanPlayThrough() {
      this.removeClass('vjs-waiting');
      this.trigger('canplaythrough');
    }
  }, {
    key: 'handleTechPlaying',

    /**
     * A handler for events that signal that waiting has ended
     * which is not consistent between browsers. See #1351
     * @event playing
     */
    value: function handleTechPlaying() {
      this.removeClass('vjs-waiting');
      this.trigger('playing');
    }
  }, {
    key: 'handleTechSeeking',

    /**
     * Fired whenever the player is jumping to a new time
     * @event seeking
     */
    value: function handleTechSeeking() {
      this.addClass('vjs-seeking');
      this.trigger('seeking');
    }
  }, {
    key: 'handleTechSeeked',

    /**
     * Fired when the player has finished jumping to a new time
     * @event seeked
     */
    value: function handleTechSeeked() {
      this.removeClass('vjs-seeking');
      this.trigger('seeked');
    }
  }, {
    key: 'handleTechFirstPlay',

    /**
     * Fired the first time a video is played
     *
     * Not part of the HLS spec, and we're not sure if this is the best
     * implementation yet, so use sparingly. If you don't have a reason to
     * prevent playback, use `myPlayer.one('play');` instead.
     *
     * @event firstplay
     */
    value: function handleTechFirstPlay() {
      //If the first starttime attribute is specified
      //then we will start at the given offset in seconds
      if (this.options_['starttime']) {
        this.currentTime(this.options_['starttime']);
      }

      this.addClass('vjs-has-started');
      this.trigger('firstplay');
    }
  }, {
    key: 'handleTechPause',

    /**
     * Fired whenever the media has been paused
     * @event pause
     */
    value: function handleTechPause() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      this.trigger('pause');
    }
  }, {
    key: 'handleTechProgress',

    /**
     * Fired while the user agent is downloading media data
     * @event progress
     */
    value: function handleTechProgress() {
      this.trigger('progress');

      // Add custom event for when source is finished downloading.
      if (this.bufferedPercent() === 1) {
        this.trigger('loadedalldata');
      }
    }
  }, {
    key: 'handleTechEnded',

    /**
     * Fired when the end of the media resource is reached (currentTime == duration)
     * @event ended
     */
    value: function handleTechEnded() {
      this.addClass('vjs-ended');
      if (this.options_['loop']) {
        this.currentTime(0);
        this.play();
      } else if (!this.paused()) {
        this.pause();
      }

      this.trigger('ended');
    }
  }, {
    key: 'handleTechDurationChange',

    /**
     * Fired when the duration of the media resource is first known or changed
     * @event durationchange
     */
    value: function handleTechDurationChange() {
      this.updateDuration();
      this.trigger('durationchange');
    }
  }, {
    key: 'handleTechClick',

    /**
     * Handle a click on the media element to play/pause
     */
    value: function handleTechClick(event) {
      // We're using mousedown to detect clicks thanks to Flash, but mousedown
      // will also be triggered with right-clicks, so we need to prevent that
      if (event.button !== 0) return;

      // When controls are disabled a click should not toggle playback because
      // the click is considered a control
      if (this.controls()) {
        if (this.paused()) {
          this.play();
        } else {
          this.pause();
        }
      }
    }
  }, {
    key: 'handleTechTap',

    /**
     * Handle a tap on the media element. It will toggle the user
     * activity state, which hides and shows the controls.
     */
    value: function handleTechTap() {
      this.userActive(!this.userActive());
    }
  }, {
    key: 'handleTechTouchStart',
    value: function handleTechTouchStart() {
      this.userWasActive = this.userActive();
    }
  }, {
    key: 'handleTechTouchMove',
    value: function handleTechTouchMove() {
      if (this.userWasActive) {
        this.reportUserActivity();
      }
    }
  }, {
    key: 'handleTechTouchEnd',
    value: function handleTechTouchEnd(event) {
      // Stop the mouse events from also happening
      event.preventDefault();
    }
  }, {
    key: 'updateDuration',

    /**
     * Update the duration of the player using the tech
     * @private
     */
    value: function updateDuration() {
      // Allows for caching value instead of asking player each time.
      // We need to get the techGet response and check for a value so we don't
      // accidentally cause the stack to blow up.
      var duration = this.techGet('duration');
      if (duration) {
        if (duration < 0) {
          duration = Infinity;
        }
        this.duration(duration);
        // Determine if the stream is live and propagate styles down to UI.
        if (duration === Infinity) {
          this.addClass('vjs-live');
        } else {
          this.removeClass('vjs-live');
        }
      }
    }
  }, {
    key: 'handleFullscreenChange',

    /**
     * Fired when the player switches in or out of fullscreen mode
     * @event fullscreenchange
     */
    value: function handleFullscreenChange() {
      if (this.isFullscreen()) {
        this.addClass('vjs-fullscreen');
      } else {
        this.removeClass('vjs-fullscreen');
      }
    }
  }, {
    key: 'handleStageClick',

    /**
     * native click events on the SWF aren't triggered on IE11, Win8.1RT
     * use stageclick events triggered from inside the SWF instead
     * @private
     */
    value: function handleStageClick() {
      this.reportUserActivity();
    }
  }, {
    key: 'handleTechFullscreenChange',
    value: function handleTechFullscreenChange() {
      this.trigger('fullscreenchange');
    }
  }, {
    key: 'handleTechError',

    /**
     * Fires when an error occurred during the loading of an audio/video
     * @event error
     */
    value: function handleTechError() {
      this.error(this.tech.error().code);
    }
  }, {
    key: 'handleTechSuspend',

    /**
     * Fires when the browser is intentionally not getting media data
     * @event suspend
     */
    value: function handleTechSuspend() {
      this.trigger('suspend');
    }
  }, {
    key: 'handleTechAbort',

    /**
     * Fires when the loading of an audio/video is aborted
     * @event abort
     */
    value: function handleTechAbort() {
      this.trigger('abort');
    }
  }, {
    key: 'handleTechEmptied',

    /**
     * Fires when the current playlist is empty
     * @event emptied
     */
    value: function handleTechEmptied() {
      this.trigger('emptied');
    }
  }, {
    key: 'handleTechStalled',

    /**
     * Fires when the browser is trying to get media data, but data is not available
     * @event stalled
     */
    value: function handleTechStalled() {
      this.trigger('stalled');
    }
  }, {
    key: 'handleTechLoadedMetaData',

    /**
     * Fires when the browser has loaded meta data for the audio/video
     * @event loadedmetadata
     */
    value: function handleTechLoadedMetaData() {
      this.trigger('loadedmetadata');
    }
  }, {
    key: 'handleMetaDataUpdate',

    /**
     * Fires when the swf issues a metadataupdate event, an event specific to our
     * Abacast stream that uses Flash's onMetaData event to surface synced banner
     * ads to listeners.
     * @event metadataupdate
     * @param e event object to be triggered for external listeners, retriggering
     * it here ensures the original event object makes it to any listeners.
     */
    value: function handleMetaDataUpdate(e) {
      this.trigger(e);
    }
  }, {
    key: 'handleTechLoadedData',

    /**
     * Fires when the browser has loaded the current frame of the audio/video
     * @event loaddata
     */
    value: function handleTechLoadedData() {
      this.trigger('loadeddata');
    }
  }, {
    key: 'handleTechTimeUpdate',

    /**
     * Fires when the current playback position has changed
     * @event timeupdate
     */
    value: function handleTechTimeUpdate() {
      this.trigger('timeupdate');
    }
  }, {
    key: 'handleTechRateChange',

    /**
     * Fires when the playing speed of the audio/video is changed
     * @event ratechange
     */
    value: function handleTechRateChange() {
      this.trigger('ratechange');
    }
  }, {
    key: 'handleTechVolumeChange',

    /**
     * Fires when the volume has been changed
     * @event volumechange
     */
    value: function handleTechVolumeChange() {
      this.trigger('volumechange');
    }
  }, {
    key: 'onTextTrackChange',

    /**
     * Fires when the text track has been changed
     * @event texttrackchange
     */
    value: function onTextTrackChange() {
      this.trigger('texttrackchange');
    }
  }, {
    key: 'getCache',

    /**
     * Object for cached values.
     */
    value: function getCache() {
      return this.cache_;
    }
  }, {
    key: 'techCall',

    // Pass values to the playback tech
    value: function techCall(method, arg) {
      // If it's not ready yet, call method when it is
      if (this.tech && !this.tech.isReady_) {
        this.tech.ready(function () {
          this[method](arg);
        });

        // Otherwise call method now
      } else {
        try {
          this.tech[method](arg);
        } catch (e) {
          Lib.log(e);
          throw e;
        }
      }
    }
  }, {
    key: 'techGet',

    // Get calls can't wait for the tech, and sometimes don't need to.
    value: function techGet(method) {
      if (this.tech && this.tech.isReady_) {

        // Flash likes to die and reload when you hide or reposition it.
        // In these cases the object methods go away and we get errors.
        // When that happens we'll catch the errors and inform tech that it's not ready any more.
        try {
          return this.tech[method]();
        } catch (e) {
          // When building additional tech libs, an expected method may not be defined yet
          if (this.tech[method] === undefined) {
            Lib.log('Video.js: ' + method + ' method not defined for ' + this.techName + ' playback technology.', e);
          } else {
            // When a method isn't available on the object it throws a TypeError
            if (e.name === 'TypeError') {
              Lib.log('Video.js: ' + method + ' unavailable on ' + this.techName + ' playback technology element.', e);
              this.tech.isReady_ = false;
            } else {
              Lib.log(e);
            }
          }
          throw e;
        }
      }

      return;
    }
  }, {
    key: 'play',

    /**
     * start media playback
     *
     *     myPlayer.play();
     *
     * @return {Player} self
     */
    value: function play() {
      this.techCall('play');
      return this;
    }
  }, {
    key: 'pause',

    /**
     * Pause the video playback
     *
     *     myPlayer.pause();
     *
     * @return {Player} self
     */
    value: function pause() {
      this.techCall('pause');
      return this;
    }
  }, {
    key: 'paused',

    /**
     * Check if the player is paused
     *
     *     var isPaused = myPlayer.paused();
     *     var isPlaying = !myPlayer.paused();
     *
     * @return {Boolean} false if the media is currently playing, or true otherwise
     */
    value: function paused() {
      // The initial state of paused should be true (in Safari it's actually false)
      return this.techGet('paused') === false ? false : true;
    }
  }, {
    key: 'scrubbing',

    /**
    * Returns whether or not the user is "scrubbing". Scrubbing is when the user
    * has clicked the progress bar handle and is dragging it along the progress bar.
    * @param  {Boolean} isScrubbing   True/false the user is scrubbing
    * @return {Boolean}               The scrubbing status when getting
    * @return {Object}                The player when setting
    */
    value: function scrubbing(isScrubbing) {
      if (isScrubbing !== undefined) {
        this.scrubbing_ = !!isScrubbing;

        if (isScrubbing) {
          this.addClass('vjs-scrubbing');
        } else {
          this.removeClass('vjs-scrubbing');
        }

        return this;
      }

      return this.scrubbing_;
    }
  }, {
    key: 'currentTime',

    /**
     * Get or set the current time (in seconds)
     *
     *     // get
     *     var whereYouAt = myPlayer.currentTime();
     *
     *     // set
     *     myPlayer.currentTime(120); // 2 minutes into the video
     *
     * @param  {Number|String=} seconds The time to seek to
     * @return {Number}        The time in seconds, when not setting
     * @return {Player}    self, when the current time is set
     */
    value: function currentTime(seconds) {
      if (seconds !== undefined) {

        this.techCall('setCurrentTime', seconds);

        return this;
      }

      // cache last currentTime and return. default to 0 seconds
      //
      // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
      // currentTime when scrubbing, but may not provide much performance benefit afterall.
      // Should be tested. Also something has to read the actual current time or the cache will
      // never get updated.
      return this.cache_.currentTime = this.techGet('currentTime') || 0;
    }
  }, {
    key: 'duration',

    /**
     * Get the length in time of the video in seconds
     *
     *     var lengthOfVideo = myPlayer.duration();
     *
     * **NOTE**: The video must have started loading before the duration can be
     * known, and in the case of Flash, may not be known until the video starts
     * playing.
     *
     * @return {Number} The duration of the video in seconds
     */
    value: function duration(seconds) {
      if (seconds !== undefined) {

        // cache the last set value for optimized scrubbing (esp. Flash)
        this.cache_.duration = parseFloat(seconds);

        return this;
      }

      if (this.cache_.duration === undefined) {
        this.updateDuration();
      }

      return this.cache_.duration || 0;
    }
  }, {
    key: 'remainingTime',

    /**
     * Calculates how much time is left.
     *
     *     var timeLeft = myPlayer.remainingTime();
     *
     * Not a native video element function, but useful
     * @return {Number} The time remaining in seconds
     */
    value: function remainingTime() {
      return this.duration() - this.currentTime();
    }
  }, {
    key: 'buffered',

    // http://dev.w3.org/html5/spec/video.html#dom-media-buffered
    // Buffered returns a timerange object.
    // Kind of like an array of portions of the video that have been downloaded.

    /**
     * Get a TimeRange object with the times of the video that have been downloaded
     *
     * If you just want the percent of the video that's been downloaded,
     * use bufferedPercent.
     *
     *     // Number of different ranges of time have been buffered. Usually 1.
     *     numberOfRanges = bufferedTimeRange.length,
     *
     *     // Time in seconds when the first range starts. Usually 0.
     *     firstRangeStart = bufferedTimeRange.start(0),
     *
     *     // Time in seconds when the first range ends
     *     firstRangeEnd = bufferedTimeRange.end(0),
     *
     *     // Length in seconds of the first time range
     *     firstRangeLength = firstRangeEnd - firstRangeStart;
     *
     * @return {Object} A mock TimeRange object (following HTML spec)
     */
    value: function buffered() {
      var buffered = this.techGet('buffered');

      if (!buffered || !buffered.length) {
        buffered = Lib.createTimeRange(0, 0);
      }

      return buffered;
    }
  }, {
    key: 'bufferedPercent',

    /**
     * Get the percent (as a decimal) of the video that's been downloaded
     *
     *     var howMuchIsDownloaded = myPlayer.bufferedPercent();
     *
     * 0 means none, 1 means all.
     * (This method isn't in the HTML5 spec, but it's very convenient)
     *
     * @return {Number} A decimal between 0 and 1 representing the percent
     */
    value: function bufferedPercent() {
      var duration = this.duration(),
          buffered = this.buffered(),
          bufferedDuration = 0,
          start,
          end;

      if (!duration) {
        return 0;
      }

      for (var i = 0; i < buffered.length; i++) {
        start = buffered.start(i);
        end = buffered.end(i);

        // buffered end can be bigger than duration by a very small fraction
        if (end > duration) {
          end = duration;
        }

        bufferedDuration += end - start;
      }

      return bufferedDuration / duration;
    }
  }, {
    key: 'bufferedEnd',

    /**
     * Get the ending time of the last buffered time range
     *
     * This is used in the progress bar to encapsulate all time ranges.
     * @return {Number} The end of the last buffered time range
     */
    value: function bufferedEnd() {
      var buffered = this.buffered(),
          duration = this.duration(),
          end = buffered.end(buffered.length - 1);

      if (end > duration) {
        end = duration;
      }

      return end;
    }
  }, {
    key: 'volume',

    /**
     * Get or set the current volume of the media
     *
     *     // get
     *     var howLoudIsIt = myPlayer.volume();
     *
     *     // set
     *     myPlayer.volume(0.5); // Set volume to half
     *
     * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.
     *
     * @param  {Number} percentAsDecimal The new volume as a decimal percent
     * @return {Number}                  The current volume, when getting
     * @return {Player}              self, when setting
     */
    value: function volume(percentAsDecimal) {
      var vol = undefined;

      if (percentAsDecimal !== undefined) {
        vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1
        this.cache_.volume = vol;
        this.techCall('setVolume', vol);
        Lib.setLocalStorage('volume', vol);
        return this;
      }

      // Default to 1 when returning current volume.
      vol = parseFloat(this.techGet('volume'));
      return isNaN(vol) ? 1 : vol;
    }
  }, {
    key: 'muted',

    /**
     * Get the current muted state, or turn mute on or off
     *
     *     // get
     *     var isVolumeMuted = myPlayer.muted();
     *
     *     // set
     *     myPlayer.muted(true); // mute the volume
     *
     * @param  {Boolean=} muted True to mute, false to unmute
     * @return {Boolean} True if mute is on, false if not, when getting
     * @return {Player} self, when setting mute
     */
    value: function muted(_muted) {
      if (_muted !== undefined) {
        this.techCall('setMuted', _muted);
        return this;
      }
      return this.techGet('muted') || false; // Default to false
    }
  }, {
    key: 'supportsFullScreen',

    // Check if current tech can support native fullscreen
    // (e.g. with built in controls like iOS, so not our flash swf)
    value: function supportsFullScreen() {
      return this.techGet('supportsFullScreen') || false;
    }
  }, {
    key: 'isFullscreen',

    /**
     * Check if the player is in fullscreen mode
     *
     *     // get
     *     var fullscreenOrNot = myPlayer.isFullscreen();
     *
     *     // set
     *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen
     *
     * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
     * property and instead document.fullscreenElement is used. But isFullscreen is
     * still a valuable property for internal player workings.
     *
     * @param  {Boolean=} isFS Update the player's fullscreen state
     * @return {Boolean} true if fullscreen, false if not
     * @return {Player} self, when setting
     */
    value: function isFullscreen(isFS) {
      if (isFS !== undefined) {
        this.isFullscreen_ = !!isFS;
        return this;
      }
      return !!this.isFullscreen_;
    }
  }, {
    key: 'isFullScreen',

    /**
     * Old naming for isFullscreen()
     * @deprecated for lowercase 's' version
     */
    value: function isFullScreen(isFS) {
      Lib.log.warn('player.isFullScreen() has been deprecated, use player.isFullscreen() with a lowercase "s")');
      return this.isFullscreen(isFS);
    }
  }, {
    key: 'requestFullscreen',

    /**
     * Increase the size of the video to full screen
     *
     *     myPlayer.requestFullscreen();
     *
     * In some browsers, full screen is not supported natively, so it enters
     * "full window mode", where the video fills the browser window.
     * In browsers and devices that support native full screen, sometimes the
     * browser's default controls will be shown, and not the Video.js custom skin.
     * This includes most mobile devices (iOS, Android) and older versions of
     * Safari.
     *
     * @return {Player} self
     */
    value: function requestFullscreen() {
      var fsApi = _fullscreenApiJs2['default'];

      this.isFullscreen(true);

      if (fsApi) {
        // the browser supports going fullscreen at the element level so we can
        // take the controls fullscreen as well as the video

        // Trigger fullscreenchange event after change
        // We have to specifically add this each time, and remove
        // when canceling fullscreen. Otherwise if there's multiple
        // players on a page, they would all be reacting to the same fullscreen
        // events
        Events.on(_globalDocument2['default'], fsApi['fullscreenchange'], Lib.bind(this, function documentFullscreenChange(e) {
          this.isFullscreen(_globalDocument2['default'][fsApi.fullscreenElement]);

          // If cancelling fullscreen, remove event listener.
          if (this.isFullscreen() === false) {
            Events.off(_globalDocument2['default'], fsApi['fullscreenchange'], documentFullscreenChange);
          }

          this.trigger('fullscreenchange');
        }));

        this.el_[fsApi.requestFullscreen]();
      } else if (this.tech.supportsFullScreen()) {
        // we can't take the video.js controls fullscreen but we can go fullscreen
        // with native controls
        this.techCall('enterFullScreen');
      } else {
        // fullscreen isn't supported so we'll just stretch the video element to
        // fill the viewport
        this.enterFullWindow();
        this.trigger('fullscreenchange');
      }

      return this;
    }
  }, {
    key: 'requestFullScreen',

    /**
     * Old naming for requestFullscreen
     * @deprecated for lower case 's' version
     */
    value: function requestFullScreen() {
      Lib.log.warn('player.requestFullScreen() has been deprecated, use player.requestFullscreen() with a lowercase "s")');
      return this.requestFullscreen();
    }
  }, {
    key: 'exitFullscreen',

    /**
     * Return the video to its normal size after having been in full screen mode
     *
     *     myPlayer.exitFullscreen();
     *
     * @return {Player} self
     */
    value: function exitFullscreen() {
      var fsApi = _fullscreenApiJs2['default'];
      this.isFullscreen(false);

      // Check for browser element fullscreen support
      if (fsApi) {
        _globalDocument2['default'][fsApi.exitFullscreen]();
      } else if (this.tech.supportsFullScreen()) {
        this.techCall('exitFullScreen');
      } else {
        this.exitFullWindow();
        this.trigger('fullscreenchange');
      }

      return this;
    }
  }, {
    key: 'cancelFullScreen',

    /**
     * Old naming for exitFullscreen
     * @deprecated for exitFullscreen
     */
    value: function cancelFullScreen() {
      Lib.log.warn('player.cancelFullScreen() has been deprecated, use player.exitFullscreen()');
      return this.exitFullscreen();
    }
  }, {
    key: 'enterFullWindow',

    // When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.
    value: function enterFullWindow() {
      this.isFullWindow = true;

      // Storing original doc overflow value to return to when fullscreen is off
      this.docOrigOverflow = _globalDocument2['default'].documentElement.style.overflow;

      // Add listener for esc key to exit fullscreen
      Events.on(_globalDocument2['default'], 'keydown', Lib.bind(this, this.fullWindowOnEscKey));

      // Hide any scroll bars
      _globalDocument2['default'].documentElement.style.overflow = 'hidden';

      // Apply fullscreen styles
      Lib.addClass(_globalDocument2['default'].body, 'vjs-full-window');

      this.trigger('enterFullWindow');
    }
  }, {
    key: 'fullWindowOnEscKey',
    value: function fullWindowOnEscKey(event) {
      if (event.keyCode === 27) {
        if (this.isFullscreen() === true) {
          this.exitFullscreen();
        } else {
          this.exitFullWindow();
        }
      }
    }
  }, {
    key: 'exitFullWindow',
    value: function exitFullWindow() {
      this.isFullWindow = false;
      Events.off(_globalDocument2['default'], 'keydown', this.fullWindowOnEscKey);

      // Unhide scroll bars.
      _globalDocument2['default'].documentElement.style.overflow = this.docOrigOverflow;

      // Remove fullscreen styles
      Lib.removeClass(_globalDocument2['default'].body, 'vjs-full-window');

      // Resize the box, controller, and poster to original sizes
      // this.positionAll();
      this.trigger('exitFullWindow');
    }
  }, {
    key: 'selectSource',
    value: function selectSource(sources) {
      // Loop through each playback technology in the options order
      for (var i = 0, j = this.options_['techOrder']; i < j.length; i++) {
        var techName = Lib.capitalize(j[i]);
        var tech = _componentJs2['default'].getComponent(techName);

        // Check if the current tech is defined before continuing
        if (!tech) {
          Lib.log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
          continue;
        }

        // Check if the browser supports this technology
        if (tech.isSupported()) {
          // Loop through each source object
          for (var a = 0, b = sources; a < b.length; a++) {
            var source = b[a];

            // Check if source can be played with this technology
            if (tech['canPlaySource'](source)) {
              return { source: source, tech: techName };
            }
          }
        }
      }

      return false;
    }
  }, {
    key: 'src',

    /**
     * The source function updates the video source
     *
     * There are three types of variables you can pass as the argument.
     *
     * **URL String**: A URL to the the video file. Use this method if you are sure
     * the current playback technology (HTML5/Flash) can support the source you
     * provide. Currently only MP4 files can be used in both HTML5 and Flash.
     *
     *     myPlayer.src("http://www.example.com/path/to/video.mp4");
     *
     * **Source Object (or element):** A javascript object containing information
     * about the source file. Use this method if you want the player to determine if
     * it can support the file using the type information.
     *
     *     myPlayer.src({ type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" });
     *
     * **Array of Source Objects:** To provide multiple versions of the source so
     * that it can be played using HTML5 across browsers you can use an array of
     * source objects. Video.js will detect which version is supported and load that
     * file.
     *
     *     myPlayer.src([
     *       { type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" },
     *       { type: "video/webm", src: "http://www.example.com/path/to/video.webm" },
     *       { type: "video/ogg", src: "http://www.example.com/path/to/video.ogv" }
     *     ]);
     *
     * @param  {String|Object|Array=} source The source URL, object, or array of sources
     * @return {String} The current video source when getting
     * @return {String} The player when setting
     */
    value: function src() {
      var source = arguments[0] === undefined ? this.techGet('src') : arguments[0];

      var currentTech = _componentJs2['default'].getComponent(this.techName);

      // case: Array of source objects to choose from and pick the best to play
      if (Lib.obj.isArray(source)) {
        this.sourceList_(source);

        // case: URL String (http://myvideo...)
      } else if (typeof source === 'string') {
        // create a source object from the string
        this.src({ src: source });

        // case: Source object { src: '', type: '' ... }
      } else if (source instanceof Object) {
        // check if the source has a type and the loaded tech cannot play the source
        // if there's no type we'll just try the current tech
        if (source.type && !currentTech['canPlaySource'](source)) {
          // create a source list with the current source and send through
          // the tech loop to check for a compatible technology
          this.sourceList_([source]);
        } else {
          this.cache_.src = source.src;
          this.currentType_ = source.type || '';

          // wait until the tech is ready to set the source
          this.ready(function () {

            // The setSource tech method was added with source handlers
            // so older techs won't support it
            // We need to check the direct prototype for the case where subclasses
            // of the tech do not support source handlers
            if (currentTech.prototype.hasOwnProperty('setSource')) {
              this.techCall('setSource', source);
            } else {
              this.techCall('src', source.src);
            }

            if (this.options_['preload'] === 'auto') {
              this.load();
            }

            if (this.options_['autoplay']) {
              this.play();
            }
          });
        }
      }

      return this;
    }
  }, {
    key: 'sourceList_',

    /**
     * Handle an array of source objects
     * @param  {[type]} sources Array of source objects
     * @private
     */
    value: function sourceList_(sources) {
      var sourceTech = this.selectSource(sources);

      if (sourceTech) {
        if (sourceTech.tech === this.techName) {
          // if this technology is already loaded, set the source
          this.src(sourceTech.source);
        } else {
          // load this technology with the chosen source
          this.loadTech(sourceTech.tech, sourceTech.source);
        }
      } else {
        // We need to wrap this in a timeout to give folks a chance to add error event handlers
        this.setTimeout(function () {
          this.error({ code: 4, message: this.localize(this.options()['notSupportedMessage']) });
        }, 0);

        // we could not find an appropriate tech, but let's still notify the delegate that this is it
        // this needs a better comment about why this is needed
        this.triggerReady();
      }
    }
  }, {
    key: 'load',

    /**
     * Begin loading the src data.
     * @return {Player} Returns the player
     */
    value: function load() {
      this.techCall('load');
      return this;
    }
  }, {
    key: 'currentSrc',

    /**
     * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
     * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
     * @return {String} The current source
     */
    value: function currentSrc() {
      return this.techGet('currentSrc') || this.cache_.src || '';
    }
  }, {
    key: 'currentType',

    /**
     * Get the current source type e.g. video/mp4
     * This can allow you rebuild the current source object so that you could load the same
     * source and tech later
     * @return {String} The source MIME type
     */
    value: function currentType() {
      return this.currentType_ || '';
    }
  }, {
    key: 'preload',

    /**
     * Get or set the preload attribute.
     * @return {String} The preload attribute value when getting
     * @return {Player} Returns the player when setting
     */
    value: function preload(value) {
      if (value !== undefined) {
        this.techCall('setPreload', value);
        this.options_['preload'] = value;
        return this;
      }
      return this.techGet('preload');
    }
  }, {
    key: 'autoplay',

    /**
     * Get or set the autoplay attribute.
     * @return {String} The autoplay attribute value when getting
     * @return {Player} Returns the player when setting
     */
    value: function autoplay(value) {
      if (value !== undefined) {
        this.techCall('setAutoplay', value);
        this.options_['autoplay'] = value;
        return this;
      }
      return this.techGet('autoplay', value);
    }
  }, {
    key: 'loop',

    /**
     * Get or set the loop attribute on the video element.
     * @return {String} The loop attribute value when getting
     * @return {Player} Returns the player when setting
     */
    value: function loop(value) {
      if (value !== undefined) {
        this.techCall('setLoop', value);
        this.options_['loop'] = value;
        return this;
      }
      return this.techGet('loop');
    }
  }, {
    key: 'poster',

    /**
     * get or set the poster image source url
     *
     * ##### EXAMPLE:
     *
     *     // getting
     *     var currentPoster = myPlayer.poster();
     *
     *     // setting
     *     myPlayer.poster('http://example.com/myImage.jpg');
     *
     * @param  {String=} [src] Poster image source URL
     * @return {String} poster URL when getting
     * @return {Player} self when setting
     */
    value: function poster(src) {
      if (src === undefined) {
        return this.poster_;
      }

      // The correct way to remove a poster is to set as an empty string
      // other falsey values will throw errors
      if (!src) {
        src = '';
      }

      // update the internal poster variable
      this.poster_ = src;

      // update the tech's poster
      this.techCall('setPoster', src);

      // alert components that the poster has been set
      this.trigger('posterchange');

      return this;
    }
  }, {
    key: 'controls',

    /**
     * Get or set whether or not the controls are showing.
     * @param  {Boolean} controls Set controls to showing or not
     * @return {Boolean}    Controls are showing
     */
    value: function controls(bool) {
      if (bool !== undefined) {
        bool = !!bool; // force boolean
        // Don't trigger a change event unless it actually changed
        if (this.controls_ !== bool) {
          this.controls_ = bool;

          if (this.usingNativeControls()) {
            this.techCall('setControls', bool);
          }

          if (bool) {
            this.removeClass('vjs-controls-disabled');
            this.addClass('vjs-controls-enabled');
            this.trigger('controlsenabled');

            if (!this.usingNativeControls()) {
              this.addTechControlsListeners();
            }
          } else {
            this.removeClass('vjs-controls-enabled');
            this.addClass('vjs-controls-disabled');
            this.trigger('controlsdisabled');

            if (!this.usingNativeControls()) {
              this.removeTechControlsListeners();
            }
          }
        }
        return this;
      }
      return !!this.controls_;
    }
  }, {
    key: 'usingNativeControls',

    /**
     * Toggle native controls on/off. Native controls are the controls built into
     * devices (e.g. default iPhone controls), Flash, or other techs
     * (e.g. Vimeo Controls)
     *
     * **This should only be set by the current tech, because only the tech knows
     * if it can support native controls**
     *
     * @param  {Boolean} bool    True signals that native controls are on
     * @return {Player}      Returns the player
     * @private
     */
    value: function usingNativeControls(bool) {
      if (bool !== undefined) {
        bool = !!bool; // force boolean
        // Don't trigger a change event unless it actually changed
        if (this.usingNativeControls_ !== bool) {
          this.usingNativeControls_ = bool;
          if (bool) {
            this.addClass('vjs-using-native-controls');

            /**
             * player is using the native device controls
             *
             * @event usingnativecontrols
             * @memberof Player
             * @instance
             * @private
             */
            this.trigger('usingnativecontrols');
          } else {
            this.removeClass('vjs-using-native-controls');

            /**
             * player is using the custom HTML controls
             *
             * @event usingcustomcontrols
             * @memberof Player
             * @instance
             * @private
             */
            this.trigger('usingcustomcontrols');
          }
        }
        return this;
      }
      return !!this.usingNativeControls_;
    }
  }, {
    key: 'error',

    /**
     * Set or get the current MediaError
     * @param  {*} err A MediaError or a String/Number to be turned into a MediaError
     * @return {MediaError|null}     when getting
     * @return {Player}              when setting
     */
    value: function error(err) {
      if (err === undefined) {
        return this.error_ || null;
      }

      // restoring to default
      if (err === null) {
        this.error_ = err;
        this.removeClass('vjs-error');
        return this;
      }

      // error instance
      if (err instanceof _mediaErrorJs2['default']) {
        this.error_ = err;
      } else {
        this.error_ = new _mediaErrorJs2['default'](err);
      }

      // fire an error event on the player
      this.trigger('error');

      // add the vjs-error classname to the player
      this.addClass('vjs-error');

      // log the name of the error type and any message
      // ie8 just logs "[object object]" if you just log the error object
      Lib.log.error('(CODE:' + this.error_.code + ' ' + _mediaErrorJs2['default'].errorTypes[this.error_.code] + ')', this.error_.message, this.error_);

      return this;
    }
  }, {
    key: 'ended',

    /**
     * Returns whether or not the player is in the "ended" state.
     * @return {Boolean} True if the player is in the ended state, false if not.
     */
    value: function ended() {
      return this.techGet('ended');
    }
  }, {
    key: 'seeking',

    /**
     * Returns whether or not the player is in the "seeking" state.
     * @return {Boolean} True if the player is in the seeking state, false if not.
     */
    value: function seeking() {
      return this.techGet('seeking');
    }
  }, {
    key: 'reportUserActivity',
    value: function reportUserActivity(event) {
      this.userActivity_ = true;
    }
  }, {
    key: 'userActive',
    value: function userActive(bool) {
      if (bool !== undefined) {
        bool = !!bool;
        if (bool !== this.userActive_) {
          this.userActive_ = bool;
          if (bool) {
            // If the user was inactive and is now active we want to reset the
            // inactivity timer
            this.userActivity_ = true;
            this.removeClass('vjs-user-inactive');
            this.addClass('vjs-user-active');
            this.trigger('useractive');
          } else {
            // We're switching the state to inactive manually, so erase any other
            // activity
            this.userActivity_ = false;

            // Chrome/Safari/IE have bugs where when you change the cursor it can
            // trigger a mousemove event. This causes an issue when you're hiding
            // the cursor when the user is inactive, and a mousemove signals user
            // activity. Making it impossible to go into inactive mode. Specifically
            // this happens in fullscreen when we really need to hide the cursor.
            //
            // When this gets resolved in ALL browsers it can be removed
            // https://code.google.com/p/chromium/issues/detail?id=103041
            if (this.tech) {
              this.tech.one('mousemove', function (e) {
                e.stopPropagation();
                e.preventDefault();
              });
            }

            this.removeClass('vjs-user-active');
            this.addClass('vjs-user-inactive');
            this.trigger('userinactive');
          }
        }
        return this;
      }
      return this.userActive_;
    }
  }, {
    key: 'listenForUserActivity',
    value: function listenForUserActivity() {
      var mouseInProgress = undefined,
          lastMoveX = undefined,
          lastMoveY = undefined;

      var handleActivity = Lib.bind(this, this.reportUserActivity);

      var handleMouseMove = function handleMouseMove(e) {
        // #1068 - Prevent mousemove spamming
        // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
        if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
          lastMoveX = e.screenX;
          lastMoveY = e.screenY;
          handleActivity();
        }
      };

      var handleMouseDown = function handleMouseDown() {
        handleActivity();
        // For as long as the they are touching the device or have their mouse down,
        // we consider them active even if they're not moving their finger or mouse.
        // So we want to continue to update that they are active
        this.clearInterval(mouseInProgress);
        // Setting userActivity=true now and setting the interval to the same time
        // as the activityCheck interval (250) should ensure we never miss the
        // next activityCheck
        mouseInProgress = this.setInterval(handleActivity, 250);
      };

      var handleMouseUp = function handleMouseUp(event) {
        handleActivity();
        // Stop the interval that maintains activity if the mouse/touch is down
        this.clearInterval(mouseInProgress);
      };

      // Any mouse movement will be considered user activity
      this.on('mousedown', handleMouseDown);
      this.on('mousemove', handleMouseMove);
      this.on('mouseup', handleMouseUp);

      // Listen for keyboard navigation
      // Shouldn't need to use inProgress interval because of key repeat
      this.on('keydown', handleActivity);
      this.on('keyup', handleActivity);

      // Run an interval every 250 milliseconds instead of stuffing everything into
      // the mousemove/touchmove function itself, to prevent performance degradation.
      // `this.reportUserActivity` simply sets this.userActivity_ to true, which
      // then gets picked up by this loop
      // http://ejohn.org/blog/learning-from-twitter/
      var activityCheck = this.setInterval(function () {
        var inactivityTimeout = undefined;

        // Check to see if mouse/touch activity has happened
        if (this.userActivity_) {
          // Reset the activity tracker
          this.userActivity_ = false;

          // If the user state was inactive, set the state to active
          this.userActive(true);

          // Clear any existing inactivity timeout to start the timer over
          this.clearTimeout(inactivityTimeout);

          var timeout = this.options()['inactivityTimeout'];
          if (timeout > 0) {
            // In <timeout> milliseconds, if no more activity has occurred the
            // user will be considered inactive
            inactivityTimeout = this.setTimeout(function () {
              // Protect against the case where the inactivityTimeout can trigger just
              // before the next user activity is picked up by the activityCheck loop
              // causing a flicker
              if (!this.userActivity_) {
                this.userActive(false);
              }
            }, timeout);
          }
        }
      }, 250);
    }
  }, {
    key: 'playbackRate',

    /**
     * Gets or sets the current playback rate.  A playback rate of
     * 1.0 represents normal speed and 0.5 would indicate half-speed
     * playback, for instance.
     * @param  {Number} rate    New playback rate to set.
     * @return {Number}         Returns the new playback rate when setting
     * @return {Number}         Returns the current playback rate when getting
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
     */
    value: function playbackRate(rate) {
      if (rate !== undefined) {
        this.techCall('setPlaybackRate', rate);
        return this;
      }

      if (this.tech && this.tech['featuresPlaybackRate']) {
        return this.techGet('playbackRate');
      } else {
        return 1;
      }
    }
  }, {
    key: 'isAudio',

    /**
     * Gets or sets the audio flag
     *
     * @param  {Boolean} bool    True signals that this is an audio player.
     * @return {Boolean}         Returns true if player is audio, false if not when getting
     * @return {Player}      Returns the player if setting
     * @private
     */
    value: function isAudio(bool) {
      if (bool !== undefined) {
        this.isAudio_ = !!bool;
        return this;
      }

      return !!this.isAudio_;
    }
  }, {
    key: 'networkState',

    /**
     * Returns the current state of network activity for the element, from
     * the codes in the list below.
     * - NETWORK_EMPTY (numeric value 0)
     *   The element has not yet been initialised. All attributes are in
     *   their initial states.
     * - NETWORK_IDLE (numeric value 1)
     *   The element's resource selection algorithm is active and has
     *   selected a resource, but it is not actually using the network at
     *   this time.
     * - NETWORK_LOADING (numeric value 2)
     *   The user agent is actively trying to download data.
     * - NETWORK_NO_SOURCE (numeric value 3)
     *   The element's resource selection algorithm is active, but it has
     *   not yet found a resource to use.
     * @return {Number} the current network activity state
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
     */
    value: function networkState() {
      return this.techGet('networkState');
    }
  }, {
    key: 'readyState',

    /**
     * Returns a value that expresses the current state of the element
     * with respect to rendering the current playback position, from the
     * codes in the list below.
     * - HAVE_NOTHING (numeric value 0)
     *   No information regarding the media resource is available.
     * - HAVE_METADATA (numeric value 1)
     *   Enough of the resource has been obtained that the duration of the
     *   resource is available.
     * - HAVE_CURRENT_DATA (numeric value 2)
     *   Data for the immediate current playback position is available.
     * - HAVE_FUTURE_DATA (numeric value 3)
     *   Data for the immediate current playback position is available, as
     *   well as enough data for the user agent to advance the current
     *   playback position in the direction of playback.
     * - HAVE_ENOUGH_DATA (numeric value 4)
     *   The user agent estimates that enough data is available for
     *   playback to proceed uninterrupted.
     * @return {Number} the current playback rendering state
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
     */
    value: function readyState() {
      return this.techGet('readyState');
    }
  }, {
    key: 'textTracks',

    /**
     * Text tracks are tracks of timed text events.
     * Captions - text displayed over the video for the hearing impaired
     * Subtitles - text displayed over the video for those who don't understand language in the video
     * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video
     * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device
     */

    /**
     * Get an array of associated text tracks. captions, subtitles, chapters, descriptions
     * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
     * @return {Array}           Array of track objects
     */
    value: function textTracks() {
      // cannot use techGet directly because it checks to see whether the tech is ready.
      // Flash is unlikely to be ready in time but textTracks should still work.
      return this.tech && this.tech['textTracks']();
    }
  }, {
    key: 'remoteTextTracks',
    value: function remoteTextTracks() {
      return this.tech && this.tech['remoteTextTracks']();
    }
  }, {
    key: 'addTextTrack',

    /**
     * Add a text track
     * In addition to the W3C settings we allow adding additional info through options.
     * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
     * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata
     * @param {String=} label       Optional label
     * @param {String=} language    Optional language
     */
    value: function addTextTrack(kind, label, language) {
      return this.tech && this.tech['addTextTrack'](kind, label, language);
    }
  }, {
    key: 'addRemoteTextTrack',
    value: function addRemoteTextTrack(options) {
      return this.tech && this.tech['addRemoteTextTrack'](options);
    }
  }, {
    key: 'removeRemoteTextTrack',
    value: function removeRemoteTextTrack(track) {
      this.tech && this.tech['removeRemoteTextTrack'](track);
    }
  }, {
    key: 'language',

    // Methods to add support for
    // initialTime: function(){ return this.techCall('initialTime'); },
    // startOffsetTime: function(){ return this.techCall('startOffsetTime'); },
    // played: function(){ return this.techCall('played'); },
    // seekable: function(){ return this.techCall('seekable'); },
    // videoTracks: function(){ return this.techCall('videoTracks'); },
    // audioTracks: function(){ return this.techCall('audioTracks'); },
    // videoWidth: function(){ return this.techCall('videoWidth'); },
    // videoHeight: function(){ return this.techCall('videoHeight'); },
    // defaultPlaybackRate: function(){ return this.techCall('defaultPlaybackRate'); },
    // mediaGroup: function(){ return this.techCall('mediaGroup'); },
    // controller: function(){ return this.techCall('controller'); },
    // defaultMuted: function(){ return this.techCall('defaultMuted'); }

    // TODO
    // currentSrcList: the array of sources including other formats and bitrates
    // playList: array of source lists in order of playback

    /**
     * The player's language code
     * @param  {String} languageCode  The locale string
     * @return {String}             The locale string when getting
     * @return {Player}         self, when setting
     */
    value: function language(languageCode) {
      if (languageCode === undefined) {
        return this.language_;
      }

      this.language_ = languageCode;
      return this;
    }
  }, {
    key: 'languages',

    /**
     * Get the player's language dictionary
     */
    value: function languages() {
      return this.languages_;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var options = Lib.obj.deepMerge({}, this.options());
      var tracks = options.tracks;

      options.tracks = [];

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        // deep merge tracks and null out player so no circular references
        track = Lib.obj.deepMerge({}, track);
        track.player = undefined;
        options.tracks[i] = track;
      }

      return options;
    }
  }], [{
    key: 'getTagSettings',
    value: function getTagSettings(tag) {
      var baseOptions = {
        'sources': [],
        'tracks': []
      };

      var tagOptions = Lib.getElementAttributes(tag);
      var dataSetup = tagOptions['data-setup'];

      // Check if data-setup attr exists.
      if (dataSetup !== null) {
        // Parse options JSON
        // If empty string, make it a parsable json object.

        var _safeParseTuple = _safeJsonParseTuple2['default'](dataSetup || '{}');

        var _safeParseTuple2 = _slicedToArray(_safeParseTuple, 2);

        var err = _safeParseTuple2[0];
        var data = _safeParseTuple2[1];

        if (err) {
          Lib.log.error(err);
        }
        Lib.obj.merge(tagOptions, data);
      }

      Lib.obj.merge(baseOptions, tagOptions);

      // Get tag children settings
      if (tag.hasChildNodes()) {
        var children = tag.childNodes;

        for (var i = 0, j = children.length; i < j; i++) {
          var child = children[i];
          // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
          var childName = child.nodeName.toLowerCase();
          if (childName === 'source') {
            baseOptions['sources'].push(Lib.getElementAttributes(child));
          } else if (childName === 'track') {
            baseOptions['tracks'].push(Lib.getElementAttributes(child));
          }
        }
      }

      return baseOptions;
    }
  }]);

  return Player;
})(_componentJs2['default']);

/**
 * Global player list
 * @type {Object}
 */
Player.players = {};

/**
 * Player instance options, surfaced using options
 * options = Player.prototype.options_
 * Make changes in options, not here.
 * All options should use string keys so they avoid
 * renaming by closure compiler
 * @type {Object}
 * @private
 */
Player.prototype.options_ = _optionsJs2['default'];

/**
 * Fired when the player has initial duration and dimension information
 * @event loadedmetadata
 */
Player.prototype.handleLoadedMetaData;

/**
 * Fired when the player has downloaded data at the current playback position
 * @event loadeddata
 */
Player.prototype.handleLoadedData;

/**
 * Fired when the player has finished downloading the source data
 * @event loadedalldata
 */
Player.prototype.handleLoadedAllData;

/**
 * Fired when the user is active, e.g. moves the mouse over the player
 * @event useractive
 */
Player.prototype.handleUserActive;

/**
 * Fired when the user is inactive, e.g. a short delay after the last mouse move or control interaction
 * @event userinactive
 */
Player.prototype.handleUserInactive;

/**
 * Fired when the current playback position has changed
 *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 * @event timeupdate
 */
Player.prototype.handleTimeUpdate;

/**
 * Fired when the volume changes
 * @event volumechange
 */
Player.prototype.handleVolumeChange;

/**
 * Fired when an error occurs
 * @event error
 */
Player.prototype.handleError;

Player.prototype.flexNotSupported_ = function () {
  var elem = _globalDocument2['default'].createElement('i');

  return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style);
};

_componentJs2['default'].registerComponent('Player', Player);
exports['default'] = Player;
module.exports = exports['default'];

},{"./big-play-button.js":5,"./component.js":7,"./control-bar/control-bar.js":8,"./error-display.js":41,"./events.js":43,"./fullscreen-api.js":45,"./lib.js":46,"./loading-spinner.js":47,"./media-error.js":48,"./options.js":52,"./poster-image.js":55,"./tech/html5.js":61,"./tech/loader.js":62,"./tracks/text-track-display.js":65,"./tracks/text-track-settings.js":68,"global/document":1,"global/window":2,"safe-json-parse/tuple":4}],54:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _player = _dereq_('./player');

var _player2 = _interopRequireDefault(_player);

/**
 * the method for registering a video.js plugin
 *
 * @param  {String} name The name of the plugin
 * @param  {Function} init The function that is run when the player inits
 */
var plugin = function plugin(name, init) {
  _player2['default'].prototype[name] = init;
};

exports['default'] = plugin;
module.exports = exports['default'];

},{"./player":53}],55:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _button = _dereq_('./button');

var _button2 = _interopRequireDefault(_button);

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

/* Poster Image
================================================================================ */
/**
 * The component that handles showing the poster image.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var PosterImage = (function (_Button) {
  function PosterImage(player, options) {
    _classCallCheck(this, PosterImage);

    _get(Object.getPrototypeOf(PosterImage.prototype), 'constructor', this).call(this, player, options);

    this.update();
    player.on('posterchange', Lib.bind(this, this.update));
  }

  _inherits(PosterImage, _Button);

  _createClass(PosterImage, [{
    key: 'dispose',

    /**
     * Clean up the poster image
     */
    value: function dispose() {
      this.player().off('posterchange', this.update);
      _get(Object.getPrototypeOf(PosterImage.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'createEl',

    /**
     * Create the poster image element
     * @return {Element}
     */
    value: function createEl() {
      var el = Lib.createEl('div', {
        className: 'vjs-poster',

        // Don't want poster to be tabbable.
        tabIndex: -1
      });

      // To ensure the poster image resizes while maintaining its original aspect
      // ratio, use a div with `background-size` when available. For browsers that
      // do not support `background-size` (e.g. IE8), fall back on using a regular
      // img element.
      if (!Lib.BACKGROUND_SIZE_SUPPORTED) {
        this.fallbackImg_ = Lib.createEl('img');
        el.appendChild(this.fallbackImg_);
      }

      return el;
    }
  }, {
    key: 'update',

    /**
     * Event handler for updates to the player's poster source
     */
    value: function update() {
      var url = this.player().poster();

      this.setSrc(url);

      // If there's no poster source we should display:none on this component
      // so it's not still clickable or right-clickable
      if (url) {
        this.show();
      } else {
        this.hide();
      }
    }
  }, {
    key: 'setSrc',

    /**
     * Set the poster source depending on the display method
     */
    value: function setSrc(url) {
      if (this.fallbackImg_) {
        this.fallbackImg_.src = url;
      } else {
        var backgroundImage = '';
        // Any falsey values should stay as an empty string, otherwise
        // this will throw an extra error
        if (url) {
          backgroundImage = 'url("' + url + '")';
        }

        this.el_.style.backgroundImage = backgroundImage;
      }
    }
  }, {
    key: 'handleClick',

    /**
     * Event handler for clicks on the poster image
     */
    value: function handleClick() {
      // We don't want a click to trigger playback when controls are disabled
      // but CSS should be hiding the poster to prevent that from happening
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    }
  }]);

  return PosterImage;
})(_button2['default']);

_button2['default'].registerComponent('PosterImage', PosterImage);
exports['default'] = PosterImage;
module.exports = exports['default'];

},{"./button":6,"./lib":46}],56:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _events = _dereq_('./events');

var Events = _interopRequireWildcard(_events);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _windowLoaded = false;
var videojs = undefined;

/**
 * @fileoverview Functions for automatically setting up a player
 * based on the data-setup attribute of the video tag
 */

// Automatically set up any tags that have a data-setup attribute
var autoSetup = function autoSetup() {
  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
  // var mediaEls = vids.concat(audios);

  // Because IE8 doesn't support calling slice on a node list, we need to loop through each list of elements
  // to build up a new, combined list of elements.
  var vids = _globalDocument2['default'].getElementsByTagName('video');
  var audios = _globalDocument2['default'].getElementsByTagName('audio');
  var mediaEls = [];
  if (vids && vids.length > 0) {
    for (var i = 0, e = vids.length; i < e; i++) {
      mediaEls.push(vids[i]);
    }
  }
  if (audios && audios.length > 0) {
    for (var i = 0, e = audios.length; i < e; i++) {
      mediaEls.push(audios[i]);
    }
  }

  // Check if any media elements exist
  if (mediaEls && mediaEls.length > 0) {

    for (var i = 0, e = mediaEls.length; i < e; i++) {
      var mediaEl = mediaEls[i];

      // Check if element exists, has getAttribute func.
      // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.
      if (mediaEl && mediaEl.getAttribute) {

        // Make sure this player hasn't already been set up.
        if (mediaEl['player'] === undefined) {
          var options = mediaEl.getAttribute('data-setup');

          // Check if data-setup attr exists.
          // We only auto-setup if they've added the data-setup attr.
          if (options !== null) {
            // Create new video.js instance.
            var player = videojs(mediaEl);
          }
        }

        // If getAttribute isn't defined, we need to wait for the DOM.
      } else {
        autoSetupTimeout(1);
        break;
      }
    }

    // No videos were found, so keep looping unless page is finished loading.
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};

// Pause to let the DOM keep processing
var autoSetupTimeout = function autoSetupTimeout(wait, vjs) {
  videojs = vjs;
  setTimeout(autoSetup, wait);
};

if (_globalDocument2['default'].readyState === 'complete') {
  _windowLoaded = true;
} else {
  Events.one(_globalWindow2['default'], 'load', function () {
    _windowLoaded = true;
  });
}

var hasLoaded = function hasLoaded() {
  return _windowLoaded;
};

exports.autoSetup = autoSetup;
exports.autoSetupTimeout = autoSetupTimeout;
exports.hasLoaded = hasLoaded;

},{"./events":43,"global/document":1,"global/window":2}],57:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _libJs = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_libJs);

/**
 * SeekBar Behavior includes play progress bar, and seek handle
 * Needed so it can determine seek position based on handle position/size
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var SliderHandle = (function (_Component) {
  function SliderHandle() {
    _classCallCheck(this, SliderHandle);

    if (_Component != null) {
      _Component.apply(this, arguments);
    }
  }

  _inherits(SliderHandle, _Component);

  _createClass(SliderHandle, [{
    key: 'createEl',

    /** @inheritDoc */
    value: function createEl(type, props) {
      props = props || {};
      // Add the slider element class to all sub classes
      props.className = props.className + ' vjs-slider-handle';
      props = Lib.obj.merge({
        innerHTML: '<span class="vjs-control-text">' + (this.defaultValue || 0) + '</span>'
      }, props);

      return _get(Object.getPrototypeOf(SliderHandle.prototype), 'createEl', this).call(this, 'div', props);
    }
  }]);

  return SliderHandle;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('SliderHandle', SliderHandle);
exports['default'] = SliderHandle;
module.exports = exports['default'];

},{"../component.js":7,"../lib.js":46}],58:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x2,
    property = _x3,
    receiver = _x4; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _libJs = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_libJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/* Slider
================================================================================ */
/**
 * The base functionality for sliders like the volume bar and seek bar
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @constructor
 */

var Slider = (function (_Component) {
  function Slider(player, options) {
    _classCallCheck(this, Slider);

    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, player, options);

    // Set property names to bar and handle to match with the child Slider class is looking for
    this.bar = this.getChild(this.options_['barName']);
    this.handle = this.getChild(this.options_['handleName']);

    // Set a horizontal or vertical class on the slider depending on the slider type
    this.vertical(!!this.options()['vertical']);

    this.on('mousedown', this.handleMouseDown);
    this.on('touchstart', this.handleMouseDown);
    this.on('focus', this.handleFocus);
    this.on('blur', this.handleBlur);
    this.on('click', this.handleClick);

    this.on(player, 'controlsvisible', this.update);
    this.on(player, this.playerEvent, this.update);
  }

  _inherits(Slider, _Component);

  _createClass(Slider, [{
    key: 'createEl',
    value: function createEl(type) {
      var props = arguments[1] === undefined ? {} : arguments[1];

      // Add the slider element class to all sub classes
      props.className = props.className + ' vjs-slider';
      props = Lib.obj.merge({
        'role': 'slider',
        'aria-valuenow': 0,
        'aria-valuemin': 0,
        'aria-valuemax': 100,
        tabIndex: 0
      }, props);

      return _get(Object.getPrototypeOf(Slider.prototype), 'createEl', this).call(this, type, props);
    }
  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      event.preventDefault();
      Lib.blockTextSelection();
      this.addClass('vjs-sliding');

      this.on(_globalDocument2['default'], 'mousemove', this.handleMouseMove);
      this.on(_globalDocument2['default'], 'mouseup', this.handleMouseUp);
      this.on(_globalDocument2['default'], 'touchmove', this.handleMouseMove);
      this.on(_globalDocument2['default'], 'touchend', this.handleMouseUp);

      this.handleMouseMove(event);
    }
  }, {
    key: 'handleMouseMove',

    // To be overridden by a subclass
    value: function handleMouseMove() {}
  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp() {
      Lib.unblockTextSelection();
      this.removeClass('vjs-sliding');

      this.off(_globalDocument2['default'], 'mousemove', this.handleMouseMove);
      this.off(_globalDocument2['default'], 'mouseup', this.handleMouseUp);
      this.off(_globalDocument2['default'], 'touchmove', this.handleMouseMove);
      this.off(_globalDocument2['default'], 'touchend', this.handleMouseUp);

      this.update();
    }
  }, {
    key: 'update',
    value: function update() {
      // In VolumeBar init we have a setTimeout for update that pops and update to the end of the
      // execution stack. The player is destroyed before then update will cause an error
      if (!this.el_) return;

      // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.
      // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.
      // var progress =  (this.player_.scrubbing) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();
      var progress = this.getPercent();
      var bar = this.bar;

      // If there's no bar...
      if (!bar) return;

      // Protect against no duration and other division issues
      if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
        progress = 0;
      }

      // If there is a handle, we need to account for the handle in our calculation for progress bar
      // so that it doesn't fall short of or extend past the handle.
      var barProgress = this.updateHandlePosition(progress);

      // Convert to a percentage for setting
      var percentage = Lib.round(barProgress * 100, 2) + '%';

      // Set the new bar width or height
      if (this.vertical()) {
        bar.el().style.height = percentage;
      } else {
        bar.el().style.width = percentage;
      }
    }
  }, {
    key: 'updateHandlePosition',

    /**
    * Update the handle position.
    */
    value: function updateHandlePosition(progress) {
      var handle = this.handle;
      if (!handle) return;

      var vertical = this.vertical();
      var box = this.el_;

      var boxSize = undefined,
          handleSize = undefined;
      if (vertical) {
        boxSize = box.offsetHeight;
        handleSize = handle.el().offsetHeight;
      } else {
        boxSize = box.offsetWidth;
        handleSize = handle.el().offsetWidth;
      }

      // The width of the handle in percent of the containing box
      // In IE, widths may not be ready yet causing NaN
      var handlePercent = handleSize ? handleSize / boxSize : 0;

      // Get the adjusted size of the box, considering that the handle's center never touches the left or right side.
      // There is a margin of half the handle's width on both sides.
      var boxAdjustedPercent = 1 - handlePercent;

      // Adjust the progress that we'll use to set widths to the new adjusted box width
      var adjustedProgress = progress * boxAdjustedPercent;

      // The bar does reach the left side, so we need to account for this in the bar's width
      var barProgress = adjustedProgress + handlePercent / 2;

      var percentage = Lib.round(adjustedProgress * 100, 2) + '%';

      if (vertical) {
        handle.el().style.bottom = percentage;
      } else {
        handle.el().style.left = percentage;
      }

      return barProgress;
    }
  }, {
    key: 'calculateDistance',
    value: function calculateDistance(event) {
      var el = this.el_;
      var box = Lib.findPosition(el);
      var boxW = el.offsetWidth;
      var boxH = el.offsetHeight;
      var handle = this.handle;

      if (this.options()['vertical']) {
        var boxY = box.top;

        var pageY = undefined;
        if (event.changedTouches) {
          pageY = event.changedTouches[0].pageY;
        } else {
          pageY = event.pageY;
        }

        if (handle) {
          var handleH = handle.el().offsetHeight;
          // Adjusted X and Width, so handle doesn't go outside the bar
          boxY = boxY + handleH / 2;
          boxH = boxH - handleH;
        }

        // Percent that the click is through the adjusted area
        return Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
      } else {
        var boxX = box.left;

        var pageX = undefined;
        if (event.changedTouches) {
          pageX = event.changedTouches[0].pageX;
        } else {
          pageX = event.pageX;
        }

        if (handle) {
          var handleW = handle.el().offsetWidth;

          // Adjusted X and Width, so handle doesn't go outside the bar
          boxX = boxX + handleW / 2;
          boxW = boxW - handleW;
        }

        // Percent that the click is through the adjusted area
        return Math.max(0, Math.min(1, (pageX - boxX) / boxW));
      }
    }
  }, {
    key: 'handleFocus',
    value: function handleFocus() {
      this.on(_globalDocument2['default'], 'keydown', this.handleKeyPress);
    }
  }, {
    key: 'handleKeyPress',
    value: function handleKeyPress(event) {
      if (event.which === 37 || event.which === 40) {
        // Left and Down Arrows
        event.preventDefault();
        this.stepBack();
      } else if (event.which === 38 || event.which === 39) {
        // Up and Right Arrows
        event.preventDefault();
        this.stepForward();
      }
    }
  }, {
    key: 'handleBlur',
    value: function handleBlur() {
      this.off(_globalDocument2['default'], 'keydown', this.handleKeyPress);
    }
  }, {
    key: 'handleClick',

    /**
     * Listener for click events on slider, used to prevent clicks
     *   from bubbling up to parent elements like button menus.
     * @param  {Object} event Event object
     */
    value: function handleClick(event) {
      event.stopImmediatePropagation();
      event.preventDefault();
    }
  }, {
    key: 'vertical',
    value: function vertical(bool) {
      if (bool === undefined) {
        return this.vertical_ || false;
      }

      this.vertical_ = !!bool;

      if (this.vertical_) {
        this.addClass('vjs-slider-vertical');
      } else {
        this.addClass('vjs-slider-horizontal');
      }

      return this;
    }
  }]);

  return Slider;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('Slider', Slider);
exports['default'] = Slider;
module.exports = exports['default'];

},{"../component.js":7,"../lib.js":46,"global/document":1}],59:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function FlashRtmpDecorator(Flash) {
  Flash.streamingFormats = {
    'rtmp/mp4': 'MP4',
    'rtmp/flv': 'FLV'
  };

  Flash.streamFromParts = function (connection, stream) {
    return connection + '&' + stream;
  };

  Flash.streamToParts = function (src) {
    var parts = {
      connection: '',
      stream: ''
    };

    if (!src) return parts;

    // Look for the normal URL separator we expect, '&'.
    // If found, we split the URL into two pieces around the
    // first '&'.
    var connEnd = src.indexOf('&');
    var streamBegin = undefined;
    if (connEnd !== -1) {
      streamBegin = connEnd + 1;
    } else {
      // If there's not a '&', we use the last '/' as the delimiter.
      connEnd = streamBegin = src.lastIndexOf('/') + 1;
      if (connEnd === 0) {
        // really, there's not a '/'?
        connEnd = streamBegin = src.length;
      }
    }
    parts.connection = src.substring(0, connEnd);
    parts.stream = src.substring(streamBegin, src.length);

    return parts;
  };

  Flash.isStreamingType = function (srcType) {
    return srcType in Flash.streamingFormats;
  };

  // RTMP has four variations, any string starting
  // with one of these protocols should be valid
  Flash.RTMP_RE = /^rtmp[set]?:\/\//i;

  Flash.isStreamingSrc = function (src) {
    return Flash.RTMP_RE.test(src);
  };

  /**
   * A source handler for RTMP urls
   * @type {Object}
   */
  Flash.rtmpSourceHandler = {};

  /**
   * Check Flash can handle the source natively
   * @param  {Object} source  The source object
   * @return {String}         'probably', 'maybe', or '' (empty string)
   */
  Flash.rtmpSourceHandler.canHandleSource = function (source) {
    if (Flash.isStreamingType(source.type) || Flash.isStreamingSrc(source.src)) {
      return 'maybe';
    }

    return '';
  };

  /**
   * Pass the source to the flash object
   * Adaptive source handlers will have more complicated workflows before passing
   * video data to the video element
   * @param  {Object} source    The source object
   * @param  {Flash} tech   The instance of the Flash tech
   */
  Flash.rtmpSourceHandler.handleSource = function (source, tech) {
    var srcParts = Flash.streamToParts(source.src);

    tech['setRtmpConnection'](srcParts.connection);
    tech['setRtmpStream'](srcParts.stream);
  };

  // Register the native source handler
  Flash.registerSourceHandler(Flash.rtmpSourceHandler);

  return Flash;
}

exports['default'] = FlashRtmpDecorator;
module.exports = exports['default'];

},{}],60:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

/**
 * @fileoverview VideoJS-SWF - Custom Flash Player with HTML5-ish API
 * https://github.com/zencoder/video-js-swf
 * Not using setupTriggers. Using global onEvent func to distribute events
 */

var _tech = _dereq_('./tech');

var _tech2 = _interopRequireDefault(_tech);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

var _flashRtmp = _dereq_('./flash-rtmp');

var _flashRtmp2 = _interopRequireDefault(_flashRtmp);

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var navigator = _globalWindow2['default'].navigator;
/**
 * Flash Media Controller - Wrapper for fallback SWF API
 *
 * @param {Player} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */

var Flash = (function (_Tech) {
  function Flash(options, ready) {
    _classCallCheck(this, Flash);

    _get(Object.getPrototypeOf(Flash.prototype), 'constructor', this).call(this, options, ready);

    var source = options.source;
    var parentEl = options.parentEl;

    // Generate ID for swf object
    var objId = options.playerId + '_flash_api';

    // Merge default flashvars with ones passed in to init
    var flashVars = Lib.obj.merge({

      // SWF Callback Functions
      'readyFunction': 'videojs.Flash.onReady',
      'eventProxyFunction': 'videojs.Flash.onEvent',
      'errorEventProxyFunction': 'videojs.Flash.onError',

      // Player Settings
      'autoplay': options.autoplay,
      'preload': options.preload,
      'loop': options.loop,
      'muted': options.muted

    }, options.flashVars);

    // Merge default parames with ones passed in
    var params = Lib.obj.merge({
      'wmode': 'opaque', // Opaque is needed to overlay controls, but can affect playback performance
      'bgcolor': '#000000' // Using bgcolor prevents a white flash when the object is loading
    }, options.params);

    // Merge default attributes with ones passed in
    var attributes = Lib.obj.merge({
      'id': objId,
      'name': objId, // Both ID and Name needed or swf to identify itself
      'class': 'vjs-tech'
    }, options.attributes);

    // If source was supplied pass as a flash var.
    if (source) {
      this.ready(function () {
        this.setSource(source);
      });
    }

    // Having issues with Flash reloading on certain page actions (hide/resize/fullscreen) in certain browsers
    // This allows resetting the playhead when we catch the reload
    if (options.startTime) {
      this.ready(function () {
        this.load();
        this.play();
        this.currentTime(options.startTime);
      });
    }

    _globalWindow2['default'].videojs = _globalWindow2['default'].videojs || {};
    _globalWindow2['default'].videojs.Flash = _globalWindow2['default'].videojs.Flash || {};
    _globalWindow2['default'].videojs.Flash.onReady = Flash.onReady;
    _globalWindow2['default'].videojs.Flash.onEvent = Flash.onEvent;
    _globalWindow2['default'].videojs.Flash.onError = Flash.onError;

    this.el_ = Flash.embed(options.swf, flashVars, params, attributes);
    this.el_.tech = this;
  }

  _inherits(Flash, _Tech);

  _createClass(Flash, [{
    key: 'play',
    value: function play() {
      this.el_.vjs_play();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.el_.vjs_pause();
    }
  }, {
    key: 'src',
    value: function src(_src) {
      if (_src === undefined) {
        return this.currentSrc();
      }

      // Setting src through `src` not `setSrc` will be deprecated
      return this.setSrc(_src);
    }
  }, {
    key: 'setSrc',
    value: function setSrc(src) {
      // Make sure source URL is absolute.
      src = Lib.getAbsoluteURL(src);
      this.el_.vjs_src(src);

      // Currently the SWF doesn't autoplay if you load a source later.
      // e.g. Load player w/ no source, wait 2s, set src.
      if (this.autoplay()) {
        var tech = this;
        this.setTimeout(function () {
          tech.play();
        }, 0);
      }
    }
  }, {
    key: 'setCurrentTime',
    value: function setCurrentTime(time) {
      this.lastSeekTarget_ = time;
      this.el_.vjs_setProperty('currentTime', time);
      _get(Object.getPrototypeOf(Flash.prototype), 'setCurrentTime', this).call(this);
    }
  }, {
    key: 'currentTime',
    value: function currentTime(time) {
      // when seeking make the reported time keep up with the requested time
      // by reading the time we're seeking to
      if (this.seeking()) {
        return this.lastSeekTarget_ || 0;
      }
      return this.el_.vjs_getProperty('currentTime');
    }
  }, {
    key: 'currentSrc',
    value: function currentSrc() {
      if (this.currentSource_) {
        return this.currentSource_.src;
      } else {
        return this.el_.vjs_getProperty('currentSrc');
      }
    }
  }, {
    key: 'load',
    value: function load() {
      this.el_.vjs_load();
    }
  }, {
    key: 'poster',
    value: function poster() {
      this.el_.vjs_getProperty('poster');
    }
  }, {
    key: 'setPoster',

    // poster images are not handled by the Flash tech so make this a no-op
    value: function setPoster() {}
  }, {
    key: 'buffered',
    value: function buffered() {
      return Lib.createTimeRange(0, this.el_.vjs_getProperty('buffered'));
    }
  }, {
    key: 'supportsFullScreen',
    value: function supportsFullScreen() {
      return false; // Flash does not allow fullscreen through javascript
    }
  }, {
    key: 'enterFullScreen',
    value: function enterFullScreen() {
      return false;
    }
  }]);

  return Flash;
})(_tech2['default']);

// Create setters and getters for attributes
var _api = Flash.prototype;
var _readWrite = 'rtmpConnection,rtmpStream,preload,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(',');
var _readOnly = 'error,networkState,readyState,seeking,initialTime,duration,startOffsetTime,paused,played,seekable,ended,videoTracks,audioTracks,videoWidth,videoHeight'.split(',');

function _createSetter(attr) {
  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);
  _api['set' + attrUpper] = function (val) {
    return this.el_.vjs_setProperty(attr, val);
  };
}
function _createGetter(attr) {
  _api[attr] = function () {
    return this.el_.vjs_getProperty(attr);
  };
}

// Create getter and setters for all read/write attributes
for (var i = 0; i < _readWrite.length; i++) {
  _createGetter(_readWrite[i]);
  _createSetter(_readWrite[i]);
}

// Create getters for read-only attributes
for (var i = 0; i < _readOnly.length; i++) {
  _createGetter(_readOnly[i]);
}

/* Flash Support Testing -------------------------------------------------------- */

Flash.isSupported = function () {
  return Flash.version()[0] >= 10;
  // return swfobject.hasFlashPlayerVersion('10');
};

// Add Source Handler pattern functions to this tech
_tech2['default'].withSourceHandlers(Flash);

/**
 * The default native source handler.
 * This simply passes the source to the video element. Nothing fancy.
 * @param  {Object} source   The source object
 * @param  {Flash} tech  The instance of the Flash tech
 */
Flash.nativeSourceHandler = {};

/**
 * Check Flash can handle the source natively
 * @param  {Object} source  The source object
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Flash.nativeSourceHandler.canHandleSource = function (source) {
  var type;

  function guessMimeType(src) {
    var ext = Lib.getFileExtension(src);
    if (ext) {
      return 'video/' + ext;
    }
    return '';
  }

  if (!source.type) {
    type = guessMimeType(source.src);
  } else {
    // Strip code information from the type because we don't get that specific
    type = source.type.replace(/;.*/, '').toLowerCase();
  }

  if (type in Flash.formats) {
    return 'maybe';
  }

  return '';
};

/**
 * Pass the source to the flash object
 * Adaptive source handlers will have more complicated workflows before passing
 * video data to the video element
 * @param  {Object} source    The source object
 * @param  {Flash} tech   The instance of the Flash tech
 */
Flash.nativeSourceHandler.handleSource = function (source, tech) {
  tech.setSrc(source.src);
};

/**
 * Clean up the source handler when disposing the player or switching sources..
 * (no cleanup is needed when supporting the format natively)
 */
Flash.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Flash.registerSourceHandler(Flash.nativeSourceHandler);

Flash.formats = {
  'video/flv': 'FLV',
  'video/x-flv': 'FLV',
  'video/mp4': 'MP4',
  'video/m4v': 'MP4'
};

Flash.onReady = function (currSwf) {
  var el = Lib.el(currSwf);
  var tech = el && el.tech;

  // if there is no el then the tech has been disposed
  // and the tech element was removed from the player div
  if (tech && tech.el()) {
    // check that the flash object is really ready
    Flash.checkReady(tech);
  }
};

// The SWF isn't always ready when it says it is. Sometimes the API functions still need to be added to the object.
// If it's not ready, we set a timeout to check again shortly.
Flash.checkReady = function (tech) {
  // stop worrying if the tech has been disposed
  if (!tech.el()) {
    return;
  }

  // check if API property exists
  if (tech.el().vjs_getProperty) {
    // tell tech it's ready
    tech.triggerReady();
  } else {
    // wait longer
    this.setTimeout(function () {
      Flash['checkReady'](tech);
    }, 50);
  }
};

// Trigger events from the swf on the player
Flash.onEvent = function (swfID, eventName) {
  var tech = Lib.el(swfID).tech;

  // Special case for our metadataupdate event which is surfaced from our
  // version of the Video JS SWF.  We need to surface the arguments from the
  // Flash event to listeners on the client side.

  if (eventName === 'metadataupdate') {
    var mesg = '';

    if (arguments && arguments.length > 2 && arguments[2].length) {
      mesg = arguments[2][0];
    }

    tech.trigger({ type: eventName, data: mesg });
  } else {
    tech.trigger(eventName);
  }
};

// Log errors from the swf
Flash.onError = function (swfID, err) {
  var tech = Lib.el(swfID).tech;
  var msg = 'FLASH: ' + err;

  if (err === 'srcnotfound') {
    tech.trigger('error', { code: 4, message: msg });

    // errors we haven't categorized into the media errors
  } else {
    tech.trigger('error', msg);
  }
};

// Flash Version Check
Flash.version = function () {
  var version = '0,0,0';

  // IE
  try {
    version = new _globalWindow2['default'].ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];

    // other browsers
  } catch (e) {
    try {
      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      }
    } catch (err) {}
  }
  return version.split(',');
};

// Flash embedding method. Only used in non-iframe mode
Flash.embed = function (swf, flashVars, params, attributes) {
  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);

  // Get element by embedding code and retrieving created element
  var obj = Lib.createEl('div', { innerHTML: code }).childNodes[0];

  return obj;
};

Flash.getEmbedCode = function (swf, flashVars, params, attributes) {
  var objTag = '<object type="application/x-shockwave-flash" ';
  var flashVarsString = '';
  var paramsString = '';
  var attrsString = '';

  // Convert flash vars to string
  if (flashVars) {
    Lib.obj.each(flashVars, function (key, val) {
      flashVarsString += '' + key + '=' + val + '&amp;';
    });
  }

  // Add swf, flashVars, and other default params
  params = Lib.obj.merge({
    'movie': swf,
    'flashvars': flashVarsString,
    'allowScriptAccess': 'always', // Required to talk to swf
    'allowNetworking': 'all' // All should be default, but having security issues.
  }, params);

  // Create param tags string
  Lib.obj.each(params, function (key, val) {
    paramsString += '<param name="' + key + '" value="' + val + '" />';
  });

  attributes = Lib.obj.merge({
    // Add swf to attributes (need both for IE and Others to work)
    'data': swf,

    // Default to 100% width/height
    'width': '100%',
    'height': '100%'

  }, attributes);

  // Create Attributes string
  Lib.obj.each(attributes, function (key, val) {
    attrsString += '' + key + '="' + val + '" ';
  });

  return '' + objTag + '' + attrsString + '>' + paramsString + '</object>';
};

// Run Flash through the RTMP decorator
_flashRtmp2['default'](Flash);

_tech2['default'].registerComponent('Flash', Flash);
exports['default'] = Flash;
module.exports = exports['default'];

},{"../component":7,"../lib":46,"./flash-rtmp":59,"./tech":63,"global/window":2}],61:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x2,
    property = _x3,
    receiver = _x4; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

/**
 * @fileoverview HTML5 Media Controller - Wrapper for HTML5 Media API
 */

var _techJs = _dereq_('./tech.js');

var _techJs2 = _interopRequireDefault(_techJs);

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

var _util = _dereq_('../util');

var VjsUtil = _interopRequireWildcard(_util);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 * @param {Player|Object} player
 * @param {Object=} options
 * @param {Function=} ready
 * @constructor
 */

var Html5 = (function (_Tech) {
  function Html5(options, ready) {
    _classCallCheck(this, Html5);

    _get(Object.getPrototypeOf(Html5.prototype), 'constructor', this).call(this, options, ready);

    var source = options.source;

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      this.setSource(source);
    }

    if (this.el_.hasChildNodes()) {

      var nodes = this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];

      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === 'track') {
          if (!this.featuresNativeTextTracks) {
            // Empty video tag tracks so the built-in player doesn't use them also.
            // This may not be fast enough to stop HTML5 browsers from reading the tags
            // so we'll need to turn off any default tracks if we're manually doing
            // captions and subtitles. videoElement.textTracks
            removeNodes.push(node);
          } else {
            this.remoteTextTracks().addTrack_(node.track);
          }
        }
      }

      for (var i = 0; i < removeNodes.length; i++) {
        this.el_.removeChild(removeNodes[i]);
      }
    }

    if (this.featuresNativeTextTracks) {
      this.on('loadstart', Lib.bind(this, this.hideCaptions));
    }

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if (Lib.TOUCH_ENABLED && options.nativeControlsForTouch === true) {
      this.trigger('usenativecontrols');
    }

    this.triggerReady();
  }

  _inherits(Html5, _Tech);

  _createClass(Html5, [{
    key: 'dispose',
    value: function dispose() {
      Html5.disposeMediaElement(this.el_);
      _get(Object.getPrototypeOf(Html5.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      var el = this.options_.tag;

      // Check if this browser supports moving the element into the box.
      // On the iPhone video will break if you move the element,
      // So we have to create a brand new element.
      if (!el || this['movingMediaElementInDOM'] === false) {

        // If the original tag is still there, clone and remove it.
        if (el) {
          var clone = el.cloneNode(false);
          Html5.disposeMediaElement(el);
          el = clone;
        } else {
          el = Lib.createEl('video');

          // determine if native controls should be used
          var tagAttributes = this.options_.tag && Lib.getElementAttributes(this.options_.tag);
          var attributes = VjsUtil.mergeOptions({}, tagAttributes);
          if (!Lib.TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
            delete attributes.controls;
          }

          Lib.setElementAttributes(el, Lib.obj.merge(attributes, {
            id: this.options_.playerId + '_html5_api',
            'class': 'vjs-tech'
          }));
        }

        if (this.options_.tracks) {
          for (var i = 0; i < this.options_.tracks.length; i++) {
            var track = this.options_.tracks[i];
            var trackEl = _globalDocument2['default'].createElement('track');
            trackEl.kind = track.kind;
            trackEl.label = track.label;
            trackEl.srclang = track.srclang;
            trackEl.src = track.src;
            if ('default' in track) {
              trackEl.setAttribute('default', 'default');
            }
            el.appendChild(trackEl);
          }
        }
      }

      // Update specific tag settings, in case they were overridden
      var settingsAttrs = ['autoplay', 'preload', 'loop', 'muted'];
      for (var i = settingsAttrs.length - 1; i >= 0; i--) {
        var attr = settingsAttrs[i];
        var overwriteAttrs = {};
        if (typeof this.options_[attr] !== 'undefined') {
          overwriteAttrs[attr] = this.options_[attr];
        }
        Lib.setElementAttributes(el, overwriteAttrs);
      }

      return el;
      // jenniisawesome = true;
    }
  }, {
    key: 'hideCaptions',
    value: function hideCaptions() {
      var tracks = this.el_.querySelectorAll('track');
      var i = tracks.length;
      var kinds = {
        'captions': 1,
        'subtitles': 1
      };

      while (i--) {
        var track = tracks[i].track;
        if (track && track['kind'] in kinds && !tracks[i]['default']) {
          track.mode = 'disabled';
        }
      }
    }
  }, {
    key: 'play',
    value: function play() {
      this.el_.play();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.el_.pause();
    }
  }, {
    key: 'paused',
    value: function paused() {
      return this.el_.paused;
    }
  }, {
    key: 'currentTime',
    value: function currentTime() {
      return this.el_.currentTime;
    }
  }, {
    key: 'setCurrentTime',
    value: function setCurrentTime(seconds) {
      try {
        this.el_.currentTime = seconds;
      } catch (e) {
        Lib.log(e, 'Video is not ready. (Video.js)');
        // this.warning(VideoJS.warnings.videoNotReady);
      }
    }
  }, {
    key: 'duration',
    value: function duration() {
      return this.el_.duration || 0;
    }
  }, {
    key: 'buffered',
    value: function buffered() {
      return this.el_.buffered;
    }
  }, {
    key: 'volume',
    value: function volume() {
      return this.el_.volume;
    }
  }, {
    key: 'setVolume',
    value: function setVolume(percentAsDecimal) {
      this.el_.volume = percentAsDecimal;
    }
  }, {
    key: 'muted',
    value: function muted() {
      return this.el_.muted;
    }
  }, {
    key: 'setMuted',
    value: function setMuted(muted) {
      this.el_.muted = muted;
    }
  }, {
    key: 'width',
    value: function width() {
      return this.el_.offsetWidth;
    }
  }, {
    key: 'height',
    value: function height() {
      return this.el_.offsetHeight;
    }
  }, {
    key: 'supportsFullScreen',
    value: function supportsFullScreen() {
      if (typeof this.el_.webkitEnterFullScreen === 'function') {

        // Seems to be broken in Chromium/Chrome && Safari in Leopard
        if (/Android/.test(Lib.USER_AGENT) || !/Chrome|Mac OS X 10.5/.test(Lib.USER_AGENT)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'enterFullScreen',
    value: function enterFullScreen() {
      var video = this.el_;

      if ('webkitDisplayingFullscreen' in video) {
        this.one('webkitbeginfullscreen', function () {
          this.one('webkitendfullscreen', function () {
            this.trigger('fullscreenchange');
          });

          this.trigger('fullscreenchange');
        });
      }

      if (video.paused && video.networkState <= video.HAVE_METADATA) {
        // attempt to prime the video element for programmatic access
        // this isn't necessary on the desktop but shouldn't hurt
        this.el_.play();

        // playing and pausing synchronously during the transition to fullscreen
        // can get iOS ~6.1 devices into a play/pause loop
        this.setTimeout(function () {
          video.pause();
          video.webkitEnterFullScreen();
        }, 0);
      } else {
        video.webkitEnterFullScreen();
      }
    }
  }, {
    key: 'exitFullScreen',
    value: function exitFullScreen() {
      this.el_.webkitExitFullScreen();
    }
  }, {
    key: 'src',
    value: function src(_src) {
      if (_src === undefined) {
        return this.el_.src;
      } else {
        // Setting src through `src` instead of `setSrc` will be deprecated
        this.setSrc(_src);
      }
    }
  }, {
    key: 'setSrc',
    value: function setSrc(src) {
      this.el_.src = src;
    }
  }, {
    key: 'load',
    value: function load() {
      this.el_.load();
    }
  }, {
    key: 'currentSrc',
    value: function currentSrc() {
      return this.el_.currentSrc;
    }
  }, {
    key: 'poster',
    value: function poster() {
      return this.el_.poster;
    }
  }, {
    key: 'setPoster',
    value: function setPoster(val) {
      this.el_.poster = val;
    }
  }, {
    key: 'preload',
    value: function preload() {
      return this.el_.preload;
    }
  }, {
    key: 'setPreload',
    value: function setPreload(val) {
      this.el_.preload = val;
    }
  }, {
    key: 'autoplay',
    value: function autoplay() {
      return this.el_.autoplay;
    }
  }, {
    key: 'setAutoplay',
    value: function setAutoplay(val) {
      this.el_.autoplay = val;
    }
  }, {
    key: 'controls',
    value: function controls() {
      return this.el_.controls;
    }
  }, {
    key: 'setControls',
    value: function setControls(val) {
      this.el_.controls = !!val;
    }
  }, {
    key: 'loop',
    value: function loop() {
      return this.el_.loop;
    }
  }, {
    key: 'setLoop',
    value: function setLoop(val) {
      this.el_.loop = val;
    }
  }, {
    key: 'error',
    value: function error() {
      return this.el_.error;
    }
  }, {
    key: 'seeking',
    value: function seeking() {
      return this.el_.seeking;
    }
  }, {
    key: 'ended',
    value: function ended() {
      return this.el_.ended;
    }
  }, {
    key: 'defaultMuted',
    value: function defaultMuted() {
      return this.el_.defaultMuted;
    }
  }, {
    key: 'playbackRate',
    value: function playbackRate() {
      return this.el_.playbackRate;
    }
  }, {
    key: 'setPlaybackRate',
    value: function setPlaybackRate(val) {
      this.el_.playbackRate = val;
    }
  }, {
    key: 'networkState',
    value: function networkState() {
      return this.el_.networkState;
    }
  }, {
    key: 'readyState',
    value: function readyState() {
      return this.el_.readyState;
    }
  }, {
    key: 'textTracks',
    value: function textTracks() {
      if (!this['featuresNativeTextTracks']) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'textTracks', this).call(this);
      }

      return this.el_.textTracks;
    }
  }, {
    key: 'addTextTrack',
    value: function addTextTrack(kind, label, language) {
      if (!this['featuresNativeTextTracks']) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'addTextTrack', this).call(this, kind, label, language);
      }

      return this.el_.addTextTrack(kind, label, language);
    }
  }, {
    key: 'addRemoteTextTrack',
    value: function addRemoteTextTrack() {
      var options = arguments[0] === undefined ? {} : arguments[0];

      if (!this['featuresNativeTextTracks']) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'addRemoteTextTrack', this).call(this, options);
      }

      var track = _globalDocument2['default'].createElement('track');

      if (options['kind']) {
        track['kind'] = options['kind'];
      }
      if (options['label']) {
        track['label'] = options['label'];
      }
      if (options['language'] || options['srclang']) {
        track['srclang'] = options['language'] || options['srclang'];
      }
      if (options['default']) {
        track['default'] = options['default'];
      }
      if (options['id']) {
        track['id'] = options['id'];
      }
      if (options['src']) {
        track['src'] = options['src'];
      }

      this.el().appendChild(track);

      if (track.track['kind'] === 'metadata') {
        track['track']['mode'] = 'hidden';
      } else {
        track['track']['mode'] = 'disabled';
      }

      track['onload'] = function () {
        var tt = track['track'];
        if (track.readyState >= 2) {
          if (tt['kind'] === 'metadata' && tt['mode'] !== 'hidden') {
            tt['mode'] = 'hidden';
          } else if (tt['kind'] !== 'metadata' && tt['mode'] !== 'disabled') {
            tt['mode'] = 'disabled';
          }
          track['onload'] = null;
        }
      };

      this.remoteTextTracks().addTrack_(track.track);

      return track;
    }
  }, {
    key: 'removeRemoteTextTrack',
    value: function removeRemoteTextTrack(track) {
      if (!this['featuresNativeTextTracks']) {
        return _get(Object.getPrototypeOf(Html5.prototype), 'removeRemoteTextTrack', this).call(this, track);
      }

      var tracks, i;

      this.remoteTextTracks().removeTrack_(track);

      tracks = this.el()['querySelectorAll']('track');

      for (i = 0; i < tracks.length; i++) {
        if (tracks[i] === track || tracks[i]['track'] === track) {
          tracks[i]['parentNode']['removeChild'](tracks[i]);
          break;
        }
      }
    }
  }]);

  return Html5;
})(_techJs2['default']);

/* HTML5 Support Testing ---------------------------------------------------- */

/**
 * Check if HTML5 video is supported by this browser/device
 * @return {Boolean}
 */
Html5.isSupported = function () {
  // IE9 with no Media Player is a LIAR! (#984)
  try {
    Lib.TEST_VID['volume'] = 0.5;
  } catch (e) {
    return false;
  }

  return !!Lib.TEST_VID.canPlayType;
};

// Add Source Handler pattern functions to this tech
_techJs2['default'].withSourceHandlers(Html5);

/**
 * The default native source handler.
 * This simply passes the source to the video element. Nothing fancy.
 * @param  {Object} source   The source object
 * @param  {Html5} tech  The instance of the HTML5 tech
 */
Html5.nativeSourceHandler = {};

/**
 * Check if the video element can handle the source natively
 * @param  {Object} source  The source object
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canHandleSource = function (source) {
  var match, ext;

  function canPlayType(type) {
    // IE9 on Windows 7 without MediaPlayer throws an error here
    // https://github.com/videojs/video.js/issues/519
    try {
      return Lib.TEST_VID.canPlayType(type);
    } catch (e) {
      return '';
    }
  }

  // If a type was provided we should rely on that
  if (source.type) {
    return canPlayType(source.type);
  } else if (source.src) {
    // If no type, fall back to checking 'video/[EXTENSION]'
    ext = Lib.getFileExtension(source.src);

    return canPlayType('video/' + ext);
  }

  return '';
};

/**
 * Pass the source to the video element
 * Adaptive source handlers will have more complicated workflows before passing
 * video data to the video element
 * @param  {Object} source    The source object
 * @param  {Html5} tech   The instance of the Html5 tech
 */
Html5.nativeSourceHandler.handleSource = function (source, tech) {
  tech.setSrc(source.src);
};

/**
 * Clean up the source handler when disposing the player or switching sources..
 * (no cleanup is needed when supporting the format natively)
 */
Html5.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Html5.registerSourceHandler(Html5.nativeSourceHandler);

/**
 * Check if the volume can be changed in this browser/device.
 * Volume cannot be changed in a lot of mobile devices.
 * Specifically, it can't be changed from 1 on iOS.
 * @return {Boolean}
 */
Html5.canControlVolume = function () {
  var volume = Lib.TEST_VID.volume;
  Lib.TEST_VID.volume = volume / 2 + 0.1;
  return volume !== Lib.TEST_VID.volume;
};

/**
 * Check if playbackRate is supported in this browser/device.
 * @return {[type]} [description]
 */
Html5.canControlPlaybackRate = function () {
  var playbackRate = Lib.TEST_VID.playbackRate;
  Lib.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
  return playbackRate !== Lib.TEST_VID.playbackRate;
};

/**
 * Check to see if native text tracks are supported by this browser/device
 * @return {Boolean}
 */
Html5.supportsNativeTextTracks = function () {
  var supportsTextTracks;

  // Figure out native text track support
  // If mode is a number, we cannot change it because it'll disappear from view.
  // Browsers with numeric modes include IE10 and older (<=2013) samsung android models.
  // Firefox isn't playing nice either with modifying the mode
  // TODO: Investigate firefox: https://github.com/videojs/video.js/issues/1862
  supportsTextTracks = !!Lib.TEST_VID.textTracks;
  if (supportsTextTracks && Lib.TEST_VID.textTracks.length > 0) {
    supportsTextTracks = typeof Lib.TEST_VID.textTracks[0]['mode'] !== 'number';
  }
  if (supportsTextTracks && Lib.IS_FIREFOX) {
    supportsTextTracks = false;
  }

  return supportsTextTracks;
};

/**
 * Set the tech's volume control support status
 * @type {Boolean}
 */
Html5.prototype['featuresVolumeControl'] = Html5.canControlVolume();

/**
 * Set the tech's playbackRate support status
 * @type {Boolean}
 */
Html5.prototype['featuresPlaybackRate'] = Html5.canControlPlaybackRate();

/**
 * Set the tech's status on moving the video element.
 * In iOS, if you move a video element in the DOM, it breaks video playback.
 * @type {Boolean}
 */
Html5.prototype['movingMediaElementInDOM'] = !Lib.IS_IOS;

/**
 * Set the the tech's fullscreen resize support status.
 * HTML video is able to automatically resize when going to fullscreen.
 * (No longer appears to be used. Can probably be removed.)
 */
Html5.prototype['featuresFullscreenResize'] = true;

/**
 * Set the tech's progress event support status
 * (this disables the manual progress events of the Tech)
 */
Html5.prototype['featuresProgressEvents'] = true;

/**
 * Sets the tech's status on native text track support
 * @type {Boolean}
 */
Html5.prototype['featuresNativeTextTracks'] = Html5.supportsNativeTextTracks();

// HTML5 Feature detection and Device Fixes --------------------------------- //
var canPlayType = undefined;
var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
var mp4RE = /^video\/mp4/i;

Html5.patchCanPlayType = function () {
  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
  if (Lib.ANDROID_VERSION >= 4) {
    if (!canPlayType) {
      canPlayType = Lib.TEST_VID.constructor.prototype.canPlayType;
    }

    Lib.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mpegurlRE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }

  // Override Android 2.2 and less canPlayType method which is broken
  if (Lib.IS_OLD_ANDROID) {
    if (!canPlayType) {
      canPlayType = Lib.TEST_VID.constructor.prototype.canPlayType;
    }

    Lib.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mp4RE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }
};

Html5.unpatchCanPlayType = function () {
  var r = Lib.TEST_VID.constructor.prototype.canPlayType;
  Lib.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  canPlayType = null;
  return r;
};

// by default, patch the video element
Html5.patchCanPlayType();

Html5.disposeMediaElement = function (el) {
  if (!el) {
    return;
  }

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {}
    })();
  }
};

_component2['default'].registerComponent('Html5', Html5);
exports['default'] = Html5;
module.exports = exports['default'];

// not supported

},{"../component":7,"../lib":46,"../util":70,"./tech.js":63,"global/document":1}],62:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

/**
 * The Media Loader is the component that decides which playback technology to load
 * when the player is initialized.
 *
 * @constructor
 */

var MediaLoader = (function (_Component) {
  function MediaLoader(player, options, ready) {
    _classCallCheck(this, MediaLoader);

    _get(Object.getPrototypeOf(MediaLoader.prototype), 'constructor', this).call(this, player, options, ready);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.
    if (!player.options_['sources'] || player.options_['sources'].length === 0) {
      for (var i = 0, j = player.options_['techOrder']; i < j.length; i++) {
        var techName = Lib.capitalize(j[i]);
        var tech = _component2['default'].getComponent(techName);

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech(techName);
          break;
        }
      }
    } else {
      // // Loop through playback technologies (HTML5, Flash) and check for support.
      // // Then load the best source.
      // // A few assumptions here:
      // //   All playback technologies respect preload false.
      player.src(player.options_['sources']);
    }
  }

  _inherits(MediaLoader, _Component);

  return MediaLoader;
})(_component2['default']);

_component2['default'].registerComponent('MediaLoader', MediaLoader);
exports['default'] = MediaLoader;
module.exports = exports['default'];

},{"../component":7,"../lib":46,"global/window":2}],63:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x4,
    property = _x5,
    receiver = _x6; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

/**
 * @fileoverview Media Technology Controller - Base class for media playback
 * technology controllers like Flash and HTML5
 */

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _tracksTextTrack = _dereq_('../tracks/text-track');

var _tracksTextTrack2 = _interopRequireDefault(_tracksTextTrack);

var _tracksTextTrackList = _dereq_('../tracks/text-track-list');

var _tracksTextTrackList2 = _interopRequireDefault(_tracksTextTrackList);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * Base class for media (HTML5 Video, Flash) controllers
 * @param {Player|Object} player  Central player instance
 * @param {Object=} options Options object
 * @constructor
 */

var Tech = (function (_Component) {
  function Tech() {
    var options = arguments[0] === undefined ? {} : arguments[0];
    var ready = arguments[1] === undefined ? function () {} : arguments[1];

    _classCallCheck(this, Tech);

    options = options || {};
    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;
    _get(Object.getPrototypeOf(Tech.prototype), 'constructor', this).call(this, null, options, ready);

    this.textTracks_ = options.textTracks;

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!this.featuresProgressEvents) {
      this.manualProgressOn();
    }

    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
    if (!this.featuresTimeupdateEvents) {
      this.manualTimeUpdatesOn();
    }

    this.initControlsListeners();

    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      this.featuresNativeTextTracks = false;
    }

    if (!this.featuresNativeTextTracks) {
      this.emulateTextTracks();
    }

    this.initTextTrackListeners();
  }

  _inherits(Tech, _Component);

  _createClass(Tech, [{
    key: 'initControlsListeners',

    /**
     * Set up click and touch listeners for the playback element
     * On desktops, a click on the video itself will toggle playback,
     * on a mobile device a click on the video toggles controls.
     * (toggling controls is done by toggling the user state between active and
     * inactive)
     *
     * A tap can signal that a user has become active, or has become inactive
     * e.g. a quick tap on an iPhone movie should reveal the controls. Another
     * quick tap should hide them again (signaling the user is in an inactive
     * viewing state)
     *
     * In addition to this, we still want the user to be considered inactive after
     * a few seconds of inactivity.
     *
     * Note: the only part of iOS interaction we can't mimic with this setup
     * is a touch and hold on the video element counting as activity in order to
     * keep the controls showing, but that shouldn't be an issue. A touch and hold on
     * any controls will still keep the user active
     */
    value: function initControlsListeners() {
      // if we're loading the playback object after it has started loading or playing the
      // video (often with autoplay on) then the loadstart event has already fired and we
      // need to fire it manually because many things rely on it.
      // Long term we might consider how we would do this for other events like 'canplay'
      // that may also have fired.
      this.ready(function () {
        if (this.networkState && this.networkState() > 0) {
          this.trigger('loadstart');
        }
      });
    }
  }, {
    key: 'manualProgressOn',

    /* Fallbacks for unsupported event types
    ================================================================================ */
    // Manually trigger progress events based on changes to the buffered amount
    // Many flash players and older HTML5 browsers don't send progress or progress-like events
    value: function manualProgressOn() {
      this.on('durationchange', this.onDurationChange);

      this.manualProgress = true;

      // Trigger progress watching when a source begins loading
      this.trackProgress();
    }
  }, {
    key: 'manualProgressOff',
    value: function manualProgressOff() {
      this.manualProgress = false;
      this.stopTrackingProgress();

      this.off('durationchange', this.onDurationChange);
    }
  }, {
    key: 'trackProgress',
    value: function trackProgress() {
      this.progressInterval = this.setInterval(Lib.bind(this, function () {
        // Don't trigger unless buffered amount is greater than last time

        var bufferedPercent = this.bufferedPercent();

        if (this.bufferedPercent_ !== bufferedPercent) {
          this.trigger('progress');
        }

        this.bufferedPercent_ = bufferedPercent;

        if (bufferedPercent === 1) {
          this.stopTrackingProgress();
        }
      }), 500);
    }
  }, {
    key: 'onDurationChange',
    value: function onDurationChange() {
      this.duration_ = this.duration();
    }
  }, {
    key: 'bufferedPercent',
    value: function bufferedPercent() {
      var bufferedDuration = 0,
          start = undefined,
          end = undefined;

      if (!this.duration_) {
        return 0;
      }

      var buffered = this.buffered();

      if (!buffered || !buffered.length) {
        buffered = Lib.createTimeRange(0, 0);
      }

      for (var i = 0; i < buffered.length; i++) {
        start = buffered.start(i);
        end = buffered.end(i);

        // buffered end can be bigger than duration by a very small fraction
        if (end > this.duration_) {
          end = this.duration_;
        }

        bufferedDuration += end - start;
      }

      return bufferedDuration / this.duration_;
    }
  }, {
    key: 'stopTrackingProgress',
    value: function stopTrackingProgress() {
      this.clearInterval(this.progressInterval);
    }
  }, {
    key: 'manualTimeUpdatesOn',

    /*! Time Tracking -------------------------------------------------------------- */
    value: function manualTimeUpdatesOn() {
      this.manualTimeUpdates = true;

      this.on('play', this.trackCurrentTime);
      this.on('pause', this.stopTrackingCurrentTime);
      // timeupdate is also called by .currentTime whenever current time is set

      // Watch for native timeupdate event only
      var onTimeUpdate = function onTimeUpdate(e) {
        if (e.manuallyTriggered) return;

        this.off('timeupdate', onTimeUpdate);

        // Update known progress support for this playback technology
        this.featuresTimeupdateEvents = true;
        // Turn off manual progress tracking
        this.manualTimeUpdatesOff();
      };

      this.on('timeupdate', onTimeUpdate);
    }
  }, {
    key: 'manualTimeUpdatesOff',
    value: function manualTimeUpdatesOff() {
      this.manualTimeUpdates = false;
      this.stopTrackingCurrentTime();
      this.off('play', this.trackCurrentTime);
      this.off('pause', this.stopTrackingCurrentTime);
    }
  }, {
    key: 'trackCurrentTime',
    value: function trackCurrentTime() {
      if (this.currentTimeInterval) {
        this.stopTrackingCurrentTime();
      }
      this.currentTimeInterval = this.setInterval(function () {
        this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
      }, 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
    }
  }, {
    key: 'stopTrackingCurrentTime',

    // Turn off play progress tracking (when paused or dragging)
    value: function stopTrackingCurrentTime() {
      this.clearInterval(this.currentTimeInterval);

      // #1002 - if the video ends right before the next timeupdate would happen,
      // the progress bar won't make it all the way to the end
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      // Turn off any manual progress or timeupdate tracking
      if (this.manualProgress) {
        this.manualProgressOff();
      }

      if (this.manualTimeUpdates) {
        this.manualTimeUpdatesOff();
      }

      _get(Object.getPrototypeOf(Tech.prototype), 'dispose', this).call(this);
    }
  }, {
    key: 'setCurrentTime',
    value: function setCurrentTime() {
      // improve the accuracy of manual timeupdates
      if (this.manualTimeUpdates) {
        this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
      }
    }
  }, {
    key: 'initTextTrackListeners',
    value: function initTextTrackListeners() {
      var textTrackListChanges = Lib.bind(this, function () {
        this.trigger('texttrackchange');
      });

      var tracks = this.textTracks();

      if (!tracks) return;

      tracks.addEventListener('removetrack', textTrackListChanges);
      tracks.addEventListener('addtrack', textTrackListChanges);

      this.on('dispose', Lib.bind(this, function () {
        tracks.removeEventListener('removetrack', textTrackListChanges);
        tracks.removeEventListener('addtrack', textTrackListChanges);
      }));
    }
  }, {
    key: 'emulateTextTracks',
    value: function emulateTextTracks() {
      if (!_globalWindow2['default']['WebVTT'] && this.el().parentNode != null) {
        var script = _globalDocument2['default'].createElement('script');
        script.src = this.options_['vtt.js'] || '../node_modules/vtt.js/dist/vtt.js';
        this.el().parentNode.appendChild(script);
        _globalWindow2['default']['WebVTT'] = true;
      }

      var tracks = this.textTracks();
      if (!tracks) {
        return;
      }

      var textTracksChanges = function textTracksChanges() {
        var updateDisplay = Lib.bind(this, function () {
          this.trigger('texttrackchange');
        });

        this.trigger('texttrackchange');

        for (var i = 0; i < this.length; i++) {
          var track = this[i];
          track.removeEventListener('cuechange', updateDisplay);
          if (track.mode === 'showing') {
            track.addEventListener('cuechange', updateDisplay);
          }
        }
      };

      tracks.addEventListener('change', textTracksChanges);

      this.on('dispose', Lib.bind(this, function () {
        tracks.removeEventListener('change', textTracksChanges);
      }));
    }
  }, {
    key: 'textTracks',

    /**
     * Provide default methods for text tracks.
     *
     * Html5 tech overrides these.
     */

    value: function textTracks() {
      this.textTracks_ = this.textTracks_ || new _tracksTextTrackList2['default']();
      return this.textTracks_;
    }
  }, {
    key: 'remoteTextTracks',
    value: function remoteTextTracks() {
      this.remoteTextTracks_ = this.remoteTextTracks_ || new _tracksTextTrackList2['default']();
      return this.remoteTextTracks_;
    }
  }, {
    key: 'addTextTrack',
    value: function addTextTrack(kind, label, language) {
      if (!kind) {
        throw new Error('TextTrack kind is required but was not provided');
      }

      return createTrackHelper(this, kind, label, language);
    }
  }, {
    key: 'addRemoteTextTrack',
    value: function addRemoteTextTrack(options) {
      var track = createTrackHelper(this, options.kind, options.label, options.language, options);
      this.remoteTextTracks().addTrack_(track);
      return {
        track: track
      };
    }
  }, {
    key: 'removeRemoteTextTrack',
    value: function removeRemoteTextTrack(track) {
      this.textTracks().removeTrack_(track);
      this.remoteTextTracks().removeTrack_(track);
    }
  }, {
    key: 'setPoster',

    /**
     * Provide a default setPoster method for techs
     *
     * Poster support for techs should be optional, so we don't want techs to
     * break if they don't have a way to set a poster.
     */
    value: function setPoster() {}
  }]);

  return Tech;
})(_component2['default']);

/**
 * List of associated text tracks
 * @type {Array}
 * @private
 */
Tech.prototype.textTracks_;

var createTrackHelper = function createTrackHelper(self, kind, label, language) {
  var options = arguments[4] === undefined ? {} : arguments[4];

  var tracks = self.textTracks();

  options.kind = kind;

  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self;

  var track = new _tracksTextTrack2['default'](options);
  tracks.addTrack_(track);

  return track;
};

Tech.prototype.featuresVolumeControl = true;

// Resizing plugins using request fullscreen reloads the plugin
Tech.prototype.featuresFullscreenResize = false;
Tech.prototype.featuresPlaybackRate = false;

// Optional events that we can manually mimic with timers
// currently not triggered by video-js-swf
Tech.prototype.featuresProgressEvents = false;
Tech.prototype.featuresTimeupdateEvents = false;

Tech.prototype.featuresNativeTextTracks = false;

/**
 * A functional mixin for techs that want to use the Source Handler pattern.
 *
 * ##### EXAMPLE:
 *
 *   Tech.withSourceHandlers.call(MyTech);
 *
 */
Tech.withSourceHandlers = function (_Tech) {
  /**
   * Register a source handler
   * Source handlers are scripts for handling specific formats.
   * The source handler pattern is used for adaptive formats (HLS, DASH) that
   * manually load video data and feed it into a Source Buffer (Media Source Extensions)
   * @param  {Function} handler  The source handler
   * @param  {Boolean}  first    Register it before any existing handlers
   */
  _Tech.registerSourceHandler = function (handler, index) {
    var handlers = _Tech.sourceHandlers;

    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }

    if (index === undefined) {
      // add to the end of the list
      index = handlers.length;
    }

    handlers.splice(index, 0, handler);
  };

  /**
   * Return the first source handler that supports the source
   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
   * @param  {Object} source The source object
   * @returns {Object}       The first source handler that supports the source
   * @returns {null}         Null if no source handler is found
   */
  _Tech.selectSourceHandler = function (source) {
    var handlers = _Tech.sourceHandlers || [];
    var can = undefined;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source);

      if (can) {
        return handlers[i];
      }
    }

    return null;
  };

  /**
  * Check if the tech can support the given source
  * @param  {Object} srcObj  The source object
  * @return {String}         'probably', 'maybe', or '' (empty string)
  */
  _Tech.canPlaySource = function (srcObj) {
    var sh = _Tech.selectSourceHandler(srcObj);

    if (sh) {
      return sh.canHandleSource(srcObj);
    }

    return '';
  };

  /**
   * Create a function for setting the source using a source object
   * and source handlers.
   * Should never be called unless a source handler was found.
   * @param {Object} source  A source object with src and type keys
   * @return {Tech} self
   */
  _Tech.prototype.setSource = function (source) {
    var sh = _Tech.selectSourceHandler(source);

    if (!sh) {
      // Fall back to a native source hander when unsupported sources are
      // deliberately set
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        Lib.log.error('No source hander found for the current source.');
      }
    }

    // Dispose any existing source handler
    this.disposeSourceHandler();
    this.off('dispose', this.disposeSourceHandler);

    this.currentSource_ = source;
    this.sourceHandler_ = sh.handleSource(source, this);
    this.on('dispose', this.disposeSourceHandler);

    return this;
  };

  /**
   * Clean up any existing source handler
   */
  _Tech.prototype.disposeSourceHandler = function () {
    if (this.sourceHandler_ && this.sourceHandler_.dispose) {
      this.sourceHandler_.dispose();
    }
  };
};

_component2['default'].registerComponent('Tech', Tech);
// Old name for Tech
_component2['default'].registerComponent('MediaTechController', Tech);
exports['default'] = Tech;
module.exports = exports['default'];

},{"../component":7,"../lib":46,"../tracks/text-track":69,"../tracks/text-track-list":67,"global/document":1,"global/window":2}],64:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist
 *
 * interface TextTrackCueList {
 *   readonly attribute unsigned long length;
 *   getter TextTrackCue (unsigned long index);
 *   TextTrackCue? getCueById(DOMString id);
 * };
 */

var TextTrackCueList = function TextTrackCueList(cues) {
  var list = this;

  if (Lib.IS_IE8) {
    list = _globalDocument2['default'].createElement('custom');

    for (var prop in TextTrackCueList.prototype) {
      list[prop] = TextTrackCueList.prototype[prop];
    }
  }

  TextTrackCueList.prototype.setCues_.call(list, cues);

  Object.defineProperty(list, 'length', {
    get: function get() {
      return this.length_;
    }
  });

  if (Lib.IS_IE8) {
    return list;
  }
};

TextTrackCueList.prototype.setCues_ = function (cues) {
  var oldLength = this.length || 0;
  var i = 0;
  var l = cues.length;

  this.cues_ = cues;
  this.length_ = cues.length;

  var defineProp = function defineProp(i) {
    if (!('' + i in this)) {
      Object.defineProperty(this, '' + i, {
        get: function get() {
          return this.cues_[i];
        }
      });
    }
  };

  if (oldLength < l) {
    i = oldLength;

    for (; i < l; i++) {
      defineProp.call(this, i);
    }
  }
};

TextTrackCueList.prototype.getCueById = function (id) {
  var result = null;
  for (var i = 0, l = this.length; i < l; i++) {
    var cue = this[i];
    if (cue.id === id) {
      result = cue;
      break;
    }
  }

  return result;
};

exports['default'] = TextTrackCueList;
module.exports = exports['default'];

},{"../lib":46,"global/document":1}],65:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _menuMenuJs = _dereq_('../menu/menu.js');

var _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);

var _menuMenuItemJs = _dereq_('../menu/menu-item.js');

var _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);

var _menuMenuButtonJs = _dereq_('../menu/menu-button.js');

var _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);

var _libJs = _dereq_('../lib.js');

var Lib = _interopRequireWildcard(_libJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var darkGray = '#222';
var lightGray = '#ccc';
var fontMap = {
  monospace: 'monospace',
  sansSerif: 'sans-serif',
  serif: 'serif',
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: 'sans-serif',
  proportionalSerif: 'serif',
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};

/**
 * The component for displaying text track cues
 *
 * @constructor
 */

var TextTrackDisplay = (function (_Component) {
  function TextTrackDisplay(player, options, ready) {
    _classCallCheck(this, TextTrackDisplay);

    _get(Object.getPrototypeOf(TextTrackDisplay.prototype), 'constructor', this).call(this, player, options, ready);

    player.on('loadstart', Lib.bind(this, this.toggleDisplay));
    player.on('texttrackchange', Lib.bind(this, this.toggleDisplay));

    // This used to be called during player init, but was causing an error
    // if a track should show by default and the display hadn't loaded yet.
    // Should probably be moved to an external track loader when we support
    // tracks that don't need a display.
    player.ready(Lib.bind(this, function () {
      if (player.tech && player.tech['featuresNativeTextTracks']) {
        this.hide();
        return;
      }

      player.on('fullscreenchange', Lib.bind(this, this.updateDisplay));

      var tracks = player.options_['tracks'] || [];
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        this.player_.addRemoteTextTrack(track);
      }
    }));
  }

  _inherits(TextTrackDisplay, _Component);

  _createClass(TextTrackDisplay, [{
    key: 'toggleDisplay',
    value: function toggleDisplay() {
      if (this.player_.tech && this.player_.tech['featuresNativeTextTracks']) {
        this.hide();
      } else {
        this.show();
      }
    }
  }, {
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(TextTrackDisplay.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-text-track-display'
      });
    }
  }, {
    key: 'clearDisplay',
    value: function clearDisplay() {
      if (typeof _globalWindow2['default']['WebVTT'] === 'function') {
        _globalWindow2['default']['WebVTT']['processCues'](_globalWindow2['default'], [], this.el_);
      }
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      var tracks = this.player_.textTracks();

      this.clearDisplay();

      if (!tracks) {
        return;
      }

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (track['mode'] === 'showing') {
          this.updateForTrack(track);
        }
      }
    }
  }, {
    key: 'updateForTrack',
    value: function updateForTrack(track) {
      if (typeof _globalWindow2['default']['WebVTT'] !== 'function' || !track['activeCues']) {
        return;
      }

      var overrides = this.player_['textTrackSettings'].getValues();

      var cues = [];
      for (var _i = 0; _i < track['activeCues'].length; _i++) {
        cues.push(track['activeCues'][_i]);
      }

      _globalWindow2['default']['WebVTT']['processCues'](_globalWindow2['default'], track['activeCues'], this.el_);

      var i = cues.length;
      while (i--) {
        var cueDiv = cues[i].displayState;
        if (overrides.color) {
          cueDiv.firstChild.style.color = overrides.color;
        }
        if (overrides.textOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
        }
        if (overrides.backgroundColor) {
          cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
        }
        if (overrides.backgroundOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
        }
        if (overrides.windowColor) {
          if (overrides.windowOpacity) {
            tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
          } else {
            cueDiv.style.backgroundColor = overrides.windowColor;
          }
        }
        if (overrides.edgeStyle) {
          if (overrides.edgeStyle === 'dropshadow') {
            cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
          } else if (overrides.edgeStyle === 'raised') {
            cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
          } else if (overrides.edgeStyle === 'depressed') {
            cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
          } else if (overrides.edgeStyle === 'uniform') {
            cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
          }
        }
        if (overrides.fontPercent && overrides.fontPercent !== 1) {
          var fontSize = _globalWindow2['default'].parseFloat(cueDiv.style.fontSize);
          cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
          cueDiv.style.height = 'auto';
          cueDiv.style.top = 'auto';
          cueDiv.style.bottom = '2px';
        }
        if (overrides.fontFamily && overrides.fontFamily !== 'default') {
          if (overrides.fontFamily === 'small-caps') {
            cueDiv.firstChild.style.fontVariant = 'small-caps';
          } else {
            cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
          }
        }
      }
    }
  }]);

  return TextTrackDisplay;
})(_component2['default']);

// Add cue HTML to display
function constructColor(color, opacity) {
  return 'rgba(' +
  // color looks like "#f0e"
  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
}

function tryUpdateStyle(el, style, rule) {
  // some style changes will throw an error, particularly in IE8. Those should be noops.
  try {
    el.style[style] = rule;
  } catch (e) {}
}

_component2['default'].registerComponent('TextTrackDisplay', TextTrackDisplay);
exports['default'] = TextTrackDisplay;
module.exports = exports['default'];

},{"../component":7,"../lib.js":46,"../menu/menu-button.js":49,"../menu/menu-item.js":50,"../menu/menu.js":51,"global/document":1,"global/window":2}],66:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
 *
 * enum TextTrackMode { "disabled",  "hidden",  "showing" };
 */
var TextTrackMode = {
  'disabled': 'disabled',
  'hidden': 'hidden',
  'showing': 'showing'
};

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackkind
 *
 * enum TextTrackKind { "subtitles",  "captions",  "descriptions",  "chapters",  "metadata" };
 */
var TextTrackKind = {
  'subtitles': 'subtitles',
  'captions': 'captions',
  'descriptions': 'descriptions',
  'chapters': 'chapters',
  'metadata': 'metadata'
};

exports.TextTrackMode = TextTrackMode;
exports.TextTrackKind = TextTrackKind;

},{}],67:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _eventEmitter = _dereq_('../event-emitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist
 *
 * interface TextTrackList : EventTarget {
 *   readonly attribute unsigned long length;
 *   getter TextTrack (unsigned long index);
 *   TextTrack? getTrackById(DOMString id);
 *
 *   attribute EventHandler onchange;
 *   attribute EventHandler onaddtrack;
 *   attribute EventHandler onremovetrack;
 * };
 */
var TextTrackList = function TextTrackList(tracks) {
  var list = this;

  if (Lib.IS_IE8) {
    list = _globalDocument2['default'].createElement('custom');

    for (var prop in TextTrackList.prototype) {
      list[prop] = TextTrackList.prototype[prop];
    }
  }

  tracks = tracks || [];
  list.tracks_ = [];

  Object.defineProperty(list, 'length', {
    get: function get() {
      return this.tracks_.length;
    }
  });

  for (var i = 0; i < tracks.length; i++) {
    list.addTrack_(tracks[i]);
  }

  if (Lib.IS_IE8) {
    return list;
  }
};

TextTrackList.prototype = Lib.obj.create(_eventEmitter2['default'].prototype);
TextTrackList.prototype.constructor = TextTrackList;

/*
 * change - One or more tracks in the track list have been enabled or disabled.
 * addtrack - A track has been added to the track list.
 * removetrack - A track has been removed from the track list.
*/
TextTrackList.prototype.allowedEvents_ = {
  'change': 'change',
  'addtrack': 'addtrack',
  'removetrack': 'removetrack'
};

// emulate attribute EventHandler support to allow for feature detection
for (var _event in TextTrackList.prototype.allowedEvents_) {
  TextTrackList.prototype['on' + _event] = null;
}

TextTrackList.prototype.addTrack_ = function (track) {
  var index = this.tracks_.length;
  if (!('' + index in this)) {
    Object.defineProperty(this, index, {
      get: function get() {
        return this.tracks_[index];
      }
    });
  }

  track.addEventListener('modechange', Lib.bind(this, function () {
    this.trigger('change');
  }));
  this.tracks_.push(track);

  this.trigger({
    type: 'addtrack',
    track: track
  });
};

TextTrackList.prototype.removeTrack_ = function (rtrack) {
  var result = null;
  var track = undefined;

  for (var i = 0, l = this.length; i < l; i++) {
    track = this[i];
    if (track === rtrack) {
      this.tracks_.splice(i, 1);
      break;
    }
  }

  this.trigger({
    type: 'removetrack',
    track: track
  });
};

TextTrackList.prototype.getTrackById = function (id) {
  var result = null;

  for (var i = 0, l = this.length; i < l; i++) {
    var track = this[i];
    if (track.id === id) {
      result = track;
      break;
    }
  }

  return result;
};

exports['default'] = TextTrackList;
module.exports = exports['default'];

},{"../event-emitter":42,"../lib":46,"global/document":1}],68:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { desc = parent = getter = undefined; _again = false; var object = _x,
    property = _x2,
    receiver = _x3; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

var _events = _dereq_('../events');

var Events = _interopRequireWildcard(_events);

var _safeJsonParseTuple = _dereq_('safe-json-parse/tuple');

var _safeJsonParseTuple2 = _interopRequireDefault(_safeJsonParseTuple);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var TextTrackSettings = (function (_Component) {
  function TextTrackSettings(player, options) {
    _classCallCheck(this, TextTrackSettings);

    _get(Object.getPrototypeOf(TextTrackSettings.prototype), 'constructor', this).call(this, player, options);
    this.hide();

    Events.on(this.el().querySelector('.vjs-done-button'), 'click', Lib.bind(this, function () {
      this.saveSettings();
      this.hide();
    }));

    Events.on(this.el().querySelector('.vjs-default-button'), 'click', Lib.bind(this, function () {
      this.el().querySelector('.vjs-fg-color > select').selectedIndex = 0;
      this.el().querySelector('.vjs-bg-color > select').selectedIndex = 0;
      this.el().querySelector('.window-color > select').selectedIndex = 0;
      this.el().querySelector('.vjs-text-opacity > select').selectedIndex = 0;
      this.el().querySelector('.vjs-bg-opacity > select').selectedIndex = 0;
      this.el().querySelector('.vjs-window-opacity > select').selectedIndex = 0;
      this.el().querySelector('.vjs-edge-style select').selectedIndex = 0;
      this.el().querySelector('.vjs-font-family select').selectedIndex = 0;
      this.el().querySelector('.vjs-font-percent select').selectedIndex = 2;
      this.updateDisplay();
    }));

    Events.on(this.el().querySelector('.vjs-fg-color > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-bg-color > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.window-color > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-text-opacity > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-bg-opacity > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-window-opacity > select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-font-percent select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-edge-style select'), 'change', Lib.bind(this, this.updateDisplay));
    Events.on(this.el().querySelector('.vjs-font-family select'), 'change', Lib.bind(this, this.updateDisplay));

    if (player.options()['persistTextTrackSettings']) {
      this.restoreSettings();
    }
  }

  _inherits(TextTrackSettings, _Component);

  _createClass(TextTrackSettings, [{
    key: 'createEl',
    value: function createEl() {
      return _get(Object.getPrototypeOf(TextTrackSettings.prototype), 'createEl', this).call(this, 'div', {
        className: 'vjs-caption-settings vjs-modal-overlay',
        innerHTML: captionOptionsMenuTemplate()
      });
    }
  }, {
    key: 'getValues',
    value: function getValues() {
      var el = this.el();

      var textEdge = getSelectedOptionValue(el.querySelector('.vjs-edge-style select'));
      var fontFamily = getSelectedOptionValue(el.querySelector('.vjs-font-family select'));
      var fgColor = getSelectedOptionValue(el.querySelector('.vjs-fg-color > select'));
      var textOpacity = getSelectedOptionValue(el.querySelector('.vjs-text-opacity > select'));
      var bgColor = getSelectedOptionValue(el.querySelector('.vjs-bg-color > select'));
      var bgOpacity = getSelectedOptionValue(el.querySelector('.vjs-bg-opacity > select'));
      var windowColor = getSelectedOptionValue(el.querySelector('.window-color > select'));
      var windowOpacity = getSelectedOptionValue(el.querySelector('.vjs-window-opacity > select'));
      var fontPercent = _globalWindow2['default']['parseFloat'](getSelectedOptionValue(el.querySelector('.vjs-font-percent > select')));

      var result = {
        'backgroundOpacity': bgOpacity,
        'textOpacity': textOpacity,
        'windowOpacity': windowOpacity,
        'edgeStyle': textEdge,
        'fontFamily': fontFamily,
        'color': fgColor,
        'backgroundColor': bgColor,
        'windowColor': windowColor,
        'fontPercent': fontPercent
      };
      for (var _name in result) {
        if (result[_name] === '' || result[_name] === 'none' || _name === 'fontPercent' && result[_name] === 1) {
          delete result[_name];
        }
      }
      return result;
    }
  }, {
    key: 'setValues',
    value: function setValues(values) {
      var el = this.el();

      setSelectedOption(el.querySelector('.vjs-edge-style select'), values.edgeStyle);
      setSelectedOption(el.querySelector('.vjs-font-family select'), values.fontFamily);
      setSelectedOption(el.querySelector('.vjs-fg-color > select'), values.color);
      setSelectedOption(el.querySelector('.vjs-text-opacity > select'), values.textOpacity);
      setSelectedOption(el.querySelector('.vjs-bg-color > select'), values.backgroundColor);
      setSelectedOption(el.querySelector('.vjs-bg-opacity > select'), values.backgroundOpacity);
      setSelectedOption(el.querySelector('.window-color > select'), values.windowColor);
      setSelectedOption(el.querySelector('.vjs-window-opacity > select'), values.windowOpacity);

      var fontPercent = values.fontPercent;

      if (fontPercent) {
        fontPercent = fontPercent.toFixed(2);
      }

      setSelectedOption(el.querySelector('.vjs-font-percent > select'), fontPercent);
    }
  }, {
    key: 'restoreSettings',
    value: function restoreSettings() {
      var _safeParseTuple = _safeJsonParseTuple2['default'](_globalWindow2['default'].localStorage.getItem('vjs-text-track-settings'));

      var _safeParseTuple2 = _slicedToArray(_safeParseTuple, 2);

      var err = _safeParseTuple2[0];
      var values = _safeParseTuple2[1];

      if (err) {
        Lib.log.error(err);
      }

      if (values) {
        this.setValues(values);
      }
    }
  }, {
    key: 'saveSettings',
    value: function saveSettings() {
      if (!this.player_.options()['persistTextTrackSettings']) {
        return;
      }

      var values = this.getValues();
      try {
        if (!Lib.isEmpty(values)) {
          _globalWindow2['default'].localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));
        } else {
          _globalWindow2['default'].localStorage.removeItem('vjs-text-track-settings');
        }
      } catch (e) {}
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      var ttDisplay = this.player_.getChild('textTrackDisplay');
      if (ttDisplay) {
        ttDisplay.updateDisplay();
      }
    }
  }]);

  return TextTrackSettings;
})(_component2['default']);

_component2['default'].registerComponent('TextTrackSettings', TextTrackSettings);

function getSelectedOptionValue(target) {
  var selectedOption = undefined;
  // not all browsers support selectedOptions, so, fallback to options
  if (target.selectedOptions) {
    selectedOption = target.selectedOptions[0];
  } else if (target.options) {
    selectedOption = target.options[target.options.selectedIndex];
  }

  return selectedOption.value;
}

function setSelectedOption(target, value) {
  if (!value) {
    return;
  }

  var i = undefined;
  for (i = 0; i < target.options.length; i++) {
    var option = target.options[i];
    if (option.value === value) {
      break;
    }
  }

  target.selectedIndex = i;
}

function captionOptionsMenuTemplate() {
  var template = '<div class="vjs-tracksettings">\n      <div class="vjs-tracksettings-colors">\n        <div class="vjs-fg-color vjs-tracksetting">\n            <label class="vjs-label">Foreground</label>\n            <select>\n              <option value="">---</option>\n              <option value="#FFF">White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-text-opacity vjs-opacity">\n              <select>\n                <option value="">---</option>\n                <option value="1">Opaque</option>\n                <option value="0.5">Semi-Opaque</option>\n              </select>\n            </span>\n        </div> <!-- vjs-fg-color -->\n        <div class="vjs-bg-color vjs-tracksetting">\n            <label class="vjs-label">Background</label>\n            <select>\n              <option value="">---</option>\n              <option value="#FFF">White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-bg-opacity vjs-opacity">\n                <select>\n                  <option value="">---</option>\n                  <option value="1">Opaque</option>\n                  <option value="0.5">Semi-Transparent</option>\n                  <option value="0">Transparent</option>\n                </select>\n            </span>\n        </div> <!-- vjs-bg-color -->\n        <div class="window-color vjs-tracksetting">\n            <label class="vjs-label">Window</label>\n            <select>\n              <option value="">---</option>\n              <option value="#FFF">White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-window-opacity vjs-opacity">\n                <select>\n                  <option value="">---</option>\n                  <option value="1">Opaque</option>\n                  <option value="0.5">Semi-Transparent</option>\n                  <option value="0">Transparent</option>\n                </select>\n            </span>\n        </div> <!-- vjs-window-color -->\n      </div> <!-- vjs-tracksettings -->\n      <div class="vjs-tracksettings-font">\n        <div class="vjs-font-percent vjs-tracksetting">\n          <label class="vjs-label">Font Size</label>\n          <select>\n            <option value="0.50">50%</option>\n            <option value="0.75">75%</option>\n            <option value="1.00" selected>100%</option>\n            <option value="1.25">125%</option>\n            <option value="1.50">150%</option>\n            <option value="1.75">175%</option>\n            <option value="2.00">200%</option>\n            <option value="3.00">300%</option>\n            <option value="4.00">400%</option>\n          </select>\n        </div> <!-- vjs-font-percent -->\n        <div class="vjs-edge-style vjs-tracksetting">\n          <label class="vjs-label">Text Edge Style</label>\n          <select>\n            <option value="none">None</option>\n            <option value="raised">Raised</option>\n            <option value="depressed">Depressed</option>\n            <option value="uniform">Uniform</option>\n            <option value="dropshadow">Dropshadow</option>\n          </select>\n        </div> <!-- vjs-edge-style -->\n        <div class="vjs-font-family vjs-tracksetting">\n          <label class="vjs-label">Font Family</label>\n          <select>\n            <option value="">Default</option>\n            <option value="monospaceSerif">Monospace Serif</option>\n            <option value="proportionalSerif">Proportional Serif</option>\n            <option value="monospaceSansSerif">Monospace Sans-Serif</option>\n            <option value="proportionalSansSerif">Proportional Sans-Serif</option>\n            <option value="casual">Casual</option>\n            <option value="script">Script</option>\n            <option value="small-caps">Small Caps</option>\n          </select>\n        </div> <!-- vjs-font-family -->\n      </div>\n    </div>\n    <div class="vjs-tracksettings-controls">\n      <button class="vjs-default-button">Defaults</button>\n      <button class="vjs-done-button">Done</button>\n    </div>';

  return template;
}

exports['default'] = TextTrackSettings;
module.exports = exports['default'];

},{"../component":7,"../events":43,"../lib":46,"global/window":2,"safe-json-parse/tuple":4}],69:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _textTrackCueList = _dereq_('./text-track-cue-list');

var _textTrackCueList2 = _interopRequireDefault(_textTrackCueList);

var _lib = _dereq_('../lib');

var Lib = _interopRequireWildcard(_lib);

var _textTrackEnums = _dereq_('./text-track-enums');

var TextTrackEnum = _interopRequireWildcard(_textTrackEnums);

var _eventEmitter = _dereq_('../event-emitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _xhrJs = _dereq_('../xhr.js');

var _xhrJs2 = _interopRequireDefault(_xhrJs);

/*
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack
 *
 * interface TextTrack : EventTarget {
 *   readonly attribute TextTrackKind kind;
 *   readonly attribute DOMString label;
 *   readonly attribute DOMString language;
 *
 *   readonly attribute DOMString id;
 *   readonly attribute DOMString inBandMetadataTrackDispatchType;
 *
 *   attribute TextTrackMode mode;
 *
 *   readonly attribute TextTrackCueList? cues;
 *   readonly attribute TextTrackCueList? activeCues;
 *
 *   void addCue(TextTrackCue cue);
 *   void removeCue(TextTrackCue cue);
 *
 *   attribute EventHandler oncuechange;
 * };
 */
var TextTrack = function TextTrack() {
  var options = arguments[0] === undefined ? {} : arguments[0];

  if (!options.tech) {
    throw new Error('A tech was not provided.');
  }

  var tt = this;
  if (Lib.IS_IE8) {
    tt = _globalDocument2['default'].createElement('custom');

    for (var prop in TextTrack.prototype) {
      tt[prop] = TextTrack.prototype[prop];
    }
  }

  tt.tech_ = options.tech;

  var mode = TextTrackEnum.TextTrackMode[options['mode']] || 'disabled';
  var kind = TextTrackEnum.TextTrackKind[options['kind']] || 'subtitles';
  var label = options['label'] || '';
  var language = options['language'] || options['srclang'] || '';
  var id = options['id'] || 'vjs_text_track_' + Lib.guid++;

  if (kind === 'metadata' || kind === 'chapters') {
    mode = 'hidden';
  }

  tt.cues_ = [];
  tt.activeCues_ = [];

  var cues = new _textTrackCueList2['default'](tt.cues_);
  var activeCues = new _textTrackCueList2['default'](tt.activeCues_);

  var changed = false;
  var timeupdateHandler = Lib.bind(tt, function () {
    this['activeCues'];
    if (changed) {
      this['trigger']('cuechange');
      changed = false;
    }
  });
  if (mode !== 'disabled') {
    tt.tech_.on('timeupdate', timeupdateHandler);
  }

  Object.defineProperty(tt, 'kind', {
    get: function get() {
      return kind;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'label', {
    get: function get() {
      return label;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'language', {
    get: function get() {
      return language;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'id', {
    get: function get() {
      return id;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'mode', {
    get: function get() {
      return mode;
    },
    set: function set(newMode) {
      if (!TextTrackEnum.TextTrackMode[newMode]) {
        return;
      }
      mode = newMode;
      if (mode === 'showing') {
        this.tech_.on('timeupdate', timeupdateHandler);
      }
      this.trigger('modechange');
    }
  });

  Object.defineProperty(tt, 'cues', {
    get: function get() {
      if (!this.loaded_) {
        return null;
      }

      return cues;
    },
    set: Function.prototype
  });

  Object.defineProperty(tt, 'activeCues', {
    get: function get() {
      if (!this.loaded_) {
        return null;
      }

      if (this['cues'].length === 0) {
        return activeCues; // nothing to do
      }

      var ct = this.tech_.currentTime();
      var active = [];

      for (var i = 0, l = this['cues'].length; i < l; i++) {
        var cue = this['cues'][i];
        if (cue['startTime'] <= ct && cue['endTime'] >= ct) {
          active.push(cue);
        } else if (cue['startTime'] === cue['endTime'] && cue['startTime'] <= ct && cue['startTime'] + 0.5 >= ct) {
          active.push(cue);
        }
      }

      changed = false;

      if (active.length !== this.activeCues_.length) {
        changed = true;
      } else {
        for (var i = 0; i < active.length; i++) {
          if (indexOf.call(this.activeCues_, active[i]) === -1) {
            changed = true;
          }
        }
      }

      this.activeCues_ = active;
      activeCues.setCues_(this.activeCues_);

      return activeCues;
    },
    set: Function.prototype
  });

  if (options.src) {
    loadTrack(options.src, tt);
  } else {
    tt.loaded_ = true;
  }

  if (Lib.IS_IE8) {
    return tt;
  }
};

TextTrack.prototype = Lib.obj.create(_eventEmitter2['default'].prototype);
TextTrack.prototype.constructor = TextTrack;

/*
 * cuechange - One or more cues in the track have become active or stopped being active.
 */
TextTrack.prototype.allowedEvents_ = {
  'cuechange': 'cuechange'
};

TextTrack.prototype.addCue = function (cue) {
  var tracks = this.tech_.textTracks();

  if (tracks) {
    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }
  }

  this.cues_.push(cue);
  this['cues'].setCues_(this.cues_);
};

TextTrack.prototype.removeCue = function (removeCue) {
  var removed = false;

  for (var i = 0, l = this.cues_.length; i < l; i++) {
    var cue = this.cues_[i];
    if (cue === removeCue) {
      this.cues_.splice(i, 1);
      removed = true;
    }
  }

  if (removed) {
    this.cues.setCues_(this.cues_);
  }
};

/*
 * Downloading stuff happens below this point
 */
var parseCues = function parseCues(srcContent, track) {
  if (typeof _globalWindow2['default']['WebVTT'] !== 'function') {
    //try again a bit later
    return _globalWindow2['default'].setTimeout(function () {
      parseCues(srcContent, track);
    }, 25);
  }

  var parser = new _globalWindow2['default']['WebVTT']['Parser'](_globalWindow2['default'], _globalWindow2['default']['vttjs'], _globalWindow2['default']['WebVTT']['StringDecoder']());

  parser['oncue'] = function (cue) {
    track.addCue(cue);
  };
  parser['onparsingerror'] = function (error) {
    Lib.log.error(error);
  };

  parser['parse'](srcContent);
  parser['flush']();
};

var loadTrack = function loadTrack(src, track) {
  _xhrJs2['default'](src, Lib.bind(this, function (err, response, responseBody) {
    if (err) {
      return Lib.log.error(err);
    }

    track.loaded_ = true;
    parseCues(responseBody, track);
  }));
};

var indexOf = function indexOf(searchElement, fromIndex) {
  if (this == null) {
    throw new TypeError('"this" is null or not defined');
  }

  var O = Object(this);

  var len = O.length >>> 0;

  if (len === 0) {
    return -1;
  }

  var n = +fromIndex || 0;

  if (Math.abs(n) === Infinity) {
    n = 0;
  }

  if (n >= len) {
    return -1;
  }

  var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

  while (k < len) {
    if (k in O && O[k] === searchElement) {
      return k;
    }
    k++;
  }
  return -1;
};

exports['default'] = TextTrack;
module.exports = exports['default'];

},{"../event-emitter":42,"../lib":46,"../xhr.js":72,"./text-track-cue-list":64,"./text-track-enums":66,"global/document":1,"global/window":2}],70:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lib = _dereq_('./lib');

/**
 * Utility functions namespace
 * @namespace
 * @type {Object}
 */
var util = {};

/**
 * Merge two options objects, recursively merging any plain object properties as
 * well.  Previously `deepMerge`
 *
 * @param  {Object} obj1 Object to override values in
 * @param  {Object} obj2 Overriding object
 * @return {Object}      New object -- obj1 and obj2 will be untouched
 */
var mergeOptions = function mergeOptions(obj1, obj2) {
  var key, val1, val2;

  // make a copy of obj1 so we're not overwriting original values.
  // like prototype.options_ and all sub options objects
  obj1 = _lib.obj.copy(obj1);

  for (key in obj2) {
    if (obj2.hasOwnProperty(key)) {
      val1 = obj1[key];
      val2 = obj2[key];

      // Check if both properties are pure objects and do a deep merge if so
      if (_lib.obj.isPlain(val1) && _lib.obj.isPlain(val2)) {
        obj1[key] = mergeOptions(val1, val2);
      } else {
        obj1[key] = obj2[key];
      }
    }
  }
  return obj1;
};

exports.mergeOptions = mergeOptions;

},{"./lib":46}],71:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _techLoaderJs = _dereq_('./tech/loader.js');

var _techLoaderJs2 = _interopRequireDefault(_techLoaderJs);

var _techHtml5Js = _dereq_('./tech/html5.js');

var _techHtml5Js2 = _interopRequireDefault(_techHtml5Js);

var _techFlashJs = _dereq_('./tech/flash.js');

var _techFlashJs2 = _interopRequireDefault(_techFlashJs);

var _posterImageJs = _dereq_('./poster-image.js');

var _posterImageJs2 = _interopRequireDefault(_posterImageJs);

var _tracksTextTrackDisplayJs = _dereq_('./tracks/text-track-display.js');

var _tracksTextTrackDisplayJs2 = _interopRequireDefault(_tracksTextTrackDisplayJs);

var _loadingSpinnerJs = _dereq_('./loading-spinner.js');

var _loadingSpinnerJs2 = _interopRequireDefault(_loadingSpinnerJs);

var _bigPlayButtonJs = _dereq_('./big-play-button.js');

var _bigPlayButtonJs2 = _interopRequireDefault(_bigPlayButtonJs);

var _controlBarControlBarJs = _dereq_('./control-bar/control-bar.js');

var _controlBarControlBarJs2 = _interopRequireDefault(_controlBarControlBarJs);

var _errorDisplayJs = _dereq_('./error-display.js');

var _errorDisplayJs2 = _interopRequireDefault(_errorDisplayJs);

var _core = _dereq_('./core');

var _core2 = _interopRequireDefault(_core);

var _setup = _dereq_('./setup');

var setup = _interopRequireWildcard(_setup);

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

var _utilJs = _dereq_('./util.js');

var Util = _interopRequireWildcard(_utilJs);

var _player = _dereq_('./player');

var _player2 = _interopRequireDefault(_player);

var _extendsJs = _dereq_('./extends.js');

var _extendsJs2 = _interopRequireDefault(_extendsJs);

var _pluginsJs = _dereq_('./plugins.js');

var _pluginsJs2 = _interopRequireDefault(_pluginsJs);

var _optionsJs = _dereq_('./options.js');

var _optionsJs2 = _interopRequireDefault(_optionsJs);

if (typeof HTMLVideoElement === 'undefined') {
  _globalDocument2['default'].createElement('video');
  _globalDocument2['default'].createElement('audio');
  _globalDocument2['default'].createElement('track');
}

// Run Auto-load players
// You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)
setup.autoSetupTimeout(1, _core2['default']);

_core2['default'].getComponent = _component2['default'].getComponent;
_core2['default'].registerComponent = _component2['default'].registerComponent;

// APIs that will be removed with 5.0, but need them to get tests passing
// in ES6 transition
_core2['default'].TOUCH_ENABLED = Lib.TOUCH_ENABLED;
_core2['default'].util = Util;

// Probably want to keep this one for 5.0?
_core2['default'].players = _player2['default'].players;

_core2['default']['extends'] = _extendsJs2['default'];

_core2['default'].getGlobalOptions = function () {
  return _optionsJs2['default'];
};
_core2['default'].setGlobalOptions = function (newOptions) {
  Lib.util.mergeOptions(_optionsJs2['default'], newOptions);
};

_core2['default'].plugin = _pluginsJs2['default'];

// REMOVING: We probably should not include this in 5.0 thought it would make it
// more backwards compatible
// // Expose but deprecate the window[componentName] method for accessing components
// Lib.obj.each(Component.components, function(name, component){
//   // A deprecation warning as the constuctor
//   module.exports[name] = function(player, options, ready){
//     Lib.log.warn('Using videojs.'+name+' to access the '+name+' component has been deprecated. Please use videojs.getComponent("componentName")');
//
//     return new Component(player, options, ready);
//   };
//
//   // Allow the prototype and class methods to be accessible still this way
//   // Though anything that attempts to override class methods will no longer work
//   Lib.obj.merge(module.exports[name], component);
// });

exports['default'] = _core2['default'];
module.exports = exports['default'];

},{"./big-play-button.js":5,"./component":7,"./control-bar/control-bar.js":8,"./core":40,"./error-display.js":41,"./extends.js":44,"./lib":46,"./loading-spinner.js":47,"./options.js":52,"./player":53,"./plugins.js":54,"./poster-image.js":55,"./setup":56,"./tech/flash.js":60,"./tech/html5.js":61,"./tech/loader.js":62,"./tracks/text-track-display.js":65,"./util.js":70,"global/document":1}],72:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _util = _dereq_('./util');

var VjsUtils = _interopRequireWildcard(_util);

var _lib = _dereq_('./lib');

var Lib = _interopRequireWildcard(_lib);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

/**
 * Simple http request for retrieving external files (e.g. text tracks)
 *
 * ##### Example
 *
 *     // using url string
 *     videojs.xhr('http://example.com/myfile.vtt', function(error, response, responseBody){});
 *
 *     // or options block
 *     videojs.xhr({
 *       uri: 'http://example.com/myfile.vtt',
 *       method: 'GET',
 *       responseType: 'text'
 *     }, function(error, response, responseBody){
 *       if (error) {
 *         // log the error
 *       } else {
 *         // successful, do something with the response
 *       }
 *     });
 *
 *
 * API is modeled after the Raynos/xhr, which we hope to use after
 * getting browserify implemented.
 * https://github.com/Raynos/xhr/blob/master/index.js
 *
 * @param  {Object|String}  options   Options block or URL string
 * @param  {Function}       callback  The callback function
 * @returns {Object}                  The request
 */
var xhr = function xhr(options, callback) {
  var abortTimeout = undefined;

  // If options is a string it's the url
  if (typeof options === 'string') {
    options = {
      uri: options
    };
  }

  // Merge with default options
  VjsUtils.mergeOptions({
    method: 'GET',
    timeout: 45 * 1000
  }, options);

  callback = callback || function () {};

  var XHR = _globalWindow2['default'].XMLHttpRequest;

  if (typeof XHR === 'undefined') {
    // Shim XMLHttpRequest for older IEs
    XHR = function () {
      try {
        return new _globalWindow2['default'].ActiveXObject('Msxml2.XMLHTTP.6.0');
      } catch (e) {}
      try {
        return new _globalWindow2['default'].ActiveXObject('Msxml2.XMLHTTP.3.0');
      } catch (f) {}
      try {
        return new _globalWindow2['default'].ActiveXObject('Msxml2.XMLHTTP');
      } catch (g) {}
      throw new Error('This browser does not support XMLHttpRequest.');
    };
  }

  var request = new XHR();
  // Store a reference to the url on the request instance
  request.uri = options.uri;

  var urlInfo = Lib.parseUrl(options.uri);
  var winLoc = _globalWindow2['default'].location;

  var successHandler = function successHandler() {
    _globalWindow2['default'].clearTimeout(abortTimeout);
    callback(null, request, request.response || request.responseText);
  };

  var errorHandler = function errorHandler(err) {
    _globalWindow2['default'].clearTimeout(abortTimeout);

    if (!err || typeof err === 'string') {
      err = new Error(err);
    }

    callback(err, request);
  };

  // Check if url is for another domain/origin
  // IE8 doesn't know location.origin, so we won't rely on it here
  var crossOrigin = urlInfo.protocol + urlInfo.host !== winLoc.protocol + winLoc.host;

  // XDomainRequest -- Use for IE if XMLHTTPRequest2 isn't available
  // 'withCredentials' is only available in XMLHTTPRequest2
  // Also XDomainRequest has a lot of gotchas, so only use if cross domain
  if (crossOrigin && _globalWindow2['default'].XDomainRequest && !('withCredentials' in request)) {
    request = new _globalWindow2['default'].XDomainRequest();
    request.onload = successHandler;
    request.onerror = errorHandler;
    // These blank handlers need to be set to fix ie9
    // http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/
    request.onprogress = function () {};
    request.ontimeout = function () {};

    // XMLHTTPRequest
  } else {
    (function () {
      var fileUrl = urlInfo.protocol === 'file:' || winLoc.protocol === 'file:';

      request.onreadystatechange = function () {
        if (request.readyState === 4) {
          if (request.timedout) {
            return errorHandler('timeout');
          }

          if (request.status === 200 || fileUrl && request.status === 0) {
            successHandler();
          } else {
            errorHandler();
          }
        }
      };

      if (options.timeout) {
        abortTimeout = _globalWindow2['default'].setTimeout(function () {
          if (request.readyState !== 4) {
            request.timedout = true;
            request.abort();
          }
        }, options.timeout);
      }
    })();
  }

  // open the connection
  try {
    // Third arg is async, or ignored by XDomainRequest
    request.open(options.method || 'GET', options.uri, true);
  } catch (err) {
    return errorHandler(err);
  }

  // withCredentials only supported by XMLHttpRequest2
  if (options.withCredentials) {
    request.withCredentials = true;
  }

  if (options.responseType) {
    request.responseType = options.responseType;
  }

  // send the request
  try {
    request.send();
  } catch (err) {
    return errorHandler(err);
  }

  return request;
};

exports['default'] = xhr;
module.exports = exports['default'];

},{"./lib":46,"./util":70,"global/window":2}]},{},[71])(71)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzIiwibm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtanNvbi1wYXJzZS90dXBsZS5qcyIsImJpZy1wbGF5LWJ1dHRvbi5qcyIsImJ1dHRvbi5qcyIsImNvbXBvbmVudC5qcyIsImNvbnRyb2wtYmFyL2NvbnRyb2wtYmFyLmpzIiwiY29udHJvbC1iYXIvZnVsbHNjcmVlbi10b2dnbGUuanMiLCJjb250cm9sLWJhci9saXZlLWRpc3BsYXkuanMiLCJjb250cm9sLWJhci9tdXRlLXRvZ2dsZS5qcyIsImNvbnRyb2wtYmFyL3BsYXktdG9nZ2xlLmpzIiwiY29udHJvbC1iYXIvcGxheWJhY2stcmF0ZS1tZW51L3BsYXliYWNrLXJhdGUtbWVudS1idXR0b24uanMiLCJjb250cm9sLWJhci9wbGF5YmFjay1yYXRlLW1lbnUvcGxheWJhY2stcmF0ZS1tZW51LWl0ZW0uanMiLCJjb250cm9sLWJhci9wcm9ncmVzcy1jb250cm9sL2xvYWQtcHJvZ3Jlc3MtYmFyLmpzIiwiY29udHJvbC1iYXIvcHJvZ3Jlc3MtY29udHJvbC9wbGF5LXByb2dyZXNzLWJhci5qcyIsImNvbnRyb2wtYmFyL3Byb2dyZXNzLWNvbnRyb2wvcHJvZ3Jlc3MtY29udHJvbC5qcyIsImNvbnRyb2wtYmFyL3Byb2dyZXNzLWNvbnRyb2wvc2Vlay1iYXIuanMiLCJjb250cm9sLWJhci9wcm9ncmVzcy1jb250cm9sL3NlZWstaGFuZGxlLmpzIiwiY29udHJvbC1iYXIvc3BhY2VyLWNvbnRyb2xzL2N1c3RvbS1jb250cm9sLXNwYWNlci5qcyIsImNvbnRyb2wtYmFyL3NwYWNlci1jb250cm9scy9zcGFjZXIuanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL2NhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzIiwiY29udHJvbC1iYXIvdGV4dC10cmFjay1jb250cm9scy9jYXB0aW9ucy1idXR0b24uanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL2NoYXB0ZXJzLWJ1dHRvbi5qcyIsImNvbnRyb2wtYmFyL3RleHQtdHJhY2stY29udHJvbHMvY2hhcHRlcnMtdHJhY2stbWVudS1pdGVtLmpzIiwiY29udHJvbC1iYXIvdGV4dC10cmFjay1jb250cm9scy9vZmYtdGV4dC10cmFjay1tZW51LWl0ZW0uanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL3N1YnRpdGxlcy1idXR0b24uanMiLCJjb250cm9sLWJhci90ZXh0LXRyYWNrLWNvbnRyb2xzL3RleHQtdHJhY2stYnV0dG9uLmpzIiwiY29udHJvbC1iYXIvdGV4dC10cmFjay1jb250cm9scy90ZXh0LXRyYWNrLW1lbnUtaXRlbS5qcyIsImNvbnRyb2wtYmFyL3RpbWUtY29udHJvbHMvY3VycmVudC10aW1lLWRpc3BsYXkuanMiLCJjb250cm9sLWJhci90aW1lLWNvbnRyb2xzL2R1cmF0aW9uLWRpc3BsYXkuanMiLCJjb250cm9sLWJhci90aW1lLWNvbnRyb2xzL3JlbWFpbmluZy10aW1lLWRpc3BsYXkuanMiLCJjb250cm9sLWJhci90aW1lLWNvbnRyb2xzL3RpbWUtZGl2aWRlci5qcyIsImNvbnRyb2wtYmFyL3ZvbHVtZS1jb250cm9sL3ZvbHVtZS1iYXIuanMiLCJjb250cm9sLWJhci92b2x1bWUtY29udHJvbC92b2x1bWUtY29udHJvbC5qcyIsImNvbnRyb2wtYmFyL3ZvbHVtZS1jb250cm9sL3ZvbHVtZS1oYW5kbGUuanMiLCJjb250cm9sLWJhci92b2x1bWUtY29udHJvbC92b2x1bWUtbGV2ZWwuanMiLCJjb250cm9sLWJhci92b2x1bWUtbWVudS1idXR0b24uanMiLCJjb3JlLW9iamVjdC5qcyIsImNvcmUuanMiLCJlcnJvci1kaXNwbGF5LmpzIiwiZXZlbnQtZW1pdHRlci5qcyIsImV2ZW50cy5qcyIsImV4dGVuZHMuanMiLCJmdWxsc2NyZWVuLWFwaS5qcyIsImxpYi5qcyIsImxvYWRpbmctc3Bpbm5lci5qcyIsIm1lZGlhLWVycm9yLmpzIiwibWVudS9tZW51LWJ1dHRvbi5qcyIsIm1lbnUvbWVudS1pdGVtLmpzIiwibWVudS9tZW51LmpzIiwib3B0aW9ucy5qcyIsInBsYXllci5qcyIsInBsdWdpbnMuanMiLCJwb3N0ZXItaW1hZ2UuanMiLCJzZXR1cC5qcyIsInNsaWRlci9zbGlkZXItaGFuZGxlLmpzIiwic2xpZGVyL3NsaWRlci5qcyIsInRlY2gvZmxhc2gtcnRtcC5qcyIsInRlY2gvZmxhc2guanMiLCJ0ZWNoL2h0bWw1LmpzIiwidGVjaC9sb2FkZXIuanMiLCJ0ZWNoL3RlY2guanMiLCJ0cmFja3MvdGV4dC10cmFjay1jdWUtbGlzdC5qcyIsInRyYWNrcy90ZXh0LXRyYWNrLWRpc3BsYXkuanMiLCJ0cmFja3MvdGV4dC10cmFjay1lbnVtcy5qcyIsInRyYWNrcy90ZXh0LXRyYWNrLWxpc3QuanMiLCJ0cmFja3MvdGV4dC10cmFjay1zZXR0aW5ncy5qcyIsInRyYWNrcy90ZXh0LXRyYWNrLmpzIiwidXRpbC5qcyIsInZpZGVvLmpzIiwieGhyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QU87TUFBRSxLQUFLLGdDQUFDLE9BQU87c0JBQUU7QUFDaEQsUUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDakMsUUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQ3RDLFFBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ25DLFFBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUN2QyxRQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQzs7O0FBR3BDLFFBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLE9BQU8sS0FBSyxRQUFRLEVBQUU7OztBQUcxQyxPQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7S0FDakI7OztBQUdELEtBQUMsR0FBRyxBQUFDLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsR0FBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQzs7OztBQUlyQyxLQUFDLEdBQUcsQ0FBQyxBQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUEsSUFBSyxDQUFDLEdBQUcsRUFBRSxHQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBLEdBQUksR0FBRyxDQUFDOzs7QUFHdEQsS0FBQyxHQUFHLEFBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFFM0IsV0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztHQUNsQjtDQUFBLENBQUM7OztBQUdGLElBQUksa0JBQWtCLEdBQUcsU0FBckIsa0JBQWtCLEdBQWE7QUFDakMsOEJB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QUksRUFBRSxZQUFXO0FBQ3hGLFVBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUNwQixVQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDYixDQUFDLENBQUMsQ0FBQzs7QUFFSixVQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMscUJBQXFCLENBQUMsRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsWUFBVztBQUMzRixVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNwRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNwRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNwRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDRCQUE0QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN4RSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDBCQUEwQixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN0RSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDhCQUE4QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUMxRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNwRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHlCQUF5QixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUNyRSxVQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDBCQUEwQixDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN0RSxVQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7S0FDdEIsQ0FBQyxDQUFDLENBQUM7O0FBRUosVUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0FBQzNHLFVBQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUMzRyxVQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsd0JBQXdCLENBQUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDM0csVUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLDRCQUE0QixDQUFDLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0FBQy9HLFVBQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUM3RyxVQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsOEJBQThCLENBQUMsRUFBRSxRQUFRLEVBQUUs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Um9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIHRvcExldmVsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge31cbnZhciBtaW5Eb2MgPSByZXF1aXJlKCdtaW4tZG9jdW1lbnQnKTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50O1xufSBlbHNlIHtcbiAgICB2YXIgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddO1xuXG4gICAgaWYgKCFkb2NjeSkge1xuICAgICAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J10gPSBtaW5Eb2M7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkb2NjeTtcbn1cbiIsImlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7fTtcbn1cbiIsbnVsbCwibW9kdWxlLmV4cG9ydHMgPSBTYWZlUGFyc2VUdXBsZVxuXG5mdW5jdGlvbiBTYWZlUGFyc2VUdXBsZShvYmosIHJldml2ZXIpIHtcbiAgICB2YXIganNvblxuICAgIHZhciBlcnJvciA9IG51bGxcblxuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKG9iaiwgcmV2aXZlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG5cbiAgICByZXR1cm4gW2Vycm9yLCBqc29uXVxufVxuIiwiaW1wb3J0IEJ1dHRvbiBmcm9tICcuL2J1dHRvbic7XG5cbi8qIEJpZyBQbGF5IEJ1dHRvblxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogSW5pdGlhbCBwbGF5IGJ1dHRvbi4gU2hvd3MgYmVmb3JlIHRoZSB2aWRlbyBoYXMgcGxheWVkLiBUaGUgaGlkaW5nIG9mIHRoZVxuICogYmlnIHBsYXkgYnV0dG9uIGlzIGRvbmUgdmlhIENTUyBhbmQgcGxheWVyIHN0YXRlcy5cbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEJpZ1BsYXlCdXR0b24gZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWJpZy1wbGF5LWJ1dHRvbicsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+JyxcbiAgICAgICdhcmlhLWxhYmVsJzogJ3BsYXkgdmlkZW8nXG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLnBsYXllcl8ucGxheSgpO1xuICB9XG5cbn1cblxuQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdCaWdQbGF5QnV0dG9uJywgQmlnUGxheUJ1dHRvbik7XG5leHBvcnQgZGVmYXVsdCBCaWdQbGF5QnV0dG9uO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudCc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi9saWInO1xuaW1wb3J0ICogYXMgRXZlbnRzIGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuXG4vKiBCdXR0b24gLSBCYXNlIGNsYXNzIGZvciBhbGwgYnV0dG9uc1xuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJ1dHRvbnNcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEJ1dHRvbiBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMuZW1pdFRhcEV2ZW50cygpO1xuXG4gICAgdGhpcy5vbigndGFwJywgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgdGhpcy5vbignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICB9XG5cbiAgY3JlYXRlRWwodHlwZSwgcHJvcHMpIHtcbiAgICAvLyBBZGQgc3RhbmRhcmQgQXJpYSBhbmQgVGFiaW5kZXggaW5mb1xuICAgIHByb3BzID0gTGliLm9iai5tZXJnZSh7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxuICAgICAgJ3JvbGUnOiAnYnV0dG9uJyxcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJywgLy8gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIHVzZXIga25vdyB0aGF0IHRoZSB0ZXh0IG9mIHRoZSBidXR0b24gbWF5IGNoYW5nZVxuICAgICAgdGFiSW5kZXg6IDBcbiAgICB9LCBwcm9wcyk7XG5cbiAgICBsZXQgZWwgPSBzdXBlci5jcmVhdGVFbCh0eXBlLCBwcm9wcyk7XG5cbiAgICAvLyBpZiBpbm5lckhUTUwgaGFzbid0IGJlZW4gb3ZlcnJpZGRlbiAoYmlnUGxheUJ1dHRvbiksIGFkZCBjb250ZW50IGVsZW1lbnRzXG4gICAgaWYgKCFwcm9wcy5pbm5lckhUTUwpIHtcbiAgICAgIHRoaXMuY29udGVudEVsXyA9IExpYi5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC1jb250ZW50J1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY29udHJvbFRleHRfID0gTGliLmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC10ZXh0JyxcbiAgICAgICAgaW5uZXJIVE1MOiB0aGlzLmxvY2FsaXplKHRoaXMuYnV0dG9uVGV4dCkgfHwgJ05lZWQgVGV4dCdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNvbnRlbnRFbF8uYXBwZW5kQ2hpbGQodGhpcy5jb250cm9sVGV4dF8pO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiBgdmpzLWNvbnRyb2wgdmpzLWJ1dHRvbiAke3N1cGVyLmJ1aWxkQ1NTQ2xhc3MoKX1gO1xuICB9XG5cbiAgLy8gQ2xpY2sgLSBPdmVycmlkZSB3aXRoIHNwZWNpZmljIGZ1bmN0aW9uYWxpdHkgZm9yIGJ1dHRvblxuICBoYW5kbGVDbGljaygpIHt9XG5cbiAgLy8gRm9jdXMgLSBBZGQga2V5Ym9hcmQgZnVuY3Rpb25hbGl0eSB0byBlbGVtZW50XG4gIGhhbmRsZUZvY3VzKCkge1xuICAgIEV2ZW50cy5vbihkb2N1bWVudCwgJ2tleWRvd24nLCBMaWIuYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gIH1cblxuICAvLyBLZXlQcmVzcyAoZG9jdW1lbnQgbGV2ZWwpIC0gVHJpZ2dlciBjbGljayB3aGVuIGtleXMgYXJlIHByZXNzZWRcbiAgaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcbiAgICAvLyBDaGVjayBmb3Igc3BhY2UgYmFyICgzMikgb3IgZW50ZXIgKDEzKSBrZXlzXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzMiB8fCBldmVudC53aGljaCA9PT0gMTMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmhhbmRsZUNsaWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQmx1ciAtIFJlbW92ZSBrZXlib2FyZCB0cmlnZ2Vyc1xuICBoYW5kbGVCbHVyKCkge1xuICAgIEV2ZW50cy5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgTGliLmJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9XG5cbn1cblxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0J1dHRvbicsIEJ1dHRvbik7XG5leHBvcnQgZGVmYXVsdCBCdXR0b247XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUGxheWVyIENvbXBvbmVudCAtIEJhc2UgY2xhc3MgZm9yIGFsbCBVSSBvYmplY3RzXG4gKlxuICovXG5cbmltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYi5qcyc7XG5pbXBvcnQgKiBhcyBWanNVdGlsIGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBFdmVudHMgZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxuLyoqXG4gKiBCYXNlIFVJIENvbXBvbmVudCBjbGFzc1xuICpcbiAqIENvbXBvbmVudHMgYXJlIGVtYmVkZGFibGUgVUkgb2JqZWN0cyB0aGF0IGFyZSByZXByZXNlbnRlZCBieSBib3RoIGFcbiAqIGphdmFzY3JpcHQgb2JqZWN0IGFuZCBhbiBlbGVtZW50IGluIHRoZSBET00uIFRoZXkgY2FuIGJlIGNoaWxkcmVuIG9mIG90aGVyXG4gKiBjb21wb25lbnRzLCBhbmQgY2FuIGhhdmUgbWFueSBjaGlsZHJlbiB0aGVtc2VsdmVzLlxuICpcbiAqICAgICAvLyBhZGRpbmcgYSBidXR0b24gdG8gdGhlIHBsYXllclxuICogICAgIHZhciBidXR0b24gPSBwbGF5ZXIuYWRkQ2hpbGQoJ2J1dHRvbicpO1xuICogICAgIGJ1dHRvbi5lbCgpOyAvLyAtPiBidXR0b24gZWxlbWVudFxuICpcbiAqICAgICA8ZGl2IGNsYXNzPVwidmlkZW8tanNcIj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJ2anMtYnV0dG9uXCI+QnV0dG9uPC9kaXY+XG4gKiAgICAgPC9kaXY+XG4gKlxuICogQ29tcG9uZW50cyBhcmUgYWxzbyBldmVudCBlbWl0dGVycy5cbiAqXG4gKiAgICAgYnV0dG9uLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gKiAgICAgICBjb25zb2xlLmxvZygnQnV0dG9uIENsaWNrZWQhJyk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGJ1dHRvbi50cmlnZ2VyKCdjdXN0b21ldmVudCcpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5ZXIgIE1haW4gUGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuXG4gICAgLy8gVGhlIGNvbXBvbmVudCBtaWdodCBiZSB0aGUgcGxheWVyIGl0c2VsZiBhbmQgd2UgY2FuJ3QgcGFzcyBgdGhpc2AgdG8gc3VwZXJcbiAgICBpZiAoIXBsYXllciAmJiB0aGlzLnBsYXkpIHtcbiAgICAgIHRoaXMucGxheWVyXyA9IHBsYXllciA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfID0gcGxheWVyO1xuICAgIH1cblxuICAgIC8vIE1ha2UgYSBjb3B5IG9mIHByb3RvdHlwZS5vcHRpb25zXyB0byBwcm90ZWN0IGFnYWluc3Qgb3ZlcnJpZGluZyBnbG9iYWwgZGVmYXVsdHNcbiAgICB0aGlzLm9wdGlvbnNfID0gTGliLm9iai5jb3B5KHRoaXMub3B0aW9uc18pO1xuXG4gICAgLy8gVXBkYXRlZCBvcHRpb25zIHdpdGggc3VwcGxpZWQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgSUQgZnJvbSBvcHRpb25zIG9yIG9wdGlvbnMgZWxlbWVudCBpZiBvbmUgaXMgc3VwcGxpZWRcbiAgICB0aGlzLmlkXyA9IG9wdGlvbnMuaWQgfHwgKG9wdGlvbnMuZWwgJiYgb3B0aW9ucy5lbC5pZCk7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgbm8gSUQgZnJvbSB0aGUgb3B0aW9ucywgZ2VuZXJhdGUgb25lXG4gICAgaWYgKCF0aGlzLmlkXykge1xuICAgICAgLy8gRG9uJ3QgcmVxdWlyZSB0aGUgcGxheWVyIElEIGZ1bmN0aW9uIGluIHRoZSBjYXNlIG9mIG1vY2sgcGxheWVyc1xuICAgICAgbGV0IGlkID0gcGxheWVyICYmIHBsYXllci5pZCAmJiBwbGF5ZXIuaWQoKSB8fCAnbm9fcGxheWVyJztcbiAgICAgIHRoaXMuaWRfID0gYCR7aWR9X2NvbXBvbmVudF8ke0xpYi5ndWlkKyt9YDtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWVfID0gb3B0aW9ucy5uYW1lIHx8IG51bGw7XG5cbiAgICAvLyBDcmVhdGUgZWxlbWVudCBpZiBvbmUgd2Fzbid0IHByb3ZpZGVkIGluIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5lbCkge1xuICAgICAgdGhpcy5lbF8gPSBvcHRpb25zLmVsO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jcmVhdGVFbCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZWxfID0gdGhpcy5jcmVhdGVFbCgpO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5fID0gW107XG4gICAgdGhpcy5jaGlsZEluZGV4XyA9IHt9O1xuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfID0ge307XG5cbiAgICAvLyBBZGQgYW55IGNoaWxkIGNvbXBvbmVudHMgaW4gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmluaXRDaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaW5pdENoaWxkcmVuKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeShyZWFkeSk7XG4gICAgLy8gRG9uJ3Qgd2FudCB0byB0cmlnZ2VyIHJlYWR5IGhlcmUgb3IgaXQgd2lsbCBiZWZvcmUgaW5pdCBpcyBhY3R1YWxseVxuICAgIC8vIGZpbmlzaGVkIGZvciBhbGwgY2hpbGRyZW4gdGhhdCBydW4gdGhpcyBjb25zdHJ1Y3RvclxuXG4gICAgaWYgKG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZW5hYmxlVG91Y2hBY3Rpdml0eSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRlbXAgZm9yIEVTNiBjbGFzcyB0cmFuc2l0aW9uLCByZW1vdmUgYmVmb3JlIDUuMFxuICBpbml0KCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdpbml0IGNhbGxlZCBvbiBDb21wb25lbnQnKTtcbiAgICBDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBjb21wb25lbnQgYW5kIGFsbCBjaGlsZCBjb21wb25lbnRzXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICdkaXNwb3NlJywgYnViYmxlczogZmFsc2UgfSk7XG5cbiAgICAvLyBEaXNwb3NlIGFsbCBjaGlsZHJlbi5cbiAgICBpZiAodGhpcy5jaGlsZHJlbl8pIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuXy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl9baV0uZGlzcG9zZSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5fW2ldLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlbGV0ZSBjaGlsZCByZWZlcmVuY2VzXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgIHRoaXMuY2hpbGRJbmRleF8gPSBudWxsO1xuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfID0gbnVsbDtcblxuICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuICAgIHRoaXMub2ZmKCk7XG5cbiAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIERPTVxuICAgIGlmICh0aGlzLmVsXy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmVsXy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxfKTtcbiAgICB9XG5cbiAgICBMaWIucmVtb3ZlRGF0YSh0aGlzLmVsXyk7XG4gICAgdGhpcy5lbF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29tcG9uZW50J3MgcGxheWVyXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICovXG4gIHBsYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZXAgbWVyZ2Ugb2Ygb3B0aW9ucyBvYmplY3RzXG4gICAqXG4gICAqIFdoZW5ldmVyIGEgcHJvcGVydHkgaXMgYW4gb2JqZWN0IG9uIGJvdGggb3B0aW9ucyBvYmplY3RzXG4gICAqIHRoZSB0d28gcHJvcGVydGllcyB3aWxsIGJlIG1lcmdlZCB1c2luZyBMaWIub2JqLmRlZXBNZXJnZS5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIGZvciBtZXJnaW5nIG9wdGlvbnMgZm9yIGNoaWxkIGNvbXBvbmVudHMuIFdlXG4gICAqIHdhbnQgaXQgdG8gYmUgZWFzeSB0byBvdmVycmlkZSBpbmRpdmlkdWFsIG9wdGlvbnMgb24gYSBjaGlsZFxuICAgKiBjb21wb25lbnQgd2l0aG91dCBoYXZpbmcgdG8gcmV3cml0ZSBhbGwgdGhlIG90aGVyIGRlZmF1bHQgb3B0aW9ucy5cbiAgICpcbiAgICogICAgIFBhcmVudC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gICAqICAgICAgIGNoaWxkcmVuOiB7XG4gICAqICAgICAgICAgJ2NoaWxkT25lJzogeyAnZm9vJzogJ2JhcicsICdhc2RmJzogJ2Zkc2EnIH0sXG4gICAqICAgICAgICAgJ2NoaWxkVHdvJzoge30sXG4gICAqICAgICAgICAgJ2NoaWxkVGhyZWUnOiB7fVxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgICBuZXdPcHRpb25zID0ge1xuICAgKiAgICAgICBjaGlsZHJlbjoge1xuICAgKiAgICAgICAgICdjaGlsZE9uZSc6IHsgJ2Zvbyc6ICdiYXonLCAnYWJjJzogJzEyMycgfVxuICAgKiAgICAgICAgICdjaGlsZFR3byc6IG51bGwsXG4gICAqICAgICAgICAgJ2NoaWxkRm91cic6IHt9XG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICpcbiAgICogICAgIHRoaXMub3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICpcbiAgICogUkVTVUxUXG4gICAqXG4gICAqICAgICB7XG4gICAqICAgICAgIGNoaWxkcmVuOiB7XG4gICAqICAgICAgICAgJ2NoaWxkT25lJzogeyAnZm9vJzogJ2JheicsICdhc2RmJzogJ2Zkc2EnLCAnYWJjJzogJzEyMycgfSxcbiAgICogICAgICAgICAnY2hpbGRUd28nOiBudWxsLCAvLyBEaXNhYmxlZC4gV29uJ3QgYmUgaW5pdGlhbGl6ZWQuXG4gICAqICAgICAgICAgJ2NoaWxkVGhyZWUnOiB7fSxcbiAgICogICAgICAgICAnY2hpbGRGb3VyJzoge31cbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBPYmplY3Qgb2YgbmV3IG9wdGlvbiB2YWx1ZXNcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgQSBORVcgb2JqZWN0IG9mIHRoaXMub3B0aW9uc18gYW5kIG9iaiBtZXJnZWRcbiAgICovXG4gIG9wdGlvbnMob2JqKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9uc18gPSBWanNVdGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfLCBvYmopO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogICAgIHZhciBkb21FbCA9IG15Q29tcG9uZW50LmVsKCk7XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF87XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmc9fSB0YWdOYW1lICBFbGVtZW50J3Mgbm9kZSB0eXBlLiBlLmcuICdkaXYnXG4gICAqIEBwYXJhbSAge09iamVjdD19IGF0dHJpYnV0ZXMgQW4gb2JqZWN0IG9mIGVsZW1lbnQgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGNyZWF0ZUVsKHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gTGliLmNyZWF0ZUVsKHRhZ05hbWUsIGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgbG9jYWxpemUoc3RyaW5nKSB7XG4gICAgbGV0IGxhbmcgPSB0aGlzLnBsYXllcl8ubGFuZ3VhZ2UoKTtcbiAgICBsZXQgbGFuZ3VhZ2VzID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlcygpO1xuXG4gICAgaWYgKGxhbmd1YWdlcyAmJiBsYW5ndWFnZXNbbGFuZ10gJiYgbGFuZ3VhZ2VzW2xhbmddW3N0cmluZ10pIHtcbiAgICAgIHJldHVybiBsYW5ndWFnZXNbbGFuZ11bc3RyaW5nXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnQgd2hlcmUgY2hpbGRyZW4gYXJlIGluc2VydGVkLlxuICAgKiBXaWxsIGVpdGhlciBiZSB0aGUgc2FtZSBhcyBlbCgpIG9yIGEgbmV3IGVsZW1lbnQgZGVmaW5lZCBpbiBjcmVhdGVFbCgpLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgY29udGVudEVsKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbF8gfHwgdGhpcy5lbF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wb25lbnQncyBJRFxuICAgKlxuICAgKiAgICAgdmFyIGlkID0gbXlDb21wb25lbnQuaWQoKTtcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcG9uZW50J3MgbmFtZS4gVGhlIG5hbWUgaXMgb2Z0ZW4gdXNlZCB0byByZWZlcmVuY2UgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogICAgIHZhciBuYW1lID0gbXlDb21wb25lbnQubmFtZSgpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiBhbGwgY2hpbGQgY29tcG9uZW50c1xuICAgKlxuICAgKiAgICAgdmFyIGtpZHMgPSBteUNvbXBvbmVudC5jaGlsZHJlbigpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGNoaWxkcmVuXG4gICAqL1xuICBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNoaWxkIGNvbXBvbmVudCB3aXRoIHRoZSBwcm92aWRlZCBJRFxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBnZXRDaGlsZEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZEluZGV4X1tpZF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNoaWxkIGNvbXBvbmVudCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIGdldENoaWxkKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZE5hbWVJbmRleF9bbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoaWxkIGNvbXBvbmVudCBpbnNpZGUgdGhpcyBjb21wb25lbnRcbiAgICpcbiAgICogICAgIG15Q29tcG9uZW50LmVsKCk7XG4gICAqICAgICAvLyAtPiA8ZGl2IGNsYXNzPSdteS1jb21wb25lbnQnPjwvZGl2PlxuICAgKiAgICAgbXlDb21wb25lbnQuY2hpbGRyZW4oKTtcbiAgICogICAgIC8vIFtlbXB0eSBhcnJheV1cbiAgICpcbiAgICogICAgIHZhciBteUJ1dHRvbiA9IG15Q29tcG9uZW50LmFkZENoaWxkKCdNeUJ1dHRvbicpO1xuICAgKiAgICAgLy8gLT4gPGRpdiBjbGFzcz0nbXktY29tcG9uZW50Jz48ZGl2IGNsYXNzPVwibXktYnV0dG9uXCI+bXlCdXR0b248ZGl2PjwvZGl2PlxuICAgKiAgICAgLy8gLT4gbXlCdXR0b24gPT09IG15Q29tb25lbnQuY2hpbGRyZW4oKVswXTtcbiAgICpcbiAgICogUGFzcyBpbiBvcHRpb25zIGZvciBjaGlsZCBjb25zdHJ1Y3RvcnMgYW5kIG9wdGlvbnMgZm9yIGNoaWxkcmVuIG9mIHRoZSBjaGlsZFxuICAgKlxuICAgKiAgICAgdmFyIG15QnV0dG9uID0gbXlDb21wb25lbnQuYWRkQ2hpbGQoJ015QnV0dG9uJywge1xuICAgKiAgICAgICB0ZXh0OiAnUHJlc3MgTWUnLFxuICAgKiAgICAgICBjaGlsZHJlbjoge1xuICAgKiAgICAgICAgIGJ1dHRvbkNoaWxkRXhhbXBsZToge1xuICAgKiAgICAgICAgICAgYnV0dG9uQ2hpbGRPcHRpb246IHRydWVcbiAgICogICAgICAgICB9XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xDb21wb25lbnR9IGNoaWxkIFRoZSBjbGFzcyBuYW1lIG9yIGluc3RhbmNlIG9mIGEgY2hpbGQgdG8gYWRkXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zLCBpbmNsdWRpbmcgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gY2hpbGRyZW4gb2YgdGhlIGNoaWxkLlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9IFRoZSBjaGlsZCBjb21wb25lbnQgKGNyZWF0ZWQgYnkgdGhpcyBwcm9jZXNzIGlmIGEgc3RyaW5nIHdhcyB1c2VkKVxuICAgKiBAc3VwcHJlc3Mge2FjY2Vzc0NvbnRyb2xzfGNoZWNrUmVnRXhwfGNoZWNrVHlwZXN8Y2hlY2tWYXJzfGNvbnN0fGNvbnN0YW50UHJvcGVydHl8ZGVwcmVjYXRlZHxkdXBsaWNhdGV8ZXM1U3RyaWN0fGZpbGVvdmVydmlld1RhZ3N8Z2xvYmFsVGhpc3xpbnZhbGlkQ2FzdHN8bWlzc2luZ1Byb3BlcnRpZXN8bm9uU3RhbmRhcmRKc0RvY3N8c3RyaWN0TW9kdWxlRGVwQ2hlY2t8dW5kZWZpbmVkTmFtZXN8dW5kZWZpbmVkVmFyc3x1bmtub3duRGVmaW5lc3x1c2VsZXNzQ29kZXx2aXNpYmlsaXR5fVxuICAgKi9cbiAgYWRkQ2hpbGQoY2hpbGQsIG9wdGlvbnM9e30pIHtcbiAgICBsZXQgY29tcG9uZW50O1xuICAgIGxldCBjb21wb25lbnROYW1lO1xuXG4gICAgLy8gSWYgY2hpbGQgaXMgYSBzdHJpbmcsIGNyZWF0ZSBudCB3aXRoIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNoaWxkO1xuXG4gICAgICAvLyBPcHRpb25zIGNhbiBhbHNvIGJlIHNwZWNpZmllZCBhcyBhIGJvb2xlYW4sIHNvIGNvbnZlcnQgdG8gYW4gZW1wdHkgb2JqZWN0IGlmIGZhbHNlLlxuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IHRydWUgaXMgZGVwcmVjYXRlZCBzbyBzaG93IGEgd2FybmluZy5cbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIExpYi5sb2cud2FybignSW5pdGlhbGl6aW5nIGEgY2hpbGQgY29tcG9uZW50IHdpdGggYHRydWVgIGlzIGRlcHJlY2F0ZWQuIENoaWxkcmVuIHNob3VsZCBiZSBkZWZpbmVkIGluIGFuIGFycmF5IHdoZW4gcG9zc2libGUsIGJ1dCBpZiBuZWNlc3NhcnkgdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGB0cnVlYC4nKTtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBjb21wb25lbnRDbGFzcyBpbiBvcHRpb25zLCBhc3N1bWUgY29tcG9uZW50Q2xhc3MgaXMgdGhlIG5hbWUgbG93ZXJjYXNlZFxuICAgICAgLy8gKGUuZy4gcGxheUJ1dHRvbilcbiAgICAgIGxldCBjb21wb25lbnRDbGFzc05hbWUgPSBvcHRpb25zLmNvbXBvbmVudENsYXNzIHx8IExpYi5jYXBpdGFsaXplKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAvLyBTZXQgbmFtZSB0aHJvdWdoIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMubmFtZSA9IGNvbXBvbmVudE5hbWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgJiBlbGVtZW50IGZvciB0aGlzIGNvbnRyb2xzIHNldFxuICAgICAgLy8gSWYgdGhlcmUncyBubyAucGxheWVyXywgdGhpcyBpcyBhIHBsYXllclxuICAgICAgbGV0IENvbXBvbmVudENsYXNzID0gQ29tcG9uZW50LmdldENvbXBvbmVudChjb21wb25lbnRDbGFzc05hbWUpO1xuXG4gICAgICBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50Q2xhc3ModGhpcy5wbGF5ZXJfIHx8IHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hpbGQgaXMgYSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50ID0gY2hpbGQ7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbl8ucHVzaChjb21wb25lbnQpO1xuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuaWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gY29tcG9uZW50O1xuICAgIH1cblxuICAgIC8vIElmIGEgbmFtZSB3YXNuJ3QgdXNlZCB0byBjcmVhdGUgdGhlIGNvbXBvbmVudCwgY2hlY2sgaWYgd2UgY2FuIHVzZSB0aGVcbiAgICAvLyBuYW1lIGZ1bmN0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCAoY29tcG9uZW50Lm5hbWUgJiYgY29tcG9uZW50Lm5hbWUoKSk7XG5cbiAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50TmFtZV0gPSBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBVSSBvYmplY3QncyBlbGVtZW50IHRvIHRoZSBjb250YWluZXIgZGl2IChib3gpXG4gICAgLy8gSGF2aW5nIGFuIGVsZW1lbnQgaXMgbm90IHJlcXVpcmVkXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuZWwgPT09ICdmdW5jdGlvbicgJiYgY29tcG9uZW50LmVsKCkpIHtcbiAgICAgIHRoaXMuY29udGVudEVsKCkuYXBwZW5kQ2hpbGQoY29tcG9uZW50LmVsKCkpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBzbyBpdCBjYW4gc3RvcmVkIG9uIHBhcmVudCBvYmplY3QgaWYgZGVzaXJlZC5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNoaWxkIGNvbXBvbmVudCBmcm9tIHRoaXMgY29tcG9uZW50J3MgbGlzdCBvZiBjaGlsZHJlbiwgYW5kIHRoZVxuICAgKiBjaGlsZCBjb21wb25lbnQncyBlbGVtZW50IGZyb20gdGhpcyBjb21wb25lbnQncyBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSAge0NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUNoaWxkKGNvbXBvbmVudCkge1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXRDaGlsZChjb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmICghY29tcG9uZW50IHx8ICF0aGlzLmNoaWxkcmVuXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjaGlsZEZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXSA9PT0gY29tcG9uZW50KSB7XG4gICAgICAgIGNoaWxkRm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuXy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hpbGRGb3VuZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4X1tjb21wb25lbnQubmFtZSgpXSA9IG51bGw7XG5cbiAgICBsZXQgY29tcEVsID0gY29tcG9uZW50LmVsKCk7XG5cbiAgICBpZiAoY29tcEVsICYmIGNvbXBFbC5wYXJlbnROb2RlID09PSB0aGlzLmNvbnRlbnRFbCgpKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLnJlbW92ZUNoaWxkKGNvbXBvbmVudC5lbCgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuZCBpbml0aWFsaXplIGRlZmF1bHQgY2hpbGQgY29tcG9uZW50cyBmcm9tIG9wdGlvbnNcbiAgICpcbiAgICogICAgIC8vIHdoZW4gYW4gaW5zdGFuY2Ugb2YgTXlDb21wb25lbnQgaXMgY3JlYXRlZCwgYWxsIGNoaWxkcmVuIGluIG9wdGlvbnNcbiAgICogICAgIC8vIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGluc3RhbmNlIGJ5IHRoZWlyIG5hbWUgc3RyaW5ncyBhbmQgb3B0aW9uc1xuICAgKiAgICAgTXlDb21wb25lbnQucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuID0ge1xuICAgKiAgICAgICBteUNoaWxkQ29tcG9uZW50OiB7XG4gICAqICAgICAgICAgbXlDaGlsZE9wdGlvbjogdHJ1ZVxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICAvLyBPciB3aGVuIGNyZWF0aW5nIHRoZSBjb21wb25lbnRcbiAgICogICAgIHZhciBteUNvbXAgPSBuZXcgTXlDb21wb25lbnQocGxheWVyLCB7XG4gICAqICAgICAgIGNoaWxkcmVuOiB7XG4gICAqICAgICAgICAgbXlDaGlsZENvbXBvbmVudDoge1xuICAgKiAgICAgICAgICAgbXlDaGlsZE9wdGlvbjogdHJ1ZVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfVxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIFRoZSBjaGlsZHJlbiBvcHRpb24gY2FuIGFsc28gYmUgYW4gQXJyYXkgb2YgY2hpbGQgbmFtZXMgb3JcbiAgICogY2hpbGQgb3B0aW9ucyBvYmplY3RzICh0aGF0IGFsc28gaW5jbHVkZSBhICduYW1lJyBrZXkpLlxuICAgKlxuICAgKiAgICAgdmFyIG15Q29tcCA9IG5ldyBNeUNvbXBvbmVudChwbGF5ZXIsIHtcbiAgICogICAgICAgY2hpbGRyZW46IFtcbiAgICogICAgICAgICAnYnV0dG9uJyxcbiAgICogICAgICAgICB7XG4gICAqICAgICAgICAgICBuYW1lOiAnYnV0dG9uJyxcbiAgICogICAgICAgICAgIHNvbWVPdGhlck9wdGlvbjogdHJ1ZVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqL1xuICBpbml0Q2hpbGRyZW4oKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5vcHRpb25zXy5jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgLy8gYHRoaXNgIGlzIGBwYXJlbnRgXG4gICAgICBsZXQgcGFyZW50T3B0aW9ucyA9IHRoaXMub3B0aW9ucygpO1xuICAgICAgbGV0IGhhbmRsZUFkZCA9IChuYW1lLCBvcHRzKSA9PiB7XG4gICAgICAgIC8vIEFsbG93IG9wdGlvbnMgZm9yIGNoaWxkcmVuIHRvIGJlIHNldCBhdCB0aGUgcGFyZW50IG9wdGlvbnNcbiAgICAgICAgLy8gZS5nLiB2aWRlb2pzKGlkLCB7IGNvbnRyb2xCYXI6IGZhbHNlIH0pO1xuICAgICAgICAvLyBpbnN0ZWFkIG9mIHZpZGVvanMoaWQsIHsgY2hpbGRyZW46IHsgY29udHJvbEJhcjogZmFsc2UgfSk7XG4gICAgICAgIGlmIChwYXJlbnRPcHRpb25zW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRzID0gcGFyZW50T3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IGZvciBkaXNhYmxpbmcgZGVmYXVsdCBjb21wb25lbnRzXG4gICAgICAgIC8vIGUuZy4gb3B0aW9uc1snY2hpbGRyZW4nXVsncG9zdGVySW1hZ2UnXSA9IGZhbHNlXG4gICAgICAgIGlmIChvcHRzID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAgIC8vIEFkZCBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIGNoaWxkIGJ5IG5hbWUgb24gdGhlIHBhcmVudCBpbnN0YW5jZS5cbiAgICAgICAgLy8gSWYgdHdvIG9mIHRoZSBzYW1lIGNvbXBvbmVudCBhcmUgdXNlZCwgZGlmZmVyZW50IG5hbWVzIHNob3VsZCBiZSBzdXBwbGllZFxuICAgICAgICAvLyBmb3IgZWFjaFxuICAgICAgICB0aGlzW25hbWVdID0gdGhpcy5hZGRDaGlsZChuYW1lLCBvcHRzKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEFsbG93IGZvciBhbiBhcnJheSBvZiBjaGlsZHJlbiBkZXRhaWxzIHRvIHBhc3NlZCBpbiB0aGUgb3B0aW9uc1xuICAgICAgaWYgKExpYi5vYmouaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGxldCBuYW1lO1xuICAgICAgICAgIGxldCBvcHRzO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFsnbXlDb21wb25lbnQnXVxuICAgICAgICAgICAgbmFtZSA9IGNoaWxkO1xuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBbeyBuYW1lOiAnbXlDb21wb25lbnQnLCBvdGhlck9wdGlvbjogdHJ1ZSB9XVxuICAgICAgICAgICAgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgICAgICBvcHRzID0gY2hpbGQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlQWRkKG5hbWUsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMaWIub2JqLmVhY2goY2hpbGRyZW4sIGhhbmRsZUFkZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBzdWIgY29tcG9uZW50cyB0byBzdGFjayBDU1MgY2xhc3MgbmFtZXNcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgY2xhc3MgbmFtZVxuICAgKi9cbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICAvLyBDaGlsZCBjbGFzc2VzIGNhbiBpbmNsdWRlIGEgZnVuY3Rpb24gdGhhdCBkb2VzOlxuICAgIC8vIHJldHVybiAnQ0xBU1MgTkFNRScgKyB0aGlzLl9zdXBlcigpO1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhpcyBjb21wb25lbnQncyBlbGVtZW50XG4gICAqXG4gICAqICAgICB2YXIgbXlGdW5jID0gZnVuY3Rpb24oKXtcbiAgICogICAgICAgdmFyIG15Q29tcG9uZW50ID0gdGhpcztcbiAgICogICAgICAgLy8gRG8gc29tZXRoaW5nIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkXG4gICAqICAgICB9O1xuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub24oJ2V2ZW50VHlwZScsIG15RnVuYyk7XG4gICAqXG4gICAqIFRoZSBjb250ZXh0IG9mIG15RnVuYyB3aWxsIGJlIG15Q29tcG9uZW50IHVubGVzcyBwcmV2aW91c2x5IGJvdW5kLlxuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIGFkZCBhIGxpc3RlbmVyIHRvIGFub3RoZXIgZWxlbWVudCBvciBjb21wb25lbnQuXG4gICAqXG4gICAqICAgICBteUNvbXBvbmVudC5vbihvdGhlckVsZW1lbnQsICdldmVudE5hbWUnLCBteUZ1bmMpO1xuICAgKiAgICAgbXlDb21wb25lbnQub24ob3RoZXJDb21wb25lbnQsICdldmVudE5hbWUnLCBteUZ1bmMpO1xuICAgKlxuICAgKiBUaGUgYmVuZWZpdCBvZiB1c2luZyB0aGlzIG92ZXIgYFZqc0V2ZW50cy5vbihvdGhlckVsZW1lbnQsICdldmVudE5hbWUnLCBteUZ1bmMpYFxuICAgKiBhbmQgYG90aGVyQ29tcG9uZW50Lm9uKCdldmVudE5hbWUnLCBteUZ1bmMpYCBpcyB0aGF0IHRoaXMgd2F5IHRoZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgd2hlbiBlaXRoZXIgY29tcG9uZW50IGlzIGRpc3Bvc2VkLlxuICAgKiBJdCB3aWxsIGFsc28gYmluZCBteUNvbXBvbmVudCBhcyB0aGUgY29udGV4dCBvZiBteUZ1bmMuXG4gICAqXG4gICAqICoqTk9URSoqOiBXaGVuIHVzaW5nIHRoaXMgb24gZWxlbWVudHMgaW4gdGhlIHBhZ2Ugb3RoZXIgdGhhbiB3aW5kb3dcbiAgICogYW5kIGRvY3VtZW50IChib3RoIHBlcm1hbmVudCksIGlmIHlvdSByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NXG4gICAqIHlvdSBuZWVkIHRvIGNhbGwgYG15Q29tcG9uZW50LnRyaWdnZXIoZWwsICdkaXNwb3NlJylgIG9uIGl0IHRvIGNsZWFuIHVwXG4gICAqIHJlZmVyZW5jZXMgdG8gaXQgYW5kIGFsbG93IHRoZSBicm93c2VyIHRvIGdhcmJhZ2UgY29sbGVjdCBpdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfENvbXBvbmVudH0gZmlyc3QgICBUaGUgZXZlbnQgdHlwZSBvciBvdGhlciBjb21wb25lbnRcbiAgICogQHBhcmFtICB7RnVuY3Rpb258U3RyaW5nfSAgICAgIHNlY29uZCAgVGhlIGV2ZW50IGhhbmRsZXIgb3IgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgICAgICAgdGhpcmQgICBUaGUgZXZlbnQgaGFuZGxlclxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9ICAgICAgICBzZWxmXG4gICAqL1xuICBvbihmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnIHx8IExpYi5vYmouaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIEV2ZW50cy5vbih0aGlzLmVsXywgZmlyc3QsIExpYi5iaW5kKHRoaXMsIHNlY29uZCkpO1xuXG4gICAgLy8gVGFyZ2V0aW5nIGFub3RoZXIgY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZmlyc3Q7XG4gICAgICBjb25zdCB0eXBlID0gc2Vjb25kO1xuICAgICAgY29uc3QgZm4gPSBMaWIuYmluZCh0aGlzLCB0aGlyZCk7XG5cbiAgICAgIC8vIFdoZW4gdGhpcyBjb21wb25lbnQgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbSB0aGUgb3RoZXIgY29tcG9uZW50XG4gICAgICBjb25zdCByZW1vdmVPbkRpc3Bvc2UgPSAoKSA9PiB0aGlzLm9mZih0YXJnZXQsIHR5cGUsIGZuKTtcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXIgaXQgdXNpbmcgdGhlIElEXG4gICAgICAvLyBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXJcbiAgICAgIHJlbW92ZU9uRGlzcG9zZS5ndWlkID0gZm4uZ3VpZDtcbiAgICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCByZW1vdmVPbkRpc3Bvc2UpO1xuXG4gICAgICAvLyBJZiB0aGUgb3RoZXIgY29tcG9uZW50IGlzIGRpc3Bvc2VkIGZpcnN0IHdlIG5lZWQgdG8gY2xlYW4gdGhlIHJlZmVyZW5jZVxuICAgICAgLy8gdG8gdGhlIG90aGVyIGNvbXBvbmVudCBpbiB0aGlzIGNvbXBvbmVudCdzIHJlbW92ZU9uRGlzcG9zZSBsaXN0ZW5lclxuICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNyZWF0ZSBhIG1lbW9yeSBsZWFrLlxuICAgICAgY29uc3QgY2xlYW5SZW1vdmVyID0gKCkgPT4gdGhpcy5vZmYoJ2Rpc3Bvc2UnLCByZW1vdmVPbkRpc3Bvc2UpO1xuXG4gICAgICAvLyBBZGQgdGhlIHNhbWUgZnVuY3Rpb24gSUQgc28gd2UgY2FuIGVhc2lseSByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIGNsZWFuUmVtb3Zlci5ndWlkID0gZm4uZ3VpZDtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIERPTSBub2RlXG4gICAgICBpZiAoZmlyc3Qubm9kZU5hbWUpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBsaXN0ZW5lciB0byB0aGUgb3RoZXIgZWxlbWVudFxuICAgICAgICBFdmVudHMub24odGFyZ2V0LCB0eXBlLCBmbik7XG4gICAgICAgIEV2ZW50cy5vbih0YXJnZXQsICdkaXNwb3NlJywgY2xlYW5SZW1vdmVyKTtcblxuICAgICAgLy8gU2hvdWxkIGJlIGEgY29tcG9uZW50XG4gICAgICAvLyBOb3QgdXNpbmcgYGluc3RhbmNlb2YgQ29tcG9uZW50YCBiZWNhdXNlIGl0IG1ha2VzIG1vY2sgcGxheWVycyBkaWZmaWN1bHRcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0Lm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgbGlzdGVuZXIgdG8gdGhlIG90aGVyIGNvbXBvbmVudFxuICAgICAgICB0YXJnZXQub24odHlwZSwgZm4pO1xuICAgICAgICB0YXJnZXQub24oJ2Rpc3Bvc2UnLCBjbGVhblJlbW92ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIHRoaXMgY29tcG9uZW50J3MgZWxlbWVudFxuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub2ZmKCdldmVudFR5cGUnLCBteUZ1bmMpO1xuICAgKlxuICAgKiBJZiBteUZ1bmMgaXMgZXhjbHVkZWQsIEFMTCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICogSWYgZXZlbnRUeXBlIGlzIGV4Y2x1ZGVkLCBBTEwgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEFsdGVybmF0aXZlbHkgeW91IGNhbiB1c2UgYG9mZmAgdG8gcmVtb3ZlIGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgdG8gb3RoZXJcbiAgICogZWxlbWVudHMgb3IgY29tcG9uZW50cyB1c2luZyBgbXlDb21wb25lbnQub24ob3RoZXJDb21wb25lbnQuLi5gLlxuICAgKiBJbiB0aGlzIGNhc2UgYm90aCB0aGUgZXZlbnQgdHlwZSBhbmQgbGlzdGVuZXIgZnVuY3Rpb24gYXJlIFJFUVVJUkVELlxuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub2ZmKG90aGVyRWxlbWVudCwgJ2V2ZW50VHlwZScsIG15RnVuYyk7XG4gICAqICAgICBteUNvbXBvbmVudC5vZmYob3RoZXJDb21wb25lbnQsICdldmVudFR5cGUnLCBteUZ1bmMpO1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmc9fENvbXBvbmVudH0gIGZpcnN0ICBUaGUgZXZlbnQgdHlwZSBvciBvdGhlciBjb21wb25lbnRcbiAgICogQHBhcmFtICB7RnVuY3Rpb249fFN0cmluZ30gICAgICAgc2Vjb25kIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBldmVudCB0eXBlXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9uPX0gICAgICAgICAgICAgIHRoaXJkICBUaGUgbGlzdGVuZXIgZm9yIG90aGVyIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBvZmYoZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcbiAgICBpZiAoIWZpcnN0IHx8IHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycgfHwgTGliLm9iai5pc0FycmF5KGZpcnN0KSkge1xuICAgICAgRXZlbnRzLm9mZih0aGlzLmVsXywgZmlyc3QsIHNlY29uZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGZpcnN0O1xuICAgICAgY29uc3QgdHlwZSA9IHNlY29uZDtcbiAgICAgIC8vIEVuc3VyZSB0aGVyZSdzIGF0IGxlYXN0IGEgZ3VpZCwgZXZlbiBpZiB0aGUgZnVuY3Rpb24gaGFzbid0IGJlZW4gdXNlZFxuICAgICAgY29uc3QgZm4gPSBMaWIuYmluZCh0aGlzLCB0aGlyZCk7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgZGlzcG9zZSBsaXN0ZW5lciBvbiB0aGlzIGNvbXBvbmVudCxcbiAgICAgIC8vIHdoaWNoIHdhcyBnaXZlbiB0aGUgc2FtZSBndWlkIGFzIHRoZSBldmVudCBsaXN0ZW5lclxuICAgICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBmbik7XG5cbiAgICAgIGlmIChmaXJzdC5ub2RlTmFtZSkge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgICAgIEV2ZW50cy5vZmYodGFyZ2V0LCB0eXBlLCBmbik7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdGVuZXIgZm9yIGNsZWFuaW5nIHRoZSBkaXNwb3NlIGxpc3RlbmVyXG4gICAgICAgIEV2ZW50cy5vZmYodGFyZ2V0LCAnZGlzcG9zZScsIGZuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5vZmYodHlwZSwgZm4pO1xuICAgICAgICB0YXJnZXQub2ZmKCdkaXNwb3NlJywgZm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBiZSB0cmlnZ2VyZWQgb25seSBvbmNlIGFuZCB0aGVuIHJlbW92ZWRcbiAgICpcbiAgICogICAgIG15Q29tcG9uZW50Lm9uZSgnZXZlbnROYW1lJywgbXlGdW5jKTtcbiAgICpcbiAgICogQWx0ZXJuYXRpdmVseSB5b3UgY2FuIGFkZCBhIGxpc3RlbmVyIHRvIGFub3RoZXIgZWxlbWVudCBvciBjb21wb25lbnRcbiAgICogdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCBvbmx5IG9uY2UuXG4gICAqXG4gICAqICAgICBteUNvbXBvbmVudC5vbmUob3RoZXJFbGVtZW50LCAnZXZlbnROYW1lJywgbXlGdW5jKTtcbiAgICogICAgIG15Q29tcG9uZW50Lm9uZShvdGhlckNvbXBvbmVudCwgJ2V2ZW50TmFtZScsIG15RnVuYyk7XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ3xDb21wb25lbnR9ICBmaXJzdCAgIFRoZSBldmVudCB0eXBlIG9yIG90aGVyIGNvbXBvbmVudFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbnxTdHJpbmd9ICAgICAgIHNlY29uZCAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtICB7RnVuY3Rpb249fSAgICAgICAgICAgICB0aGlyZCAgIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBmb3Igb3RoZXIgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIG9uZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnIHx8IExpYi5vYmouaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIEV2ZW50cy5vbmUodGhpcy5lbF8sIGZpcnN0LCBMaWIuYmluZCh0aGlzLCBzZWNvbmQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZmlyc3Q7XG4gICAgICBjb25zdCB0eXBlID0gc2Vjb25kO1xuICAgICAgY29uc3QgZm4gPSBMaWIuYmluZCh0aGlzLCB0aGlyZCk7XG5cbiAgICAgIGNvbnN0IG5ld0Z1bmMgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKHRhcmdldCwgdHlwZSwgbmV3RnVuYyk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICAvLyBLZWVwIHRoZSBzYW1lIGZ1bmN0aW9uIElEIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIG5ld0Z1bmMuZ3VpZCA9IGZuLmd1aWQ7XG5cbiAgICAgIHRoaXMub24odGFyZ2V0LCB0eXBlLCBuZXdGdW5jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIGFuIGVsZW1lbnRcbiAgICpcbiAgICogICAgIG15Q29tcG9uZW50LnRyaWdnZXIoJ2V2ZW50TmFtZScpO1xuICAgKiAgICAgbXlDb21wb25lbnQudHJpZ2dlcih7J3R5cGUnOidldmVudE5hbWUnfSk7XG4gICAqXG4gICAqIEBwYXJhbSAge0V2ZW50fE9iamVjdHxTdHJpbmd9IGV2ZW50ICBBIHN0cmluZyAodGhlIHR5cGUpIG9yIGFuIGV2ZW50IG9iamVjdCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGVcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSAgICAgICBzZWxmXG4gICAqL1xuICB0cmlnZ2VyKGV2ZW50KSB7XG4gICAgRXZlbnRzLnRyaWdnZXIodGhpcy5lbF8sIGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIGEgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJlYWR5IHN0YXRlXG4gICAqXG4gICAqIERpZmZlcmVudCBmcm9tIGV2ZW50IGxpc3RlbmVycyBpbiB0aGF0IGlmIHRoZSByZWFkeSBldmVudCBoYXMgYWxyZWFkeSBoYXBwZW5lZFxuICAgKiBpdCB3aWxsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gUmVhZHkgbGlzdGVuZXJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKi9cbiAgcmVhZHkoZm4pIHtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGlmICh0aGlzLmlzUmVhZHlfKSB7XG4gICAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlYWR5UXVldWVfID0gdGhpcy5yZWFkeVF1ZXVlXyB8fCBbXTtcbiAgICAgICAgdGhpcy5yZWFkeVF1ZXVlXy5wdXNoKGZuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgcmVhZHkgbGlzdGVuZXJzXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIHRyaWdnZXJSZWFkeSgpIHtcbiAgICB0aGlzLmlzUmVhZHlfID0gdHJ1ZTtcblxuICAgIGxldCByZWFkeVF1ZXVlID0gdGhpcy5yZWFkeVF1ZXVlXztcblxuICAgIGlmIChyZWFkeVF1ZXVlICYmIHJlYWR5UXVldWUubGVuZ3RoID4gMCkge1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlYWR5UXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVhZHlRdWV1ZVtpXS5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXNldCBSZWFkeSBRdWV1ZVxuICAgICAgdGhpcy5yZWFkeVF1ZXVlXyA9IFtdO1xuXG4gICAgICAvLyBBbGxvdyBmb3IgdXNpbmcgZXZlbnQgbGlzdGVuZXJzIGFsc28sIGluIGNhc2UgeW91IHdhbnQgdG8gZG8gc29tZXRoaW5nIGV2ZXJ5dGltZSBhIHNvdXJjZSBpcyByZWFkeS5cbiAgICAgIHRoaXMudHJpZ2dlcigncmVhZHknKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21wb25lbnQncyBlbGVtZW50IGhhcyBhIENTUyBjbGFzcyBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc1RvQ2hlY2sgQ2xhc3NuYW1lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzVG9DaGVjaykge1xuICAgIHJldHVybiBMaWIuaGFzQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9DaGVjayk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gdGhlIGNvbXBvbmVudCdzIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9BZGQgQ2xhc3NuYW1lIHRvIGFkZFxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc1RvQWRkKSB7XG4gICAgTGliLmFkZENsYXNzKHRoaXMuZWxfLCBjbGFzc1RvQWRkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIHRoZSBjb21wb25lbnQncyBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc1RvUmVtb3ZlIENsYXNzbmFtZSB0byByZW1vdmVcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NUb1JlbW92ZSkge1xuICAgIExpYi5yZW1vdmVDbGFzcyh0aGlzLmVsXywgY2xhc3NUb1JlbW92ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGUgY29tcG9uZW50IGVsZW1lbnQgaWYgaGlkZGVuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGNvbXBvbmVudCBlbGVtZW50IGlmIGN1cnJlbnRseSBzaG93aW5nXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2sgYW4gaXRlbSBpbiBpdHMgdmlzaWJsZSBzdGF0ZVxuICAgKiBUbyBiZSB1c2VkIHdpdGggZmFkZUluL2ZhZGVPdXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGxvY2tTaG93aW5nKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmxvY2sgYW4gaXRlbSB0byBiZSBoaWRkZW5cbiAgICogVG8gYmUgdXNlZCB3aXRoIGZhZGVJbi9mYWRlT3V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxvY2tTaG93aW5nKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgb3IgZ2V0IHRoZSB3aWR0aCBvZiB0aGUgY29tcG9uZW50IChDU1MgdmFsdWVzKVxuICAgKlxuICAgKiBTZXR0aW5nIHRoZSB2aWRlbyB0YWcgZGltZW5zaW9uIHZhbHVlcyBvbmx5IHdvcmtzIHdpdGggdmFsdWVzIGluIHBpeGVscy5cbiAgICogUGVyY2VudCB2YWx1ZXMgd2lsbCBub3Qgd29yay5cbiAgICogU29tZSBwZXJjZW50cyBjYW4gYmUgdXNlZCwgYnV0IHdpZHRoKCkvaGVpZ2h0KCkgd2lsbCByZXR1cm4gdGhlIG51bWJlciArICUsXG4gICAqIG5vdCB0aGUgYWN0dWFsIGNvbXB1dGVkIHdpZHRoL2hlaWdodC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZz19IG51bSAgIE9wdGlvbmFsIHdpZHRoIG51bWJlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwTGlzdGVuZXJzIFNraXAgdGhlICdyZXNpemUnIGV2ZW50IHRyaWdnZXJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSBUaGlzIGNvbXBvbmVudCwgd2hlbiBzZXR0aW5nIHRoZSB3aWR0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBUaGUgd2lkdGgsIHdoZW4gZ2V0dGluZ1xuICAgKi9cbiAgd2lkdGgobnVtLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCd3aWR0aCcsIG51bSwgc2tpcExpc3RlbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQgKENTUyB2YWx1ZXMpXG4gICAqXG4gICAqIFNldHRpbmcgdGhlIHZpZGVvIHRhZyBkaW1lbnNpb24gdmFsdWVzIG9ubHkgd29ya3Mgd2l0aCB2YWx1ZXMgaW4gcGl4ZWxzLlxuICAgKiBQZXJjZW50IHZhbHVlcyB3aWxsIG5vdCB3b3JrLlxuICAgKiBTb21lIHBlcmNlbnRzIGNhbiBiZSB1c2VkLCBidXQgd2lkdGgoKS9oZWlnaHQoKSB3aWxsIHJldHVybiB0aGUgbnVtYmVyICsgJSxcbiAgICogbm90IHRoZSBhY3R1YWwgY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nPX0gbnVtICAgICBOZXcgY29tcG9uZW50IGhlaWdodFxuICAgKiBAcGFyYW0gIHtCb29sZWFuPX0gc2tpcExpc3RlbmVycyBTa2lwIHRoZSByZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9IFRoaXMgY29tcG9uZW50LCB3aGVuIHNldHRpbmcgdGhlIGhlaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBUaGUgaGVpZ2h0LCB3aGVuIGdldHRpbmdcbiAgICovXG4gIGhlaWdodChudW0sIHNraXBMaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ2hlaWdodCcsIG51bSwgc2tpcExpc3RlbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGJvdGggd2lkdGggYW5kIGhlaWdodCBhdCB0aGUgc2FtZSB0aW1lXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHdpZHRoXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGhlaWdodFxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9IFRoZSBjb21wb25lbnRcbiAgICovXG4gIGRpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIC8vIFNraXAgcmVzaXplIGxpc3RlbmVycyBvbiB3aWR0aCBmb3Igb3B0aW1pemF0aW9uXG4gICAgcmV0dXJuIHRoaXMud2lkdGgod2lkdGgsIHRydWUpLmhlaWdodChoZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgd2lkdGggb3IgaGVpZ2h0XG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGUgd2lkdGgoKSBhbmQgaGVpZ2h0KCkgbWV0aG9kcy5cbiAgICogQWxsIGZvciBhbiBpbnRlZ2VyLCBpbnRlZ2VyICsgJ3B4JyBvciBpbnRlZ2VyICsgJyUnO1xuICAgKlxuICAgKiBLbm93biBpc3N1ZTogSGlkZGVuIGVsZW1lbnRzIG9mZmljaWFsbHkgaGF2ZSBhIHdpZHRoIG9mIDAuIFdlJ3JlIGRlZmF1bHRpbmdcbiAgICogdG8gdGhlIHN0eWxlLndpZHRoIHZhbHVlIGFuZCBmYWxsaW5nIGJhY2sgdG8gY29tcHV0ZWRTdHlsZSB3aGljaCBoYXMgdGhlXG4gICAqIGhpZGRlbiBlbGVtZW50IGlzc3VlLiBJbmZvLCBidXQgcHJvYmFibHkgbm90IGFuIGVmZmljaWVudCBmaXg6XG4gICAqIGh0dHA6Ly93d3cuZm9saW90ZWsuY29tL2RldmJsb2cvZ2V0dGluZy10aGUtd2lkdGgtb2YtYS1oaWRkZW4tZWxlbWVudC13aXRoLWpxdWVyeS11c2luZy13aWR0aC9cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSB3aWR0aE9ySGVpZ2h0ICAnd2lkdGgnIG9yICdoZWlnaHQnXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmc9fSBudW0gICAgIE5ldyBkaW1lbnNpb25cbiAgICogQHBhcmFtICB7Qm9vbGVhbj19IHNraXBMaXN0ZW5lcnMgU2tpcCByZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9IFRoZSBjb21wb25lbnQgaWYgYSBkaW1lbnNpb24gd2FzIHNldFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBUaGUgZGltZW5zaW9uIGlmIG5vdGhpbmcgd2FzIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGltZW5zaW9uKHdpZHRoT3JIZWlnaHQsIG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIGlmIChudW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2V0IHRvIHplcm8gaWYgbnVsbCBvciBsaXRlcmFsbHkgTmFOIChOYU4gIT09IE5hTilcbiAgICAgIGlmIChudW0gPT09IG51bGwgfHwgbnVtICE9PSBudW0pIHtcbiAgICAgICAgbnVtID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdXNpbmcgY3NzIHdpZHRoL2hlaWdodCAoJSBvciBweCkgYW5kIGFkanVzdFxuICAgICAgaWYgKCgnJyArIG51bSkuaW5kZXhPZignJScpICE9PSAtMSB8fCAoJycgKyBudW0pLmluZGV4T2YoJ3B4JykgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gbnVtO1xuICAgICAgfSBlbHNlIGlmIChudW0gPT09ICdhdXRvJykge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSBudW0gKyAncHgnO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwTGlzdGVuZXJzIGFsbG93cyB1cyB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSByZXNpemUgZXZlbnQgd2hlbiBzZXR0aW5nIGJvdGggd2lkdGggYW5kIGhlaWdodFxuICAgICAgaWYgKCFza2lwTGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVzaXplJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBjb21wb25lbnRcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIE5vdCBzZXR0aW5nIGEgdmFsdWUsIHNvIGdldHRpbmcgaXRcbiAgICAvLyBNYWtlIHN1cmUgZWxlbWVudCBleGlzdHNcbiAgICBpZiAoIXRoaXMuZWxfKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBHZXQgZGltZW5zaW9uIHZhbHVlIGZyb20gc3R5bGVcbiAgICBsZXQgdmFsID0gdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF07XG4gICAgbGV0IHB4SW5kZXggPSB2YWwuaW5kZXhPZigncHgnKTtcblxuICAgIGlmIChweEluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBwaXhlbCB2YWx1ZSB3aXRoIG5vICdweCdcbiAgICAgIHJldHVybiBwYXJzZUludCh2YWwuc2xpY2UoMCwgcHhJbmRleCksIDEwKTtcbiAgICB9XG5cbiAgICAvLyBObyBweCBzbyB1c2luZyAlIG9yIG5vIHN0eWxlIHdhcyBzZXQsIHNvIGZhbGxpbmcgYmFjayB0byBvZmZzZXRXaWR0aC9oZWlnaHRcbiAgICAvLyBJZiBjb21wb25lbnQgaGFzIGRpc3BsYXk6bm9uZSwgb2Zmc2V0IHdpbGwgcmV0dXJuIDBcbiAgICAvLyBUT0RPOiBoYW5kbGUgZGlzcGxheTpub25lIGFuZCBubyBkaW1lbnNpb24gc3R5bGUgdXNpbmcgcHhcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5lbF9bJ29mZnNldCcgKyBMaWIuY2FwaXRhbGl6ZSh3aWR0aE9ySGVpZ2h0KV0sIDEwKTtcblxuICAgIC8vIENvbXB1dGVkU3R5bGUgdmVyc2lvbi5cbiAgICAvLyBPbmx5IGRpZmZlcmVuY2UgaXMgaWYgdGhlIGVsZW1lbnQgaXMgaGlkZGVuIGl0IHdpbGwgcmV0dXJuXG4gICAgLy8gdGhlIHBlcmNlbnQgdmFsdWUgKGUuZy4gJzEwMCUnJylcbiAgICAvLyBpbnN0ZWFkIG9mIHplcm8gbGlrZSBvZmZzZXRXaWR0aCByZXR1cm5zLlxuICAgIC8vIHZhciB2YWwgPSBMaWIuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHRoaXMuZWxfLCB3aWR0aE9ySGVpZ2h0KTtcbiAgICAvLyB2YXIgcHhJbmRleCA9IHZhbC5pbmRleE9mKCdweCcpO1xuXG4gICAgLy8gaWYgKHB4SW5kZXggIT09IC0xKSB7XG4gICAgLy8gICByZXR1cm4gdmFsLnNsaWNlKDAsIHB4SW5kZXgpO1xuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICByZXR1cm4gdmFsO1xuICAgIC8vIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0ICd0YXAnIGV2ZW50cyB3aGVuIHRvdWNoIGV2ZW50cyBhcmUgc3VwcG9ydGVkXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBzdXBwb3J0IHRvZ2dsaW5nIHRoZSBjb250cm9scyB0aHJvdWdoIGEgdGFwIG9uIHRoZSB2aWRlby5cbiAgICpcbiAgICogV2UncmUgcmVxdWlyaW5nIHRoZW0gdG8gYmUgZW5hYmxlZCBiZWNhdXNlIG90aGVyd2lzZSBldmVyeSBjb21wb25lbnQgd291bGRcbiAgICogaGF2ZSB0aGlzIGV4dHJhIG92ZXJoZWFkIHVubmVjZXNzYXJpbHksIG9uIG1vYmlsZSBkZXZpY2VzIHdoZXJlIGV4dHJhXG4gICAqIG92ZXJoZWFkIGlzIGVzcGVjaWFsbHkgYmFkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdFRhcEV2ZW50cygpIHtcbiAgICAvLyBUcmFjayB0aGUgc3RhcnQgdGltZSBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGhvdyBsb25nIHRoZSB0b3VjaCBsYXN0ZWRcbiAgICBsZXQgdG91Y2hTdGFydCA9IDA7XG4gICAgbGV0IGZpcnN0VG91Y2ggPSBudWxsO1xuXG4gICAgLy8gTWF4aW11bSBtb3ZlbWVudCBhbGxvd2VkIGR1cmluZyBhIHRvdWNoIGV2ZW50IHRvIHN0aWxsIGJlIGNvbnNpZGVyZWQgYSB0YXBcbiAgICAvLyBPdGhlciBwb3B1bGFyIGxpYnMgdXNlIGFueXdoZXJlIGZyb20gMiAoaGFtbWVyLmpzKSB0byAxNSwgc28gMTAgc2VlbXMgbGlrZSBhIG5pY2UsIHJvdW5kIG51bWJlci5cbiAgICBjb25zdCB0YXBNb3ZlbWVudFRocmVzaG9sZCA9IDEwO1xuXG4gICAgLy8gVGhlIG1heGltdW0gbGVuZ3RoIGEgdG91Y2ggY2FuIGJlIHdoaWxlIHN0aWxsIGJlaW5nIGNvbnNpZGVyZWQgYSB0YXBcbiAgICBjb25zdCB0b3VjaFRpbWVUaHJlc2hvbGQgPSAyMDA7XG5cbiAgICBsZXQgY291bGRCZVRhcDtcblxuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZpcnN0VG91Y2ggPSBMaWIub2JqLmNvcHkoZXZlbnQudG91Y2hlc1swXSk7XG4gICAgICAgIC8vIFJlY29yZCBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlY3QgYSB0YXAgdnMuIFwidG91Y2ggYW5kIGhvbGRcIlxuICAgICAgICB0b3VjaFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIFJlc2V0IGNvdWxkQmVUYXAgdHJhY2tpbmdcbiAgICAgICAgY291bGRCZVRhcCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0VG91Y2gpIHtcbiAgICAgICAgLy8gU29tZSBkZXZpY2VzIHdpbGwgdGhyb3cgdG91Y2htb3ZlcyBmb3IgYWxsIGJ1dCB0aGUgc2xpZ2h0ZXN0IG9mIHRhcHMuXG4gICAgICAgIC8vIFNvLCBpZiB3ZSBtb3ZlZCBvbmx5IGEgc21hbGwgZGlzdGFuY2UsIHRoaXMgY291bGQgc3RpbGwgYmUgYSB0YXBcbiAgICAgICAgY29uc3QgeGRpZmYgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZmlyc3RUb3VjaC5wYWdlWDtcbiAgICAgICAgY29uc3QgeWRpZmYgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZmlyc3RUb3VjaC5wYWdlWTtcbiAgICAgICAgY29uc3QgdG91Y2hEaXN0YW5jZSA9IE1hdGguc3FydCh4ZGlmZiAqIHhkaWZmICsgeWRpZmYgKiB5ZGlmZik7XG5cbiAgICAgICAgaWYgKHRvdWNoRGlzdGFuY2UgPiB0YXBNb3ZlbWVudFRocmVzaG9sZCkge1xuICAgICAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgbm9UYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogTGlzdGVuIHRvIHRoZSBvcmlnaW5hbCB0YXJnZXQuIGh0dHA6Ly95b3V0dS5iZS9EdWpmcFhPS1VwOD90PTEzbThzXG4gICAgdGhpcy5vbigndG91Y2hsZWF2ZScsIG5vVGFwKTtcbiAgICB0aGlzLm9uKCd0b3VjaGNhbmNlbCcsIG5vVGFwKTtcblxuICAgIC8vIFdoZW4gdGhlIHRvdWNoIGVuZHMsIG1lYXN1cmUgaG93IGxvbmcgaXQgdG9vayBhbmQgdHJpZ2dlciB0aGUgYXBwcm9wcmlhdGVcbiAgICAvLyBldmVudFxuICAgIHRoaXMub24oJ3RvdWNoZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgLy8gUHJvY2VlZCBvbmx5IGlmIHRoZSB0b3VjaG1vdmUvbGVhdmUvY2FuY2VsIGV2ZW50IGRpZG4ndCBoYXBwZW5cbiAgICAgIGlmIChjb3VsZEJlVGFwID09PSB0cnVlKSB7XG4gICAgICAgIC8vIE1lYXN1cmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgICAgICBjb25zdCB0b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnQ7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0b3VjaCB3YXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQgdG8gYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgICAgICBpZiAodG91Y2hUaW1lIDwgdG91Y2hUaW1lVGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgbGV0IGJyb3dzZXIgdHVybiB0aGlzIGludG8gYSBjbGlja1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd0YXAnKTtcbiAgICAgICAgICAvLyBJdCBtYXkgYmUgZ29vZCB0byBjb3B5IHRoZSB0b3VjaGVuZCBldmVudCBvYmplY3QgYW5kIGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyB0eXBlIHRvIHRhcCwgaWYgdGhlIG90aGVyIGV2ZW50IHByb3BlcnRpZXMgYXJlbid0IGV4YWN0IGFmdGVyXG4gICAgICAgICAgLy8gTGliLmZpeEV2ZW50IHJ1bnMgKGUuZy4gZXZlbnQudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwb3J0IHVzZXIgdG91Y2ggYWN0aXZpdHkgd2hlbiB0b3VjaCBldmVudHMgb2NjdXJcbiAgICpcbiAgICogVXNlciBhY3Rpdml0eSBpcyB1c2VkIHRvIGRldGVybWluZSB3aGVuIGNvbnRyb2xzIHNob3VsZCBzaG93L2hpZGUuIEl0J3NcbiAgICogcmVsYXRpdmVseSBzaW1wbGUgd2hlbiBpdCBjb21lcyB0byBtb3VzZSBldmVudHMsIGJlY2F1c2UgYW55IG1vdXNlIGV2ZW50XG4gICAqIHNob3VsZCBzaG93IHRoZSBjb250cm9scy4gU28gd2UgY2FwdHVyZSBtb3VzZSBldmVudHMgdGhhdCBidWJibGUgdXAgdG8gdGhlXG4gICAqIHBsYXllciBhbmQgcmVwb3J0IGFjdGl2aXR5IHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBXaXRoIHRvdWNoIGV2ZW50cyBpdCBpc24ndCBhcyBlYXN5LiBXZSBjYW4ndCByZWx5IG9uIHRvdWNoIGV2ZW50cyBhdCB0aGVcbiAgICogcGxheWVyIGxldmVsLCBiZWNhdXNlIGEgdGFwICh0b3VjaHN0YXJ0ICsgdG91Y2hlbmQpIG9uIHRoZSB2aWRlbyBpdHNlbGYgb25cbiAgICogbW9iaWxlIGRldmljZXMgaXMgbWVhbnQgdG8gdHVybiBjb250cm9scyBvZmYgKGFuZCBvbikuIFVzZXIgYWN0aXZpdHkgaXNcbiAgICogY2hlY2tlZCBhc3luY2hyb25vdXNseSwgc28gd2hhdCBjb3VsZCBoYXBwZW4gaXMgYSB0YXAgZXZlbnQgb24gdGhlIHZpZGVvXG4gICAqIHR1cm5zIHRoZSBjb250cm9scyBvZmYsIHRoZW4gdGhlIHRvdWNoZW5kIGV2ZW50IGJ1YmJsZXMgdXAgdG8gdGhlIHBsYXllcixcbiAgICogd2hpY2ggaWYgaXQgcmVwb3J0ZWQgdXNlciBhY3Rpdml0eSwgd291bGQgdHVybiB0aGUgY29udHJvbHMgcmlnaHQgYmFjayBvbi5cbiAgICogKFdlIGFsc28gZG9uJ3Qgd2FudCB0byBjb21wbGV0ZWx5IGJsb2NrIHRvdWNoIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHVwKVxuICAgKlxuICAgKiBBbHNvIGEgdG91Y2htb3ZlLCB0b3VjaCtob2xkLCBhbmQgYW55dGhpbmcgb3RoZXIgdGhhbiBhIHRhcCBpcyBub3Qgc3VwcG9zZWRcbiAgICogdG8gdHVybiB0aGUgY29udHJvbHMgYmFjayBvbiBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gICAqXG4gICAqIEhlcmUgd2UncmUgc2V0dGluZyB0aGUgZGVmYXVsdCBjb21wb25lbnQgYmVoYXZpb3IgdG8gcmVwb3J0IHVzZXIgYWN0aXZpdHlcbiAgICogd2hlbmV2ZXIgdG91Y2ggZXZlbnRzIGhhcHBlbiwgYW5kIHRoaXMgY2FuIGJlIHR1cm5lZCBvZmYgYnkgY29tcG9uZW50cyB0aGF0XG4gICAqIHdhbnQgdG91Y2ggZXZlbnRzIHRvIGFjdCBkaWZmZXJlbnRseS5cbiAgICovXG4gIGVuYWJsZVRvdWNoQWN0aXZpdHkoKSB7XG4gICAgLy8gRG9uJ3QgY29udGludWUgaWYgdGhlIHJvb3QgcGxheWVyIGRvZXNuJ3Qgc3VwcG9ydCByZXBvcnRpbmcgdXNlciBhY3Rpdml0eVxuICAgIGlmICghdGhpcy5wbGF5ZXIoKSB8fCAhdGhpcy5wbGF5ZXIoKS5yZXBvcnRVc2VyQWN0aXZpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBsaXN0ZW5lciBmb3IgcmVwb3J0aW5nIHRoYXQgdGhlIHVzZXIgaXMgYWN0aXZlXG4gICAgY29uc3QgcmVwb3J0ID0gTGliLmJpbmQodGhpcy5wbGF5ZXIoKSwgdGhpcy5wbGF5ZXIoKS5yZXBvcnRVc2VyQWN0aXZpdHkpO1xuXG4gICAgbGV0IHRvdWNoSG9sZGluZztcblxuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gRm9yIGFzIGxvbmcgYXMgdGhlIHRoZXkgYXJlIHRvdWNoaW5nIHRoZSBkZXZpY2Ugb3IgaGF2ZSB0aGVpciBtb3VzZSBkb3duLFxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgICAgLy8gcmVwb3J0IGF0IHRoZSBzYW1lIGludGVydmFsIGFzIGFjdGl2aXR5Q2hlY2tcbiAgICAgIHRvdWNoSG9sZGluZyA9IHRoaXMuc2V0SW50ZXJ2YWwocmVwb3J0LCAyNTApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBzdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgdG91Y2ggaXMgaG9sZGluZ1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgfTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIHJlcG9ydCk7XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCB0b3VjaEVuZCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCB0b3VjaEVuZCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aW1lb3V0IGFuZCBzZXRzIHVwIGRpc3Bvc2FsIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIHRpbWVvdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IE51bWJlciBvZiBtcyB0byBkZWxheSBiZWZvcmUgZXhlY3V0aW5nIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lb3V0IElEXG4gICAqL1xuICBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KSB7XG4gICAgZm4gPSBMaWIuYmluZCh0aGlzLCBmbik7XG5cbiAgICAvLyB3aW5kb3cuc2V0VGltZW91dCB3b3VsZCBiZSBwcmVmZXJhYmxlIGhlcmUsIGJ1dCBkdWUgdG8gc29tZSBiaXphcnJlIGlzc3VlIHdpdGggU2lub24gYW5kL29yIFBoYW50b21qcywgd2UgY2FuJ3QuXG4gICAgbGV0IHRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lb3V0KTtcblxuICAgIGNvbnN0IGRpc3Bvc2VGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSBgdmpzLXRpbWVvdXQtJHt0aW1lb3V0SWR9YDtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIHRpbWVvdXRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYSB0aW1lb3V0IGFuZCByZW1vdmVzIHRoZSBhc3NvY2lhdGVkIGRpc3Bvc2UgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRJZCBUaGUgaWQgb2YgdGhlIHRpbWVvdXQgdG8gY2xlYXJcbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lb3V0IElEXG4gICAqL1xuICBjbGVhclRpbWVvdXQodGltZW91dElkKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgY29uc3QgZGlzcG9zZUZuID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gYHZqcy10aW1lb3V0LSR7dGltZW91dElkfWA7XG5cbiAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gdGltZW91dElkO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW50ZXJ2YWwgYW5kIHNldHMgdXAgZGlzcG9zYWwgYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJ1biBldmVyeSBOIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCBOdW1iZXIgb2YgbXMgdG8gZGVsYXkgYmVmb3JlIGV4ZWN1dGluZyBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgaW50ZXJ2YWwgSURcbiAgICovXG4gIHNldEludGVydmFsKGZuLCBpbnRlcnZhbCkge1xuICAgIGZuID0gTGliLmJpbmQodGhpcywgZm4pO1xuXG4gICAgbGV0IGludGVydmFsSWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKTtcblxuICAgIGNvbnN0IGRpc3Bvc2VGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIH07XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9IGB2anMtaW50ZXJ2YWwtJHtpbnRlcnZhbElkfWA7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiBpbnRlcnZhbElkO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbiBpbnRlcnZhbCBhbmQgcmVtb3ZlcyB0aGUgYXNzb2NpYXRlZCBkaXNwb3NlIGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbElkIFRoZSBpZCBvZiB0aGUgaW50ZXJ2YWwgdG8gY2xlYXJcbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBpbnRlcnZhbCBJRFxuICAgKi9cbiAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG5cbiAgICBjb25zdCBkaXNwb3NlRm4gPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSBgdmpzLWludGVydmFsLSR7aW50ZXJ2YWxJZH1gO1xuXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIGludGVydmFsSWQ7XG4gIH1cblxuICBzdGF0aWMgcmVnaXN0ZXJDb21wb25lbnQobmFtZSwgY29tcCkge1xuICAgIGlmICghQ29tcG9uZW50LmNvbXBvbmVudHNfKSB7XG4gICAgICBDb21wb25lbnQuY29tcG9uZW50c18gPSB7fTtcbiAgICB9XG5cbiAgICBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0gPSBjb21wO1xuICAgIHJldHVybiBjb21wO1xuICB9XG5cbiAgc3RhdGljIGdldENvbXBvbmVudChuYW1lKSB7XG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzXyAmJiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0pIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV07XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cudmlkZW9qcyAmJiB3aW5kb3cudmlkZW9qc1tuYW1lXSkge1xuICAgICAgTGliLmxvZy53YXJuKGBUaGUgJHtuYW1lfSBjb21wb25lbnQgd2FzIGFkZGVkIHRvIHRoZSB2aWRlb2pzIG9iamVjdCB3aGVuIGl0IHNob3VsZCBiZSByZWdpc3RlcmVkIHVzaW5nIHZpZGVvanMucmVnaXN0ZXJDb21wb25lbnQobmFtZSwgY29tcG9uZW50KWApO1xuICAgICAgcmV0dXJuIHdpbmRvdy52aWRlb2pzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBleHRlbmQocHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIC8vIFNldCB1cCB0aGUgY29uc3RydWN0b3IgdXNpbmcgdGhlIHN1cHBsaWVkIGluaXQgbWV0aG9kXG4gICAgLy8gb3IgdXNpbmcgdGhlIGluaXQgb2YgdGhlIHBhcmVudCBvYmplY3RcbiAgICAvLyBNYWtlIHN1cmUgdG8gY2hlY2sgdGhlIHVub2JmdXNjYXRlZCB2ZXJzaW9uIGZvciBleHRlcm5hbCBsaWJzXG4gICAgbGV0IGluaXQgPSBwcm9wcy5pbml0IHx8IHByb3BzLmluaXQgfHwgdGhpcy5wcm90b3R5cGUuaW5pdCB8fCB0aGlzLnByb3RvdHlwZS5pbml0IHx8IGZ1bmN0aW9uKCkge307XG4gICAgLy8gSW4gUmVzaWcncyBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2UgKHByZXZpb3VzbHkgdXNlZCkgdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gIGlzIGEgZnVuY3Rpb24gdGhhdCBjYWxscyBgdGhpcy5pbml0LmFwcGx5KGFyZ3VtZW50cylgXG4gICAgLy8gSG93ZXZlciB0aGF0IHdvdWxkIHByZXZlbnQgdXMgZnJvbSB1c2luZyBgUGFyZW50T2JqZWN0LmNhbGwodGhpcyk7YFxuICAgIC8vICBpbiBhIENoaWxkIGNvbnN0cnVjdG9yIGJlY2F1c2UgdGhlIGB0aGlzYCBpbiBgdGhpcy5pbml0YFxuICAgIC8vICB3b3VsZCBzdGlsbCByZWZlciB0byB0aGUgQ2hpbGQgYW5kIGNhdXNlIGFuIGluZmluaXRlIGxvb3AuXG4gICAgLy8gV2Ugd291bGQgaW5zdGVhZCBoYXZlIHRvIGRvXG4gICAgLy8gICAgYFBhcmVudE9iamVjdC5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO2BcbiAgICAvLyAgQmxlaC4gV2UncmUgbm90IGNyZWF0aW5nIGEgX3N1cGVyKCkgZnVuY3Rpb24sIHNvIGl0J3MgZ29vZCB0byBrZWVwXG4gICAgLy8gIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgcmVmZXJlbmNlIHNpbXBsZS5cbiAgICBsZXQgc3ViT2JqID0gZnVuY3Rpb24oKSB7XG4gICAgICBpbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIC8vIEluaGVyaXQgZnJvbSB0aGlzIG9iamVjdCdzIHByb3RvdHlwZVxuICAgIHN1Yk9iai5wcm90b3R5cGUgPSBMaWIub2JqLmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gICAgLy8gUmVzZXQgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5IGZvciBzdWJPYmogb3RoZXJ3aXNlXG4gICAgLy8gaW5zdGFuY2VzIG9mIHN1Yk9iaiB3b3VsZCBoYXZlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcGFyZW50IE9iamVjdFxuICAgIHN1Yk9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJPYmo7XG5cbiAgICAvLyBNYWtlIHRoZSBjbGFzcyBleHRlbmRhYmxlXG4gICAgc3ViT2JqLmV4dGVuZCA9IENvbXBvbmVudC5leHRlbmQ7XG4gICAgLy8gTWFrZSBhIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBpbnN0YW5jZXNcbiAgICAvLyBzdWJPYmouY3JlYXRlID0gQ29yZU9iamVjdC5jcmVhdGU7XG5cbiAgICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcbiAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgc3ViT2JqLnByb3RvdHlwZVtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdWJPYmo7XG4gIH1cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb21wb25lbnQnLCBDb21wb25lbnQpO1xuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYi5qcyc7XG5cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG5pbXBvcnQgUGxheVRvZ2dsZSBmcm9tICcuL3BsYXktdG9nZ2xlLmpzJztcbmltcG9ydCBDdXJyZW50VGltZURpc3BsYXkgZnJvbSAnLi90aW1lLWNvbnRyb2xzL2N1cnJlbnQtdGltZS1kaXNwbGF5LmpzJztcbmltcG9ydCBEdXJhdGlvbkRpc3BsYXkgZnJvbSAnLi90aW1lLWNvbnRyb2xzL2R1cmF0aW9uLWRpc3BsYXkuanMnO1xuaW1wb3J0IFRpbWVEaXZpZGVyIGZyb20gJy4vdGltZS1jb250cm9scy90aW1lLWRpdmlkZXIuanMnO1xuaW1wb3J0IFJlbWFpbmluZ1RpbWVEaXNwbGF5IGZyb20gJy4vdGltZS1jb250cm9scy9yZW1haW5pbmctdGltZS1kaXNwbGF5LmpzJztcbmltcG9ydCBMaXZlRGlzcGxheSBmcm9tICcuL2xpdmUtZGlzcGxheS5qcyc7XG5pbXBvcnQgUHJvZ3Jlc3NDb250cm9sIGZyb20gJy4vcHJvZ3Jlc3MtY29udHJvbC9wcm9ncmVzcy1jb250cm9sLmpzJztcbmltcG9ydCBGdWxsc2NyZWVuVG9nZ2xlIGZyb20gJy4vZnVsbHNjcmVlbi10b2dnbGUuanMnO1xuaW1wb3J0IFZvbHVtZUNvbnRyb2wgZnJvbSAnLi92b2x1bWUtY29udHJvbC92b2x1bWUtY29udHJvbC5qcyc7XG5pbXBvcnQgVm9sdW1lTWVudUJ1dHRvbiBmcm9tICcuL3ZvbHVtZS1tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgTXV0ZVRvZ2dsZSBmcm9tICcuL211dGUtdG9nZ2xlLmpzJztcbmltcG9ydCBDaGFwdGVyc0J1dHRvbiBmcm9tICcuL3RleHQtdHJhY2stY29udHJvbHMvY2hhcHRlcnMtYnV0dG9uLmpzJztcbmltcG9ydCBTdWJ0aXRsZXNCdXR0b24gZnJvbSAnLi90ZXh0LXRyYWNrLWNvbnRyb2xzL3N1YnRpdGxlcy1idXR0b24uanMnO1xuaW1wb3J0IENhcHRpb25zQnV0dG9uIGZyb20gJy4vdGV4dC10cmFjay1jb250cm9scy9jYXB0aW9ucy1idXR0b24uanMnO1xuaW1wb3J0IFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gZnJvbSAnLi9wbGF5YmFjay1yYXRlLW1lbnUvcGxheWJhY2stcmF0ZS1tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgQ3VzdG9tQ29udHJvbFNwYWNlciBmcm9tICcuL3NwYWNlci1jb250cm9scy9jdXN0b20tY29udHJvbC1zcGFjZXIuanMnO1xuXG4vKipcbiAqIENvbnRhaW5lciBvZiBtYWluIGNvbnRyb2xzXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmNsYXNzIENvbnRyb2xCYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gTGliLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC1iYXInXG4gICAgfSk7XG4gIH1cbn1cblxuQ29udHJvbEJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGxvYWRFdmVudDogJ3BsYXknLFxuICBjaGlsZHJlbjogW1xuICAgICdwbGF5VG9nZ2xlJyxcbiAgICAnY3VycmVudFRpbWVEaXNwbGF5JyxcbiAgICAndGltZURpdmlkZXInLFxuICAgICdkdXJhdGlvbkRpc3BsYXknLFxuICAgICdwcm9ncmVzc0NvbnRyb2wnLFxuICAgICdsaXZlRGlzcGxheScsXG4gICAgJ3JlbWFpbmluZ1RpbWVEaXNwbGF5JyxcbiAgICAnY3VzdG9tQ29udHJvbFNwYWNlcicsXG4gICAgJ3BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLFxuICAgICdtdXRlVG9nZ2xlJyxcbiAgICAndm9sdW1lQ29udHJvbCcsXG4gICAgJ2NoYXB0ZXJzQnV0dG9uJyxcbiAgICAnc3VidGl0bGVzQnV0dG9uJyxcbiAgICAnY2FwdGlvbnNCdXR0b24nLFxuICAgICd2b2x1bWVNZW51QnV0dG9uJyxcbiAgICAnZnVsbHNjcmVlblRvZ2dsZSdcbiAgXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb250cm9sQmFyJywgQ29udHJvbEJhcik7XG5leHBvcnQgZGVmYXVsdCBDb250cm9sQmFyO1xuIiwiaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24nO1xuXG4vKipcbiAqIFRvZ2dsZSBmdWxsc2NyZWVuIHZpZGVvXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIHZqcy5CdXR0b25cbiAqL1xuY2xhc3MgRnVsbHNjcmVlblRvZ2dsZSBleHRlbmRzIEJ1dHRvbiB7XG5cbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gYHZqcy1mdWxsc2NyZWVuLWNvbnRyb2wgJHtzdXBlci5idWlsZENTU0NsYXNzKCl9YDtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgIHRoaXMuY29udHJvbFRleHRfLmlubmVySFRNTCA9IHRoaXMubG9jYWxpemUoJ05vbi1GdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgdGhpcy5jb250cm9sVGV4dF8uaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgnRnVsbHNjcmVlbicpO1xuICAgIH1cbiAgfVxuXG59XG5cbkZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnRnVsbHNjcmVlbic7XG5cbkJ1dHRvbi5yZWdpc3RlckNvbXBvbmVudCgnRnVsbHNjcmVlblRvZ2dsZScsIEZ1bGxzY3JlZW5Ub2dnbGUpO1xuZXhwb3J0IGRlZmF1bHQgRnVsbHNjcmVlblRvZ2dsZTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi9saWInO1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSBsaXZlIGluZGljYXRvclxuICogVE9ETyAtIEZ1dHVyZSBtYWtlIGl0IGNsaWNrIHRvIHNuYXAgdG8gbGl2ZVxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIExpdmVEaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjcmVhdGVFbCgpIHtcbiAgICB2YXIgZWwgPSBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxpdmUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IExpYi5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxpdmUtZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke3RoaXMubG9jYWxpemUoJ1N0cmVhbSBUeXBlJyl9PC9zcGFuPiR7dGhpcy5sb2NhbGl6ZSgnTElWRScpfWAsXG4gICAgICAnYXJpYS1saXZlJzogJ29mZidcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xpdmVEaXNwbGF5JywgTGl2ZURpc3BsYXkpO1xuZXhwb3J0IGRlZmF1bHQgTGl2ZURpc3BsYXk7XG4iLCJpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbic7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliJztcblxuLyoqXG4gKiBBIGJ1dHRvbiBjb21wb25lbnQgZm9yIG11dGluZyB0aGUgYXVkaW9cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTXV0ZVRvZ2dsZSBleHRlbmRzIEJ1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMub24ocGxheWVyLCAndm9sdW1lY2hhbmdlJywgdGhpcy51cGRhdGUpO1xuXG4gICAgLy8gaGlkZSBtdXRlIHRvZ2dsZSBpZiB0aGUgY3VycmVudCB0ZWNoIGRvZXNuJ3Qgc3VwcG9ydCB2b2x1bWUgY29udHJvbFxuICAgIGlmIChwbGF5ZXIudGVjaCAmJiBwbGF5ZXIudGVjaFsnZmVhdHVyZXNWb2x1bWVDb250cm9sJ10gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vbihwbGF5ZXIsICdsb2Fkc3RhcnQnLCBmdW5jdGlvbigpe1xuICAgICAgaWYgKHBsYXllci50ZWNoWydmZWF0dXJlc1ZvbHVtZUNvbnRyb2wnXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxuICAgICAgaW5uZXJIVE1MOiBgPGRpdj48c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke3RoaXMubG9jYWxpemUoJ011dGUnKX08L3NwYW4+PC9kaXY+YFxuICAgIH0pO1xuICB9XG5cbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gYHZqcy1tdXRlLWNvbnRyb2wgJHtzdXBlci5idWlsZENTU0NsYXNzKCl9YDtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMucGxheWVyXy5tdXRlZCggdGhpcy5wbGF5ZXJfLm11dGVkKCkgPyBmYWxzZSA6IHRydWUgKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB2YXIgdm9sID0gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpLFxuICAgICAgICBsZXZlbCA9IDM7XG5cbiAgICBpZiAodm9sID09PSAwIHx8IHRoaXMucGxheWVyXy5tdXRlZCgpKSB7XG4gICAgICBsZXZlbCA9IDA7XG4gICAgfSBlbHNlIGlmICh2b2wgPCAwLjMzKSB7XG4gICAgICBsZXZlbCA9IDE7XG4gICAgfSBlbHNlIGlmICh2b2wgPCAwLjY3KSB7XG4gICAgICBsZXZlbCA9IDI7XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgcmV3cml0ZSB0aGUgYnV0dG9uIHRleHQgaWYgdGhlIGFjdHVhbCB0ZXh0IGRvZXNuJ3QgY2hhbmdlLlxuICAgIC8vIFRoaXMgY2F1c2VzIHVubmVjZXNzYXJ5IGFuZCBjb25mdXNpbmcgaW5mb3JtYXRpb24gZm9yIHNjcmVlbiByZWFkZXIgdXNlcnMuXG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHZvbHVtZSBsZXZlbCBpcyBjaGFuZ2VkLlxuICAgIGxldCB0b011dGUgPSB0aGlzLnBsYXllcl8ubXV0ZWQoKSA/ICdVbm11dGUnIDogJ011dGUnO1xuICAgIGxldCBsb2NhbGl6ZWRNdXRlID0gdGhpcy5sb2NhbGl6ZSh0b011dGUpO1xuICAgIGlmICh0aGlzLmVsXy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgIT09IGxvY2FsaXplZE11dGUpIHtcbiAgICAgIHRoaXMuZWxfLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmlubmVySFRNTCA9IGxvY2FsaXplZE11dGU7XG4gICAgfVxuXG4gICAgLyogVE9ETyBpbXByb3ZlIG11dGVkIGljb24gY2xhc3NlcyAqL1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBMaWIucmVtb3ZlQ2xhc3ModGhpcy5lbF8sIGB2anMtdm9sLSR7aX1gKTtcbiAgICB9XG4gICAgTGliLmFkZENsYXNzKHRoaXMuZWxfLCBgdmpzLXZvbC0ke2xldmVsfWApO1xuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNdXRlVG9nZ2xlJywgTXV0ZVRvZ2dsZSk7XG5leHBvcnQgZGVmYXVsdCBNdXRlVG9nZ2xlO1xuIiwiaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24nO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5cbi8qKlxuICogQnV0dG9uIHRvIHRvZ2dsZSBiZXR3ZWVuIHBsYXkgYW5kIHBhdXNlXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQbGF5VG9nZ2xlIGV4dGVuZHMgQnV0dG9uIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ3BsYXknLCB0aGlzLmhhbmRsZVBsYXkpO1xuICAgIHRoaXMub24ocGxheWVyLCAncGF1c2UnLCB0aGlzLmhhbmRsZVBhdXNlKTtcbiAgfVxuXG4gIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIGB2anMtcGxheS1jb250cm9sICR7c3VwZXIuYnVpbGRDU1NDbGFzcygpfWA7XG4gIH1cblxuICAvLyBoYW5kbGVDbGljayAtIFRvZ2dsZSBiZXR3ZWVuIHBsYXkgYW5kIHBhdXNlXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZVBsYXkgLSBBZGQgdGhlIHZqcy1wbGF5aW5nIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZVxuICBoYW5kbGVQbGF5KCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuZWxfLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmlubmVySFRNTCA9IHRoaXMubG9jYWxpemUoJ1BhdXNlJyk7IC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQYXVzZVwiXG4gIH1cblxuICAvLyBoYW5kbGVQYXVzZSAtIEFkZCB0aGUgdmpzLXBhdXNlZCBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2VcbiAgaGFuZGxlUGF1c2UoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgdGhpcy5lbF8uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgnUGxheScpOyAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUGxheVwiXG4gIH1cblxufVxuXG5QbGF5VG9nZ2xlLnByb3RvdHlwZS5idXR0b25UZXh0ID0gJ1BsYXknO1xuXG5CdXR0b24ucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXlUb2dnbGUnLCBQbGF5VG9nZ2xlKTtcbmV4cG9ydCBkZWZhdWx0IFBsYXlUb2dnbGU7XG4iLCJpbXBvcnQgTWVudUJ1dHRvbiBmcm9tICcuLi8uLi9tZW51L21lbnUtYnV0dG9uLmpzJztcbmltcG9ydCBNZW51IGZyb20gJy4uLy4uL21lbnUvbWVudS5qcyc7XG5pbXBvcnQgUGxheWJhY2tSYXRlTWVudUl0ZW0gZnJvbSAnLi9wbGF5YmFjay1yYXRlLW1lbnUtaXRlbS5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vLi4vbGliLmpzJztcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgcGxheWJhY2sgcmF0ZVxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQbGF5YmFja1JhdGVNZW51QnV0dG9uIGV4dGVuZHMgTWVudUJ1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgdGhpcy51cGRhdGVMYWJlbCgpO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICdsb2Fkc3RhcnQnLCB0aGlzLnVwZGF0ZVZpc2liaWxpdHkpO1xuICAgIHRoaXMub24ocGxheWVyLCAncmF0ZWNoYW5nZScsIHRoaXMudXBkYXRlTGFiZWwpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGVsID0gc3VwZXIuY3JlYXRlRWwoKTtcblxuICAgIHRoaXMubGFiZWxFbF8gPSBMaWIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wbGF5YmFjay1yYXRlLXZhbHVlJyxcbiAgICAgIGlubmVySFRNTDogMS4wXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsRWxfKTtcblxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8vIE1lbnUgY3JlYXRpb25cbiAgY3JlYXRlTWVudSgpIHtcbiAgICBsZXQgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyKCkpO1xuICAgIGxldCByYXRlcyA9IHRoaXMucGxheWVyKCkub3B0aW9ucygpWydwbGF5YmFja1JhdGVzJ107XG5cbiAgICBpZiAocmF0ZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSByYXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZW51LmFkZENoaWxkKFxuICAgICAgICAgIG5ldyBQbGF5YmFja1JhdGVNZW51SXRlbSh0aGlzLnBsYXllcigpLCB7ICdyYXRlJzogcmF0ZXNbaV0gKyAneCd9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZW51O1xuICB9XG5cbiAgdXBkYXRlQVJJQUF0dHJpYnV0ZXMoKSB7XG4gICAgLy8gQ3VycmVudCBwbGF5YmFjayByYXRlXG4gICAgdGhpcy5lbCgpLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkpO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgLy8gc2VsZWN0IG5leHQgcmF0ZSBvcHRpb25cbiAgICBsZXQgY3VycmVudFJhdGUgPSB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpO1xuICAgIGxldCByYXRlcyA9IHRoaXMucGxheWVyKCkub3B0aW9ucygpWydwbGF5YmFja1JhdGVzJ107XG4gICAgLy8gdGhpcyB3aWxsIHNlbGVjdCBmaXJzdCBvbmUgaWYgdGhlIGxhc3Qgb25lIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgIGxldCBuZXdSYXRlID0gcmF0ZXNbMF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPHJhdGVzLmxlbmd0aCA7IGkrKykge1xuICAgICAgaWYgKHJhdGVzW2ldID4gY3VycmVudFJhdGUpIHtcbiAgICAgICAgbmV3UmF0ZSA9IHJhdGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUobmV3UmF0ZSk7XG4gIH1cblxuICBwbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyKCkudGVjaFxuICAgICAgJiYgdGhpcy5wbGF5ZXIoKS50ZWNoWydmZWF0dXJlc1BsYXliYWNrUmF0ZSddXG4gICAgICAmJiB0aGlzLnBsYXllcigpLm9wdGlvbnMoKVsncGxheWJhY2tSYXRlcyddXG4gICAgICAmJiB0aGlzLnBsYXllcigpLm9wdGlvbnMoKVsncGxheWJhY2tSYXRlcyddLmxlbmd0aCA+IDBcbiAgICA7XG4gIH1cblxuICAvKipcbiAgICogSGlkZSBwbGF5YmFjayByYXRlIGNvbnRyb2xzIHdoZW4gdGhleSdyZSBubyBwbGF5YmFjayByYXRlIG9wdGlvbnMgdG8gc2VsZWN0XG4gICAqL1xuICB1cGRhdGVWaXNpYmlsaXR5KCkge1xuICAgIGlmICh0aGlzLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGJ1dHRvbiBsYWJlbCB3aGVuIHJhdGUgY2hhbmdlZFxuICAgKi9cbiAgdXBkYXRlTGFiZWwoKSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMubGFiZWxFbF8uaW5uZXJIVE1MID0gdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSArICd4JztcbiAgICB9XG4gIH1cblxufVxuXG5QbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5idXR0b25UZXh0ID0gJ1BsYXliYWNrIFJhdGUnO1xuUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ3Zqcy1wbGF5YmFjay1yYXRlJztcblxuTWVudUJ1dHRvbi5yZWdpc3RlckNvbXBvbmVudCgnUGxheWJhY2tSYXRlTWVudUJ1dHRvbicsIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24pO1xuZXhwb3J0IGRlZmF1bHQgUGxheWJhY2tSYXRlTWVudUJ1dHRvbjtcbiIsImltcG9ydCBNZW51SXRlbSBmcm9tICcuLi8uLi9tZW51L21lbnUtaXRlbS5qcyc7XG5cbi8qKlxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBwbGF5YmFjayByYXRlXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFBsYXliYWNrUmF0ZU1lbnVJdGVtIGV4dGVuZHMgTWVudUl0ZW0ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgbGV0IGxhYmVsID0gb3B0aW9uc1sncmF0ZSddO1xuICAgIGxldCByYXRlID0gcGFyc2VGbG9hdChsYWJlbCwgMTApO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9uc1snbGFiZWwnXSA9IGxhYmVsO1xuICAgIG9wdGlvbnNbJ3NlbGVjdGVkJ10gPSByYXRlID09PSAxO1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5yYXRlID0gcmF0ZTtcblxuICAgIHRoaXMub24ocGxheWVyLCAncmF0ZWNoYW5nZScsIHRoaXMudXBkYXRlKTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIHN1cGVyLmhhbmRsZUNsaWNrKCk7XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUodGhpcy5yYXRlKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkgPT09IHRoaXMucmF0ZSk7XG4gIH1cblxufVxuXG5QbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUuY29udGVudEVsVHlwZSA9ICdidXR0b24nO1xuXG5NZW51SXRlbS5yZWdpc3RlckNvbXBvbmVudCgnUGxheWJhY2tSYXRlTWVudUl0ZW0nLCBQbGF5YmFja1JhdGVNZW51SXRlbSk7XG5leHBvcnQgZGVmYXVsdCBQbGF5YmFja1JhdGVNZW51SXRlbTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG4vKipcbiAqIFNob3dzIGxvYWQgcHJvZ3Jlc3NcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTG9hZFByb2dyZXNzQmFyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdwcm9ncmVzcycsIHRoaXMudXBkYXRlKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWQtcHJvZ3Jlc3MnLFxuICAgICAgaW5uZXJIVE1MOiBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JHt0aGlzLmxvY2FsaXplKCdMb2FkZWQnKX08L3NwYW4+OiAwJTwvc3Bhbj5gXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgbGV0IGJ1ZmZlcmVkID0gdGhpcy5wbGF5ZXJfLmJ1ZmZlcmVkKCk7XG4gICAgbGV0IGR1cmF0aW9uID0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgbGV0IGJ1ZmZlcmVkRW5kID0gdGhpcy5wbGF5ZXJfLmJ1ZmZlcmVkRW5kKCk7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5lbF8uY2hpbGRyZW47XG5cbiAgICAvLyBnZXQgdGhlIHBlcmNlbnQgd2lkdGggb2YgYSB0aW1lIGNvbXBhcmVkIHRvIHRoZSB0b3RhbCBlbmRcbiAgICBsZXQgcGVyY2VudGlmeSA9IGZ1bmN0aW9uICh0aW1lLCBlbmQpe1xuICAgICAgbGV0IHBlcmNlbnQgPSAodGltZSAvIGVuZCkgfHwgMDsgLy8gbm8gTmFOXG4gICAgICByZXR1cm4gKChwZXJjZW50ID49IDEgPyAxIDogcGVyY2VudCkgKiAxMDApICsgJyUnO1xuICAgIH07XG5cbiAgICAvLyB1cGRhdGUgdGhlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBiYXJcbiAgICB0aGlzLmVsXy5zdHlsZS53aWR0aCA9IHBlcmNlbnRpZnkoYnVmZmVyZWRFbmQsIGR1cmF0aW9uKTtcblxuICAgIC8vIGFkZCBjaGlsZCBlbGVtZW50cyB0byByZXByZXNlbnQgdGhlIGluZGl2aWR1YWwgYnVmZmVyZWQgdGltZSByYW5nZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc3RhcnQgPSBidWZmZXJlZC5zdGFydChpKTtcbiAgICAgIGxldCBlbmQgPSBidWZmZXJlZC5lbmQoaSk7XG4gICAgICBsZXQgcGFydCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgcGFydCA9IHRoaXMuZWxfLmFwcGVuZENoaWxkKExpYi5jcmVhdGVFbCgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBwZXJjZW50IGJhc2VkIG9uIHRoZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyIChidWZmZXJlZEVuZClcbiAgICAgIHBhcnQuc3R5bGUubGVmdCA9IHBlcmNlbnRpZnkoc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICAgIHBhcnQuc3R5bGUud2lkdGggPSBwZXJjZW50aWZ5KGVuZCAtIHN0YXJ0LCBidWZmZXJlZEVuZCk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVudXNlZCBidWZmZXJlZCByYW5nZSBlbGVtZW50c1xuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPiBidWZmZXJlZC5sZW5ndGg7IGktLSkge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQ2hpbGQoY2hpbGRyZW5baS0xXSk7XG4gICAgfVxuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdMb2FkUHJvZ3Jlc3NCYXInLCBMb2FkUHJvZ3Jlc3NCYXIpO1xuZXhwb3J0IGRlZmF1bHQgTG9hZFByb2dyZXNzQmFyO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuXG4vKipcbiAqIFNob3dzIHBsYXkgcHJvZ3Jlc3NcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUGxheVByb2dyZXNzQmFyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wbGF5LXByb2dyZXNzJyxcbiAgICAgIGlubmVySFRNTDogYDxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjxzcGFuPiR7dGhpcy5sb2NhbGl6ZSgnUHJvZ3Jlc3MnKX08L3NwYW4+OiAwJTwvc3Bhbj5gXG4gICAgfSk7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXlQcm9ncmVzc0JhcicsIFBsYXlQcm9ncmVzc0Jhcik7XG5leHBvcnQgZGVmYXVsdCBQbGF5UHJvZ3Jlc3NCYXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgU2Vla0JhciBmcm9tICcuL3NlZWstYmFyLmpzJztcblxuLyoqXG4gKiBUaGUgUHJvZ3Jlc3MgQ29udHJvbCBjb21wb25lbnQgY29udGFpbnMgdGhlIHNlZWsgYmFyLCBsb2FkIHByb2dyZXNzLFxuICogYW5kIHBsYXkgcHJvZ3Jlc3NcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUHJvZ3Jlc3NDb250cm9sIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcbiAgfVxufVxuXG5Qcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjoge1xuICAgICdzZWVrQmFyJzoge31cbiAgfVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQcm9ncmVzc0NvbnRyb2wnLCBQcm9ncmVzc0NvbnRyb2wpO1xuZXhwb3J0IGRlZmF1bHQgUHJvZ3Jlc3NDb250cm9sO1xuIiwiaW1wb3J0IFNsaWRlciBmcm9tICcuLi8uLi9zbGlkZXIvc2xpZGVyLmpzJztcbmltcG9ydCBMb2FkUHJvZ3Jlc3NCYXIgZnJvbSAnLi9sb2FkLXByb2dyZXNzLWJhci5qcyc7XG5pbXBvcnQgUGxheVByb2dyZXNzQmFyIGZyb20gJy4vcGxheS1wcm9ncmVzcy1iYXIuanMnO1xuaW1wb3J0IFNlZWtIYW5kbGUgZnJvbSAnLi9zZWVrLWhhbmRsZS5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vLi4vbGliLmpzJztcblxuLyoqXG4gKiBTZWVrIEJhciBhbmQgaG9sZGVyIGZvciB0aGUgcHJvZ3Jlc3MgYmFyc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTZWVrQmFyIGV4dGVuZHMgU2xpZGVyIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGVBUklBQXR0cmlidXRlcyk7XG4gICAgcGxheWVyLnJlYWR5KExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMpKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXByb2dyZXNzLWhvbGRlcicsXG4gICAgICAnYXJpYS1sYWJlbCc6ICd2aWRlbyBwcm9ncmVzcyBiYXInXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVBUklBQXR0cmlidXRlcygpIHtcbiAgICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICAgIGxldCB0aW1lID0gKHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSkgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgTGliLnJvdW5kKHRoaXMuZ2V0UGVyY2VudCgpKjEwMCwgMikpOyAvLyBtYWNoaW5lIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAocGVyY2VudGFnZSBjb21wbGV0ZSlcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCBMaWIuZm9ybWF0VGltZSh0aW1lLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkpOyAvLyBodW1hbiByZWFkYWJsZSB2YWx1ZSBvZiBwcm9ncmVzcyBiYXIgKHRpbWUgY29tcGxldGUpXG4gIH1cblxuICBnZXRQZXJjZW50KCkge1xuICAgIGxldCBwZXJjZW50ID0gdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICByZXR1cm4gcGVyY2VudCA+PSAxID8gMSA6IHBlcmNlbnQ7XG4gIH1cblxuICBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICBzdXBlci5oYW5kbGVNb3VzZURvd24oZXZlbnQpO1xuXG4gICAgdGhpcy5wbGF5ZXJfLnNjcnViYmluZyh0cnVlKTtcblxuICAgIHRoaXMudmlkZW9XYXNQbGF5aW5nID0gIXRoaXMucGxheWVyXy5wYXVzZWQoKTtcbiAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcbiAgfVxuXG4gIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIGxldCBuZXdUaW1lID0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShldmVudCkgKiB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcblxuICAgIC8vIERvbid0IGxldCB2aWRlbyBlbmQgd2hpbGUgc2NydWJiaW5nLlxuICAgIGlmIChuZXdUaW1lID09PSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkgeyBuZXdUaW1lID0gbmV3VGltZSAtIDAuMTsgfVxuXG4gICAgLy8gU2V0IG5ldyB0aW1lICh0ZWxsIHBsYXllciB0byBzZWVrIHRvIG5ldyB0aW1lKVxuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZShuZXdUaW1lKTtcbiAgfVxuXG4gIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcbiAgICBzdXBlci5oYW5kbGVNb3VzZVVwKGV2ZW50KTtcblxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoZmFsc2UpO1xuICAgIGlmICh0aGlzLnZpZGVvV2FzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9XG4gIH1cblxuICBzdGVwRm9yd2FyZCgpIHtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgKyA1KTsgLy8gbW9yZSBxdWlja2x5IGZhc3QgZm9yd2FyZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICB9XG5cbiAgc3RlcEJhY2soKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC0gNSk7IC8vIG1vcmUgcXVpY2tseSByZXdpbmQgZm9yIGtleWJvYXJkLW9ubHkgdXNlcnNcbiAgfVxuXG59XG5cblNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjoge1xuICAgICdsb2FkUHJvZ3Jlc3NCYXInOiB7fSxcbiAgICAncGxheVByb2dyZXNzQmFyJzoge30sXG4gICAgJ3NlZWtIYW5kbGUnOiB7fVxuICB9LFxuICAnYmFyTmFtZSc6ICdwbGF5UHJvZ3Jlc3NCYXInLFxuICAnaGFuZGxlTmFtZSc6ICdzZWVrSGFuZGxlJ1xufTtcblxuU2Vla0Jhci5wcm90b3R5cGUucGxheWVyRXZlbnQgPSAndGltZXVwZGF0ZSc7XG5cblNsaWRlci5yZWdpc3RlckNvbXBvbmVudCgnU2Vla0JhcicsIFNlZWtCYXIpO1xuZXhwb3J0IGRlZmF1bHQgU2Vla0JhcjtcbiIsImltcG9ydCBTbGlkZXJIYW5kbGUgZnJvbSAnLi4vLi4vc2xpZGVyL3NsaWRlci1oYW5kbGUuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uLy4uL2xpYi5qcyc7XG5cbi8qKlxuICogVGhlIFNlZWsgSGFuZGxlIHNob3dzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZCBkdXJpbmcgcGxheWJhY2ssXG4gKiBhbmQgY2FuIGJlIGRyYWdnZWQgdG8gYWRqdXN0IHRoZSBwbGF5aGVhZC5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU2Vla0hhbmRsZSBleHRlbmRzIFNsaWRlckhhbmRsZSB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXNlZWstaGFuZGxlJyxcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlQ29udGVudCgpIHtcbiAgICBsZXQgdGltZSA9ICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgdGhpcy5lbF8uaW5uZXJIVE1MID0gYDxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiR7TGliLmZvcm1hdFRpbWUodGltZSwgdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpfTwvc3Bhbj5gO1xuICB9XG5cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGhhbmRsZSBjb250ZW50LCB3aGljaCBtYXkgYmUgcmVhZCBieSBzY3JlZW4gcmVhZGVyc1xuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5TZWVrSGFuZGxlLnByb3RvdHlwZS5kZWZhdWx0VmFsdWUgPSAnMDA6MDAnO1xuXG5TbGlkZXJIYW5kbGUucmVnaXN0ZXJDb21wb25lbnQoJ1NlZWtIYW5kbGUnLCBTZWVrSGFuZGxlKTtcbmV4cG9ydCBkZWZhdWx0IFNlZWtIYW5kbGU7XG4iLCJpbXBvcnQgU3BhY2VyIGZyb20gJy4vc3BhY2VyLmpzJztcblxuLyoqXG4gKiBTcGFjZXIgc3BlY2lmaWNhbGx5IG1lYW50IHRvIGJlIHVzZWQgYXMgYW4gaW5zZXJ0aW9uIHBvaW50IGZvciBuZXcgcGx1Z2lucywgZXRjLlxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iZWN0PX0gb3B0aW9uc1xuICovXG5jbGFzcyBDdXN0b21Db250cm9sU3BhY2VyIGV4dGVuZHMgU3BhY2VyIHtcbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gYHZqcy1jdXN0b20tY29udHJvbC1zcGFjZXIgJHtzdXBlci5idWlsZENTU0NsYXNzKCl9YDtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCh7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpXG4gICAgfSk7XG4gIH1cbn1cblxuU3BhY2VyLnJlZ2lzdGVyQ29tcG9uZW50KCdDdXN0b21Db250cm9sU3BhY2VyJywgQ3VzdG9tQ29udHJvbFNwYWNlcik7XG5cbmV4cG9ydCBkZWZhdWx0IEN1c3RvbUNvbnRyb2xTcGFjZXI7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5cbi8qKlxuICogSnVzdCBhbiBlbXB0eSBzcGFjZXIgZWxlbWVudCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGFwcGVuZCBwb2ludCBmb3IgcGx1Z2lucywgZXRjLlxuICogQWxzbyBjYW4gYmUgdXNlZCB0byBjcmVhdGUgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKi9cbmNsYXNzIFNwYWNlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIGB2anMtc3BhY2VyICR7c3VwZXIuYnVpbGRDU1NDbGFzcygpfWA7XG4gIH1cblxuICBjcmVhdGVFbChwcm9wcykge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuICB9XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3BhY2VyJywgU3BhY2VyKTtcblxuZXhwb3J0IGRlZmF1bHQgU3BhY2VyO1xuIiwiaW1wb3J0IFRleHRUcmFja01lbnVJdGVtIGZyb20gJy4vdGV4dC10cmFjay1tZW51LWl0ZW0uanMnO1xuXG5jbGFzcyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSBleHRlbmRzIFRleHRUcmFja01lbnVJdGVtIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zWyd0cmFjayddID0ge1xuICAgICAgJ2tpbmQnOiBvcHRpb25zWydraW5kJ10sXG4gICAgICAncGxheWVyJzogcGxheWVyLFxuICAgICAgJ2xhYmVsJzogb3B0aW9uc1sna2luZCddICsgJyBzZXR0aW5ncycsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy10ZXh0dHJhY2stc2V0dGluZ3MnKTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMucGxheWVyKCkuZ2V0Q2hpbGQoJ3RleHRUcmFja1NldHRpbmdzJykuc2hvdygpO1xuICB9XG5cbn1cblxuVGV4dFRyYWNrTWVudUl0ZW0ucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJywgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0pO1xuZXhwb3J0IGRlZmF1bHQgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW07XG4iLCJpbXBvcnQgVGV4dFRyYWNrQnV0dG9uIGZyb20gJy4vdGV4dC10cmFjay1idXR0b24uanMnO1xuaW1wb3J0IENhcHRpb25TZXR0aW5nc01lbnVJdGVtIGZyb20gJy4vY2FwdGlvbi1zZXR0aW5ncy1tZW51LWl0ZW0uanMnO1xuXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGNhcHRpb25zXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIENhcHRpb25zQnV0dG9uIGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCdDYXB0aW9ucyBNZW51Jyk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgbGV0IHRocmVzaG9sZCA9IDI7XG4gICAgc3VwZXIudXBkYXRlKCk7XG5cbiAgICAvLyBpZiBuYXRpdmUsIHRoZW4gdGhyZXNob2xkIGlzIDEgYmVjYXVzZSBubyBzZXR0aW5ncyBidXR0b25cbiAgICBpZiAodGhpcy5wbGF5ZXIoKS50ZWNoICYmIHRoaXMucGxheWVyKCkudGVjaFsnZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10pIHtcbiAgICAgIHRocmVzaG9sZCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtcy5sZW5ndGggPiB0aHJlc2hvbGQpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVJdGVtcygpIHtcbiAgICBsZXQgaXRlbXMgPSBbXTtcblxuICAgIGlmICghKHRoaXMucGxheWVyKCkudGVjaCAmJiB0aGlzLnBsYXllcigpLnRlY2hbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSkge1xuICAgICAgaXRlbXMucHVzaChuZXcgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7ICdraW5kJzogdGhpcy5raW5kXyB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUl0ZW1zKGl0ZW1zKTtcbiAgfVxuXG59XG5cbkNhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdjYXB0aW9ucyc7XG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnV0dG9uVGV4dCA9ICdDYXB0aW9ucyc7XG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ3Zqcy1jYXB0aW9ucy1idXR0b24nO1xuXG5UZXh0VHJhY2tCdXR0b24ucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25zQnV0dG9uJywgQ2FwdGlvbnNCdXR0b24pO1xuZXhwb3J0IGRlZmF1bHQgQ2FwdGlvbnNCdXR0b247XG4iLCJpbXBvcnQgVGV4dFRyYWNrQnV0dG9uIGZyb20gJy4vdGV4dC10cmFjay1idXR0b24uanMnO1xuaW1wb3J0IFRleHRUcmFja01lbnVJdGVtIGZyb20gJy4vdGV4dC10cmFjay1tZW51LWl0ZW0uanMnO1xuaW1wb3J0IENoYXB0ZXJzVHJhY2tNZW51SXRlbSBmcm9tICcuL2NoYXB0ZXJzLXRyYWNrLW1lbnUtaXRlbS5qcyc7XG5pbXBvcnQgTWVudSBmcm9tICcuLi8uLi9tZW51L21lbnUuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uLy4uL2xpYi5qcyc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG4vLyBDaGFwdGVycyBhY3QgbXVjaCBkaWZmZXJlbnRseSB0aGFuIG90aGVyIHRleHQgdHJhY2tzXG4vLyBDdWVzIGFyZSBuYXZpZ2F0aW9uIHZzLiBvdGhlciB0cmFja3Mgb2YgYWx0ZXJuYXRpdmUgbGFuZ3VhZ2VzXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGNoYXB0ZXJzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIENoYXB0ZXJzQnV0dG9uIGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCdDaGFwdGVycyBNZW51Jyk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICBjcmVhdGVJdGVtcygpIHtcbiAgICBsZXQgaXRlbXMgPSBbXTtcblxuICAgIGxldCB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHRyYWNrWydraW5kJ10gPT09IHRoaXMua2luZF8pIHtcbiAgICAgICAgaXRlbXMucHVzaChuZXcgVGV4dFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgICAgJ3RyYWNrJzogdHJhY2tcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIGNyZWF0ZU1lbnUoKSB7XG4gICAgbGV0IHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCkgfHwgW107XG4gICAgbGV0IGNoYXB0ZXJzVHJhY2s7XG4gICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICBpZiAodHJhY2tbJ2tpbmQnXSA9PT0gdGhpcy5raW5kXykge1xuICAgICAgICBpZiAoIXRyYWNrLmN1ZXMpIHtcbiAgICAgICAgICB0cmFja1snbW9kZSddID0gJ2hpZGRlbic7XG4gICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gZmlndXJlIG91dCBhIGJldHRlciB3YXkgb2YgZG9pbmcgdGhpcyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMTg2NFxuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVNZW51KCk7XG4gICAgICAgICAgfSksIDEwMCk7XG4gICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOmZhbHNlICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhcHRlcnNUcmFjayA9IHRyYWNrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1lbnUgPSB0aGlzLm1lbnU7XG4gICAgaWYgKG1lbnUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyXyk7XG4gICAgICBtZW51LmNvbnRlbnRFbCgpLmFwcGVuZENoaWxkKExpYi5jcmVhdGVFbCgnbGknLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LXRpdGxlJyxcbiAgICAgICAgaW5uZXJIVE1MOiBMaWIuY2FwaXRhbGl6ZSh0aGlzLmtpbmRfKSxcbiAgICAgICAgdGFiaW5kZXg6IC0xXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKGNoYXB0ZXJzVHJhY2spIHtcbiAgICAgIGxldCBjdWVzID0gY2hhcHRlcnNUcmFja1snY3VlcyddLCBjdWU7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3VlID0gY3Vlc1tpXTtcblxuICAgICAgICBsZXQgbWkgPSBuZXcgQ2hhcHRlcnNUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAgICAgICd0cmFjayc6IGNoYXB0ZXJzVHJhY2ssXG4gICAgICAgICAgJ2N1ZSc6IGN1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtcy5wdXNoKG1pKTtcblxuICAgICAgICBtZW51LmFkZENoaWxkKG1pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkQ2hpbGQobWVudSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH1cblxufVxuXG5DaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2hhcHRlcnMnO1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmJ1dHRvblRleHQgPSAnQ2hhcHRlcnMnO1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNsYXNzTmFtZSA9ICd2anMtY2hhcHRlcnMtYnV0dG9uJztcblxuVGV4dFRyYWNrQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdDaGFwdGVyc0J1dHRvbicsIENoYXB0ZXJzQnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IENoYXB0ZXJzQnV0dG9uO1xuIiwiaW1wb3J0IE1lbnVJdGVtIGZyb20gJy4uLy4uL21lbnUvbWVudS1pdGVtLmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDaGFwdGVyc1RyYWNrTWVudUl0ZW0gZXh0ZW5kcyBNZW51SXRlbSB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBsZXQgdHJhY2sgPSBvcHRpb25zWyd0cmFjayddO1xuICAgIGxldCBjdWUgPSBvcHRpb25zWydjdWUnXTtcbiAgICBsZXQgY3VycmVudFRpbWUgPSBwbGF5ZXIuY3VycmVudFRpbWUoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnNbJ2xhYmVsJ10gPSBjdWUudGV4dDtcbiAgICBvcHRpb25zWydzZWxlY3RlZCddID0gKGN1ZVsnc3RhcnRUaW1lJ10gPD0gY3VycmVudFRpbWUgJiYgY3VycmVudFRpbWUgPCBjdWVbJ2VuZFRpbWUnXSk7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcbiAgICB0aGlzLmN1ZSA9IGN1ZTtcbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZSkpO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgc3VwZXIuaGFuZGxlQ2xpY2soKTtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5jdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGxldCBjdWUgPSB0aGlzLmN1ZTtcbiAgICBsZXQgY3VycmVudFRpbWUgPSB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgIC8vIHZqcy5sb2coY3VycmVudFRpbWUsIGN1ZS5zdGFydFRpbWUpO1xuICAgIHRoaXMuc2VsZWN0ZWQoY3VlWydzdGFydFRpbWUnXSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZVsnZW5kVGltZSddKTtcbiAgfVxuXG59XG5cbk1lbnVJdGVtLnJlZ2lzdGVyQ29tcG9uZW50KCdDaGFwdGVyc1RyYWNrTWVudUl0ZW0nLCBDaGFwdGVyc1RyYWNrTWVudUl0ZW0pO1xuZXhwb3J0IGRlZmF1bHQgQ2hhcHRlcnNUcmFja01lbnVJdGVtO1xuIiwiaW1wb3J0IFRleHRUcmFja01lbnVJdGVtIGZyb20gJy4vdGV4dC10cmFjay1tZW51LWl0ZW0uanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbCBtZW51IGl0ZW0gZm9yIHR1cm5pbmcgb2YgYSBzcGVjaWZpYyB0eXBlIG9mIHRleHQgdHJhY2tcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgT2ZmVGV4dFRyYWNrTWVudUl0ZW0gZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbSB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICAvLyBDcmVhdGUgcHNldWRvIHRyYWNrIGluZm9cbiAgICAvLyBSZXF1aXJlcyBvcHRpb25zWydraW5kJ11cbiAgICBvcHRpb25zWyd0cmFjayddID0ge1xuICAgICAgJ2tpbmQnOiBvcHRpb25zWydraW5kJ10sXG4gICAgICAncGxheWVyJzogcGxheWVyLFxuICAgICAgJ2xhYmVsJzogb3B0aW9uc1sna2luZCddICsgJyBvZmYnLFxuICAgICAgJ2RlZmF1bHQnOiBmYWxzZSxcbiAgICAgICdtb2RlJzogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuc2VsZWN0ZWQodHJ1ZSk7XG4gIH1cblxuICBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpe1xuICAgIGxldCB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICBsZXQgc2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICBpZiAodHJhY2tbJ2tpbmQnXSA9PT0gdGhpcy50cmFja1sna2luZCddICYmIHRyYWNrWydtb2RlJ10gPT09ICdzaG93aW5nJykge1xuICAgICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgfVxuXG59XG5cblRleHRUcmFja01lbnVJdGVtLnJlZ2lzdGVyQ29tcG9uZW50KCdPZmZUZXh0VHJhY2tNZW51SXRlbScsIE9mZlRleHRUcmFja01lbnVJdGVtKTtcbmV4cG9ydCBkZWZhdWx0IE9mZlRleHRUcmFja01lbnVJdGVtOyIsImltcG9ydCBUZXh0VHJhY2tCdXR0b24gZnJvbSAnLi90ZXh0LXRyYWNrLWJ1dHRvbi5qcyc7XG5cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3Rpbmcgc3VidGl0bGVzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFN1YnRpdGxlc0J1dHRvbiBleHRlbmRzIFRleHRUcmFja0J1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zLCByZWFkeSl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zLCByZWFkeSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywnU3VidGl0bGVzIE1lbnUnKTtcbiAgfVxuXG59XG5cblN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnc3VidGl0bGVzJztcblN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUuYnV0dG9uVGV4dCA9ICdTdWJ0aXRsZXMnO1xuU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5jbGFzc05hbWUgPSAndmpzLXN1YnRpdGxlcy1idXR0b24nO1xuXG5UZXh0VHJhY2tCdXR0b24ucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnRpdGxlc0J1dHRvbicsIFN1YnRpdGxlc0J1dHRvbik7XG5leHBvcnQgZGVmYXVsdCBTdWJ0aXRsZXNCdXR0b247IiwiaW1wb3J0IE1lbnVCdXR0b24gZnJvbSAnLi4vLi4vbWVudS9tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vLi4vbGliLmpzJztcblxuaW1wb3J0IFRleHRUcmFja01lbnVJdGVtIGZyb20gJy4vdGV4dC10cmFjay1tZW51LWl0ZW0uanMnO1xuaW1wb3J0IE9mZlRleHRUcmFja01lbnVJdGVtIGZyb20gJy4vb2ZmLXRleHQtdHJhY2stbWVudS1pdGVtLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB0ZXh0IHRyYWNrIHR5cGVzIChlLmcuIHN1YnRpdGxlcylcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVGV4dFRyYWNrQnV0dG9uIGV4dGVuZHMgTWVudUJ1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgbGV0IHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPD0gMSkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdXBkYXRlSGFuZGxlciA9IExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcblxuICAgIHRoaXMucGxheWVyXy5vbignZGlzcG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCB0ZXh0IHRyYWNrXG4gIGNyZWF0ZUl0ZW1zKGl0ZW1zPVtdKSB7XG4gICAgLy8gQWRkIGFuIE9GRiBtZW51IGl0ZW0gdG8gdHVybiBhbGwgdHJhY2tzIG9mZlxuICAgIGl0ZW1zLnB1c2gobmV3IE9mZlRleHRUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywgeyAna2luZCc6IHRoaXMua2luZF8gfSkpO1xuXG4gICAgbGV0IHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICBpZiAoIXRyYWNrcykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIC8vIG9ubHkgYWRkIHRyYWNrcyB0aGF0IGFyZSBvZiB0aGUgYXBwcm9wcmlhdGUga2luZCBhbmQgaGF2ZSBhIGxhYmVsXG4gICAgICBpZiAodHJhY2tbJ2tpbmQnXSA9PT0gdGhpcy5raW5kXykge1xuICAgICAgICBpdGVtcy5wdXNoKG5ldyBUZXh0VHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHtcbiAgICAgICAgICAndHJhY2snOiB0cmFja1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbn1cblxuTWVudUJ1dHRvbi5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrQnV0dG9uJywgVGV4dFRyYWNrQnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IFRleHRUcmFja0J1dHRvbjtcbiIsImltcG9ydCBNZW51SXRlbSBmcm9tICcuLi8uLi9tZW51L21lbnUtaXRlbS5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vLi4vbGliLmpzJztcblxuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuXG4vKipcbiAqIFRoZSBzcGVjaWZpYyBtZW51IGl0ZW0gdHlwZSBmb3Igc2VsZWN0aW5nIGEgbGFuZ3VhZ2Ugd2l0aGluIGEgdGV4dCB0cmFjayBraW5kXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFRleHRUcmFja01lbnVJdGVtIGV4dGVuZHMgTWVudUl0ZW0ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgbGV0IHRyYWNrID0gb3B0aW9uc1sndHJhY2snXTtcbiAgICBsZXQgdHJhY2tzID0gcGxheWVyLnRleHRUcmFja3MoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnNbJ2xhYmVsJ10gPSB0cmFja1snbGFiZWwnXSB8fCB0cmFja1snbGFuZ3VhZ2UnXSB8fCAnVW5rbm93bic7XG4gICAgb3B0aW9uc1snc2VsZWN0ZWQnXSA9IHRyYWNrWydkZWZhdWx0J10gfHwgdHJhY2tbJ21vZGUnXSA9PT0gJ3Nob3dpbmcnO1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnRyYWNrID0gdHJhY2s7XG5cbiAgICBpZiAodHJhY2tzKSB7XG4gICAgICBsZXQgY2hhbmdlSGFuZGxlciA9IExpYi5iaW5kKHRoaXMsIHRoaXMuaGFuZGxlVHJhY2tzQ2hhbmdlKTtcblxuICAgICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpT1M3IGRvZXNuJ3QgZGlzcGF0Y2ggY2hhbmdlIGV2ZW50cyB0byBUZXh0VHJhY2tMaXN0cyB3aGVuIGFuXG4gICAgLy8gYXNzb2NpYXRlZCB0cmFjaydzIG1vZGUgY2hhbmdlcy4gV2l0aG91dCBzb21ldGhpbmcgbGlrZVxuICAgIC8vIE9iamVjdC5vYnNlcnZlKCkgKGFsc28gbm90IHByZXNlbnQgb24gaU9TNyksIGl0J3Mgbm90XG4gICAgLy8gcG9zc2libGUgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gdGhlIG1vZGUgYXR0cmlidXRlIGFuZCBwb2x5ZmlsbFxuICAgIC8vIHRoZSBjaGFuZ2UgZXZlbnQuIEFzIGEgcG9vciBzdWJzdGl0dXRlLCB3ZSBtYW51YWxseSBkaXNwYXRjaFxuICAgIC8vIGNoYW5nZSBldmVudHMgd2hlbmV2ZXIgdGhlIGNvbnRyb2xzIG1vZGlmeSB0aGUgbW9kZS5cbiAgICBpZiAodHJhY2tzICYmIHRyYWNrcy5vbmNoYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZXZlbnQ7XG5cbiAgICAgIHRoaXMub24oWyd0YXAnLCAnY2xpY2snXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkV2ZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIEFuZHJvaWQgMi4zIHRocm93cyBhbiBJbGxlZ2FsIENvbnN0cnVjdG9yIGVycm9yIGZvciB3aW5kb3cuRXZlbnRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgd2luZG93LkV2ZW50KCdjaGFuZ2UnKTtcbiAgICAgICAgICB9IGNhdGNoKGVycil7fVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCdjaGFuZ2UnLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgbGV0IGtpbmQgPSB0aGlzLnRyYWNrWydraW5kJ107XG4gICAgbGV0IHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICBzdXBlci5oYW5kbGVDbGljayhldmVudCk7XG5cbiAgICBpZiAoIXRyYWNrcykgcmV0dXJuO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrWydraW5kJ10gIT09IGtpbmQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFjayA9PT0gdGhpcy50cmFjaykge1xuICAgICAgICB0cmFja1snbW9kZSddID0gJ3Nob3dpbmcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2tbJ21vZGUnXSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KXtcbiAgICB0aGlzLnNlbGVjdGVkKHRoaXMudHJhY2tbJ21vZGUnXSA9PT0gJ3Nob3dpbmcnKTtcbiAgfVxuXG59XG5cbk1lbnVJdGVtLnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tNZW51SXRlbScsIFRleHRUcmFja01lbnVJdGVtKTtcbmV4cG9ydCBkZWZhdWx0IFRleHRUcmFja01lbnVJdGVtO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uLy4uL2xpYi5qcyc7XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGN1cnJlbnQgdGltZVxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEN1cnJlbnRUaW1lRGlzcGxheSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGVDb250ZW50KTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIGxldCBlbCA9IHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY3VycmVudC10aW1lIHZqcy10aW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBMaWIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jdXJyZW50LXRpbWUtZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj5DdXJyZW50IFRpbWUgPC9zcGFuPicgKyAnMDowMCcsIC8vIGxhYmVsIHRoZSBjdXJyZW50IHRpbWUgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJyAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB1cGRhdGVDb250ZW50KCkge1xuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICBsZXQgdGltZSA9ICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgbGV0IGxvY2FsaXplZFRleHQgPSB0aGlzLmxvY2FsaXplKCdDdXJyZW50IFRpbWUnKTtcbiAgICBsZXQgZm9ybWF0dGVkVGltZSA9IExpYi5mb3JtYXRUaW1lKHRpbWUsIHRoaXMucGxheWVyXy5kdXJhdGlvbigpKTtcbiAgICB0aGlzLmNvbnRlbnRFbF8uaW5uZXJIVE1MID0gYDxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiR7bG9jYWxpemVkVGV4dH08L3NwYW4+ICR7Zm9ybWF0dGVkVGltZX1gO1xuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXJyZW50VGltZURpc3BsYXknLCBDdXJyZW50VGltZURpc3BsYXkpO1xuZXhwb3J0IGRlZmF1bHQgQ3VycmVudFRpbWVEaXNwbGF5O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uLy4uL2xpYi5qcyc7XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGR1cmF0aW9uXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgRHVyYXRpb25EaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICAvLyB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgY2hhbmdlZCB0byAnZHVyYXRpb25jaGFuZ2UnIGluc3RlYWQgb2YgJ3RpbWV1cGRhdGUnIGV2ZW50dWFsbHksXG4gICAgLy8gaG93ZXZlciB0aGUgZHVyYXRpb25jaGFuZ2UgZXZlbnQgZmlyZXMgYmVmb3JlIHRoaXMucGxheWVyXy5kdXJhdGlvbigpIGlzIHNldCxcbiAgICAvLyBzbyB0aGUgdmFsdWUgY2Fubm90IGJlIHdyaXR0ZW4gb3V0IHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgIC8vIE9uY2UgdGhlIG9yZGVyIG9mIGR1cmF0aW9uY2hhbmdlIGFuZCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSBiZWluZyBzZXQgaXMgZmlndXJlZCBvdXQsXG4gICAgLy8gdGhpcyBjYW4gYmUgdXBkYXRlZC5cbiAgICB0aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGVsID0gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1kdXJhdGlvbiB2anMtdGltZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gTGliLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtZHVyYXRpb24tZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke3RoaXMubG9jYWxpemUoJ0R1cmF0aW9uIFRpbWUnKX08L3NwYW4+IDA6MDBgLCAvLyBsYWJlbCB0aGUgZHVyYXRpb24gdGltZSBmb3Igc2NyZWVuIHJlYWRlciB1c2Vyc1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnIC8vIHRlbGwgc2NyZWVuIHJlYWRlcnMgbm90IHRvIGF1dG9tYXRpY2FsbHkgcmVhZCB0aGUgdGltZSBhcyBpdCBjaGFuZ2VzXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHVwZGF0ZUNvbnRlbnQoKSB7XG4gICAgbGV0IGR1cmF0aW9uID0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICBsZXQgbG9jYWxpemVkVGV4dCA9IHRoaXMubG9jYWxpemUoJ0R1cmF0aW9uIFRpbWUnKTtcbiAgICAgIGxldCBmb3JtYXR0ZWRUaW1lID0gTGliLmZvcm1hdFRpbWUoZHVyYXRpb24pO1xuICAgICAgdGhpcy5jb250ZW50RWxfLmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke2xvY2FsaXplZFRleHR9PC9zcGFuPiAke2Zvcm1hdHRlZFRpbWV9YDsgLy8gbGFiZWwgdGhlIGR1cmF0aW9uIHRpbWUgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnNcbiAgICB9XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0R1cmF0aW9uRGlzcGxheScsIER1cmF0aW9uRGlzcGxheSk7XG5leHBvcnQgZGVmYXVsdCBEdXJhdGlvbkRpc3BsYXk7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vLi4vbGliJztcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUgdGltZSBsZWZ0IGluIHRoZSB2aWRlb1xuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJlbWFpbmluZ1RpbWVEaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgbGV0IGVsID0gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1yZW1haW5pbmctdGltZSB2anMtdGltZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gTGliLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcmVtYWluaW5nLXRpbWUtZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6IGA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4ke3RoaXMubG9jYWxpemUoJ1JlbWFpbmluZyBUaW1lJyl9PC9zcGFuPiAtMDowMGAsIC8vIGxhYmVsIHRoZSByZW1haW5pbmcgdGltZSBmb3Igc2NyZWVuIHJlYWRlciB1c2Vyc1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnIC8vIHRlbGwgc2NyZWVuIHJlYWRlcnMgbm90IHRvIGF1dG9tYXRpY2FsbHkgcmVhZCB0aGUgdGltZSBhcyBpdCBjaGFuZ2VzXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHVwZGF0ZUNvbnRlbnQoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XG4gICAgICBjb25zdCBsb2NhbGl6ZWRUZXh0ID0gdGhpcy5sb2NhbGl6ZSgnUmVtYWluaW5nIFRpbWUnKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSBMaWIuZm9ybWF0VGltZSh0aGlzLnBsYXllcl8ucmVtYWluaW5nVGltZSgpKTtcbiAgICAgIHRoaXMuY29udGVudEVsXy5pbm5lckhUTUwgPSBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JHtsb2NhbGl6ZWRUZXh0fTwvc3Bhbj4gLSR7Zm9ybWF0dGVkVGltZX1gO1xuICAgIH1cblxuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICAvLyB2YXIgdGltZSA9ICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgLy8gdGhpcy5jb250ZW50RWxfLmlubmVySFRNTCA9IHZqcy5mb3JtYXRUaW1lKHRpbWUsIHRoaXMucGxheWVyXy5kdXJhdGlvbigpKTtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUmVtYWluaW5nVGltZURpc3BsYXknLCBSZW1haW5pbmdUaW1lRGlzcGxheSk7XG5leHBvcnQgZGVmYXVsdCBSZW1haW5pbmdUaW1lRGlzcGxheTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcblxuLyoqXG4gKiBUaGUgc2VwYXJhdG9yIGJldHdlZW4gdGhlIGN1cnJlbnQgdGltZSBhbmQgZHVyYXRpb25cbiAqXG4gKiBDYW4gYmUgaGlkZGVuIGlmIGl0J3Mgbm90IG5lZWRlZCBpbiB0aGUgZGVzaWduLlxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUaW1lRGl2aWRlciBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdGltZS1jb250cm9sIHZqcy10aW1lLWRpdmlkZXInLFxuICAgICAgaW5uZXJIVE1MOiAnPGRpdj48c3Bhbj4vPC9zcGFuPjwvZGl2PidcbiAgICB9KTtcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGltZURpdmlkZXInLCBUaW1lRGl2aWRlcik7XG5leHBvcnQgZGVmYXVsdCBUaW1lRGl2aWRlcjtcbiIsImltcG9ydCBTbGlkZXIgZnJvbSAnLi4vLi4vc2xpZGVyL3NsaWRlci5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vLi4vbGliLmpzJztcblxuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbmltcG9ydCBWb2x1bWVIYW5kbGUgZnJvbSAnLi92b2x1bWUtaGFuZGxlLmpzJztcbmltcG9ydCBWb2x1bWVMZXZlbCBmcm9tICcuL3ZvbHVtZS1sZXZlbC5qcyc7XG5cbi8qKlxuICogVGhlIGJhciB0aGF0IGNvbnRhaW5zIHRoZSB2b2x1bWUgbGV2ZWwgYW5kIGNhbiBiZSBjbGlja2VkIG9uIHRvIGFkanVzdCB0aGUgbGV2ZWxcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lQmFyIGV4dGVuZHMgU2xpZGVyIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICd2b2x1bWVjaGFuZ2UnLCB0aGlzLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzKTtcbiAgICBwbGF5ZXIucmVhZHkoTGliLmJpbmQodGhpcywgdGhpcy51cGRhdGVBUklBQXR0cmlidXRlcykpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWJhcicsXG4gICAgICAnYXJpYS1sYWJlbCc6ICd2b2x1bWUgbGV2ZWwnXG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZChmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSk7XG4gIH1cblxuICBnZXRQZXJjZW50KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLnBsYXllcl8udm9sdW1lKCkgKyAwLjEpO1xuICB9XG5cbiAgc3RlcEJhY2soKSB7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLnBsYXllcl8udm9sdW1lKCkgLSAwLjEpO1xuICB9XG5cbiAgdXBkYXRlQVJJQUF0dHJpYnV0ZXMoKSB7XG4gICAgLy8gQ3VycmVudCB2YWx1ZSBvZiB2b2x1bWUgYmFyIGFzIGEgcGVyY2VudGFnZVxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIExpYi5yb3VuZCh0aGlzLnBsYXllcl8udm9sdW1lKCkqMTAwLCAyKSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIExpYi5yb3VuZCh0aGlzLnBsYXllcl8udm9sdW1lKCkqMTAwLCAyKSsnJScpO1xuICB9XG5cbn1cblxuVm9sdW1lQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IHtcbiAgICAndm9sdW1lTGV2ZWwnOiB7fSxcbiAgICAndm9sdW1lSGFuZGxlJzoge31cbiAgfSxcbiAgJ2Jhck5hbWUnOiAndm9sdW1lTGV2ZWwnLFxuICAnaGFuZGxlTmFtZSc6ICd2b2x1bWVIYW5kbGUnXG59O1xuXG5Wb2x1bWVCYXIucHJvdG90eXBlLnBsYXllckV2ZW50ID0gJ3ZvbHVtZWNoYW5nZSc7XG5cblNsaWRlci5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQmFyJywgVm9sdW1lQmFyKTtcbmV4cG9ydCBkZWZhdWx0IFZvbHVtZUJhcjtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuLi8uLi9saWIuanMnO1xuXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuaW1wb3J0IFZvbHVtZUJhciBmcm9tICcuL3ZvbHVtZS1iYXIuanMnO1xuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSB2b2x1bWUgbGV2ZWxcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lQ29udHJvbCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gaGlkZSB2b2x1bWUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgdGVjaFxuICAgIGlmIChwbGF5ZXIudGVjaCAmJiBwbGF5ZXIudGVjaFsnZmVhdHVyZXNWb2x1bWVDb250cm9sJ10gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfVxuICAgIHRoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgZnVuY3Rpb24oKXtcbiAgICAgIGlmIChwbGF5ZXIudGVjaFsnZmVhdHVyZXNWb2x1bWVDb250cm9sJ10gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuICB9XG5cbn1cblxuVm9sdW1lQ29udHJvbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiB7XG4gICAgJ3ZvbHVtZUJhcic6IHt9XG4gIH1cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQ29udHJvbCcsIFZvbHVtZUNvbnRyb2wpO1xuZXhwb3J0IGRlZmF1bHQgVm9sdW1lQ29udHJvbDtcbiIsImltcG9ydCBTbGlkZXJIYW5kbGUgZnJvbSAnLi4vLi4vc2xpZGVyL3NsaWRlci1oYW5kbGUuanMnO1xuXG4vKipcbiAqIFRoZSB2b2x1bWUgaGFuZGxlIGNhbiBiZSBkcmFnZ2VkIHRvIGFkanVzdCB0aGUgdm9sdW1lIGxldmVsXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFZvbHVtZUhhbmRsZSBleHRlbmRzIFNsaWRlckhhbmRsZSB7XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1oYW5kbGUnXG4gICAgfSk7XG4gIH1cblxufVxuXG5Wb2x1bWVIYW5kbGUucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9ICcwMDowMCc7XG5cblNsaWRlckhhbmRsZS5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lSGFuZGxlJywgVm9sdW1lSGFuZGxlKTtcbmV4cG9ydCBkZWZhdWx0IFZvbHVtZUhhbmRsZTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50LmpzJztcblxuLyoqXG4gKiBTaG93cyB2b2x1bWUgbGV2ZWxcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lTGV2ZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1sZXZlbCcsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48L3NwYW4+J1xuICAgIH0pO1xuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVMZXZlbCcsIFZvbHVtZUxldmVsKTtcbmV4cG9ydCBkZWZhdWx0IFZvbHVtZUxldmVsO1xuIiwiaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24uanMnO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi4vbWVudS9tZW51LmpzJztcbmltcG9ydCBNZW51QnV0dG9uIGZyb20gJy4uL21lbnUvbWVudS1idXR0b24uanMnO1xuaW1wb3J0IE11dGVUb2dnbGUgZnJvbSAnLi9tdXRlLXRvZ2dsZS5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcbmltcG9ydCBWb2x1bWVCYXIgZnJvbSAnLi92b2x1bWUtY29udHJvbC92b2x1bWUtYmFyLmpzJztcblxuLyoqXG4gKiBNZW51IGJ1dHRvbiB3aXRoIGEgcG9wdXAgZm9yIHNob3dpbmcgdGhlIHZvbHVtZSBzbGlkZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVm9sdW1lTWVudUJ1dHRvbiBleHRlbmRzIE1lbnVCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucyl7XG4gICAgc3VwZXIocGxheWVyLCBvcHRpb25zKTtcblxuICAgIC8vIFNhbWUgbGlzdGVuZXJzIGFzIE11dGVUb2dnbGVcbiAgICB0aGlzLm9uKHBsYXllciwgJ3ZvbHVtZWNoYW5nZScsIHRoaXMudm9sdW1lVXBkYXRlKTtcblxuICAgIC8vIGhpZGUgbXV0ZSB0b2dnbGUgaWYgdGhlIGN1cnJlbnQgdGVjaCBkb2Vzbid0IHN1cHBvcnQgdm9sdW1lIGNvbnRyb2xcbiAgICBpZiAocGxheWVyLnRlY2ggJiYgcGxheWVyLnRlY2hbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgICB0aGlzLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIGZ1bmN0aW9uKCl7XG4gICAgICBpZiAocGxheWVyLnRlY2hbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLW1lbnUtYnV0dG9uJyk7XG4gIH1cblxuICBjcmVhdGVNZW51KCkge1xuICAgIGxldCBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXJfLCB7XG4gICAgICBjb250ZW50RWxUeXBlOiAnZGl2J1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHZvbHVtZUJhciBpcyB2ZXJ0aWNhbCBieSBkZWZhdWx0IGluIHRoZSBiYXNlIHRoZW1lIHdoZW4gdXNlZCB3aXRoIGEgVm9sdW1lTWVudUJ1dHRvblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zX1sndm9sdW1lQmFyJ10gfHwge307XG4gICAgb3B0aW9uc1sndmVydGljYWwnXSA9IG9wdGlvbnNbJ3ZlcnRpY2FsJ10gfHwgdHJ1ZTtcblxuICAgIGxldCB2YyA9IG5ldyBWb2x1bWVCYXIodGhpcy5wbGF5ZXJfLCBvcHRpb25zKTtcblxuICAgIHZjLm9uKCdmb2N1cycsIGZ1bmN0aW9uKCkge1xuICAgICAgbWVudS5sb2NrU2hvd2luZygpO1xuICAgIH0pO1xuICAgIHZjLm9uKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICBtZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICB9KTtcbiAgICBtZW51LmFkZENoaWxkKHZjKTtcbiAgICByZXR1cm4gbWVudTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIE11dGVUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XG4gICAgc3VwZXIuaGFuZGxlQ2xpY2soKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1tZW51LWJ1dHRvbiB2anMtbWVudS1idXR0b24gdmpzLWNvbnRyb2wgdmpzLWJ1dHRvbicsXG4gICAgICBpbm5lckhUTUw6IGA8ZGl2PjxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiR7dGhpcy5sb2NhbGl6ZSgnTXV0ZScpfTwvc3Bhbj48L2Rpdj5gXG4gICAgfSk7XG4gIH1cblxufVxuXG5Wb2x1bWVNZW51QnV0dG9uLnByb3RvdHlwZS52b2x1bWVVcGRhdGUgPSBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGU7XG5cbkJ1dHRvbi5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lTWVudUJ1dHRvbicsIFZvbHVtZU1lbnVCdXR0b24pO1xuZXhwb3J0IGRlZmF1bHQgVm9sdW1lTWVudUJ1dHRvbjtcbiIsImltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYic7XG5cbi8qKlxuICogQ29yZSBPYmplY3QvQ2xhc3MgZm9yIG9iamVjdHMgdGhhdCB1c2UgaW5oZXJpdGFuY2UgKyBjb25zdHJ1Y3RvcnNcbiAqXG4gKiBUbyBjcmVhdGUgYSBjbGFzcyB0aGF0IGNhbiBiZSBzdWJjbGFzc2VkIGl0c2VsZiwgZXh0ZW5kIHRoZSBDb3JlT2JqZWN0IGNsYXNzLlxuICpcbiAqICAgICB2YXIgQW5pbWFsID0gQ29yZU9iamVjdC5leHRlbmQoKTtcbiAqICAgICB2YXIgSG9yc2UgPSBBbmltYWwuZXh0ZW5kKCk7XG4gKlxuICogVGhlIGNvbnN0cnVjdG9yIGNhbiBiZSBkZWZpbmVkIHRocm91Z2ggdGhlIGluaXQgcHJvcGVydHkgb2YgYW4gb2JqZWN0IGFyZ3VtZW50LlxuICpcbiAqICAgICB2YXIgQW5pbWFsID0gQ29yZU9iamVjdC5leHRlbmQoe1xuICogICAgICAgaW5pdDogZnVuY3Rpb24obmFtZSwgc291bmQpe1xuICogICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIE90aGVyIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIHRoZSBzYW1lIHdheSwgb3IgZGlyZWN0bHkgdG8gdGhlXG4gKiBwcm90b3R5cGUuXG4gKlxuICogICAgdmFyIEFuaW1hbCA9IENvcmVPYmplY3QuZXh0ZW5kKHtcbiAqICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5hbWUpe1xuICogICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICogICAgICAgfSxcbiAqICAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKCl7XG4gKiAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gKiAgICAgICB9LFxuICogICAgICAgc291bmQ6ICcuLi4nXG4gKiAgICB9KTtcbiAqXG4gKiAgICBBbmltYWwucHJvdG90eXBlLm1ha2VTb3VuZCA9IGZ1bmN0aW9uKCl7XG4gKiAgICAgIGFsZXJ0KHRoaXMuc291bmQpO1xuICogICAgfTtcbiAqXG4gKiBUbyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcywgdXNlIHRoZSBjcmVhdGUgbWV0aG9kLlxuICpcbiAqICAgIHZhciBmbHVmZnkgPSBBbmltYWwuY3JlYXRlKCdGbHVmZnknKTtcbiAqICAgIGZsdWZmeS5nZXROYW1lKCk7IC8vIC0+IEZsdWZmeVxuICpcbiAqIE1ldGhvZHMgYW5kIHByb3BlcnRpZXMgY2FuIGJlIG92ZXJyaWRkZW4gaW4gc3ViY2xhc3Nlcy5cbiAqXG4gKiAgICAgdmFyIEhvcnNlID0gQW5pbWFsLmV4dGVuZCh7XG4gKiAgICAgICBzb3VuZDogJ05laWdoaGhoaCEnXG4gKiAgICAgfSk7XG4gKlxuICogICAgIHZhciBob3JzZXkgPSBIb3JzZS5jcmVhdGUoJ0hvcnNleScpO1xuICogICAgIGhvcnNleS5nZXROYW1lKCk7IC8vIC0+IEhvcnNleVxuICogICAgIGhvcnNleS5tYWtlU291bmQoKTsgLy8gLT4gQWxlcnQ6IE5laWdoaGhoaCFcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29yZU9iamVjdCA9IGZ1bmN0aW9uKCl7fTtcbi8vIE1hbnVhbGx5IGV4cG9ydGluZyB2anNbJ0NvcmVPYmplY3QnXSBoZXJlIGZvciBDbG9zdXJlIENvbXBpbGVyXG4vLyBiZWNhdXNlIG9mIHRoZSB1c2Ugb2YgdGhlIGV4dGVuZC9jcmVhdGUgY2xhc3MgbWV0aG9kc1xuLy8gSWYgd2UgZGlkbid0IGRvIHRoaXMsIHRob3NlIGZ1bmN0aW9ucyB3b3VsZCBnZXQgZmxhdHRlbmVkIHRvIHNvbWV0aGluZyBsaWtlXG4vLyBgYSA9IC4uLmAgYW5kIGB0aGlzLnByb3RvdHlwZWAgd291bGQgcmVmZXIgdG8gdGhlIGdsb2JhbCBvYmplY3QgaW5zdGVhZCBvZlxuLy8gQ29yZU9iamVjdFxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgT2JqZWN0XG4gKlxuICogICAgIHZhciBBbmltYWwgPSBDb3JlT2JqZWN0LmV4dGVuZCgpO1xuICogICAgIHZhciBIb3JzZSA9IEFuaW1hbC5leHRlbmQoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgRnVuY3Rpb25zIGFuZCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgbmV3IG9iamVjdCdzIHByb3RvdHlwZVxuICogQHJldHVybiB7Q29yZU9iamVjdH0gQW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBDb3JlT2JqZWN0XG4gKiBAdGhpcyB7Kn1cbiAqL1xuQ29yZU9iamVjdC5leHRlbmQgPSBmdW5jdGlvbihwcm9wcz17fSl7XG4gIC8vIFNldCB1cCB0aGUgY29uc3RydWN0b3IgdXNpbmcgdGhlIHN1cHBsaWVkIGluaXQgbWV0aG9kXG4gIC8vIG9yIHVzaW5nIHRoZSBpbml0IG9mIHRoZSBwYXJlbnQgb2JqZWN0XG4gIC8vIE1ha2Ugc3VyZSB0byBjaGVjayB0aGUgdW5vYmZ1c2NhdGVkIHZlcnNpb24gZm9yIGV4dGVybmFsIGxpYnNcbiAgbGV0IGluaXQgPSBwcm9wc1snaW5pdCddIHx8IHByb3BzLmluaXQgfHwgdGhpcy5wcm90b3R5cGVbJ2luaXQnXSB8fCB0aGlzLnByb3RvdHlwZS5pbml0IHx8IGZ1bmN0aW9uKCl7fTtcbiAgLy8gSW4gUmVzaWcncyBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2UgKHByZXZpb3VzbHkgdXNlZCkgdGhlIGNvbnN0cnVjdG9yXG4gIC8vICBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgYHRoaXMuaW5pdC5hcHBseShhcmd1bWVudHMpYFxuICAvLyBIb3dldmVyIHRoYXQgd291bGQgcHJldmVudCB1cyBmcm9tIHVzaW5nIGBQYXJlbnRPYmplY3QuY2FsbCh0aGlzKTtgXG4gIC8vICBpbiBhIENoaWxkIGNvbnN0cnVjdG9yIGJlY2F1c2UgdGhlIGB0aGlzYCBpbiBgdGhpcy5pbml0YFxuICAvLyAgd291bGQgc3RpbGwgcmVmZXIgdG8gdGhlIENoaWxkIGFuZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wLlxuICAvLyBXZSB3b3VsZCBpbnN0ZWFkIGhhdmUgdG8gZG9cbiAgLy8gICAgYFBhcmVudE9iamVjdC5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO2BcbiAgLy8gIEJsZWguIFdlJ3JlIG5vdCBjcmVhdGluZyBhIF9zdXBlcigpIGZ1bmN0aW9uLCBzbyBpdCdzIGdvb2QgdG8ga2VlcFxuICAvLyAgdGhlIHBhcmVudCBjb25zdHJ1Y3RvciByZWZlcmVuY2Ugc2ltcGxlLlxuICBsZXQgc3ViT2JqID0gZnVuY3Rpb24oKXtcbiAgICBpbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gSW5oZXJpdCBmcm9tIHRoaXMgb2JqZWN0J3MgcHJvdG90eXBlXG4gIHN1Yk9iai5wcm90b3R5cGUgPSBMaWIub2JqLmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gIC8vIFJlc2V0IHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBmb3Igc3ViT2JqIG90aGVyd2lzZVxuICAvLyBpbnN0YW5jZXMgb2Ygc3ViT2JqIHdvdWxkIGhhdmUgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBwYXJlbnQgT2JqZWN0XG4gIHN1Yk9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJPYmo7XG5cbiAgLy8gTWFrZSB0aGUgY2xhc3MgZXh0ZW5kYWJsZVxuICBzdWJPYmouZXh0ZW5kID0gQ29yZU9iamVjdC5leHRlbmQ7XG4gIC8vIE1ha2UgYSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgaW5zdGFuY2VzXG4gIHN1Yk9iai5jcmVhdGUgPSBDb3JlT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcbiAgZm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc3ViT2JqLnByb3RvdHlwZVtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJPYmo7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIE9iamVjdCBjbGFzc1xuICpcbiAqICAgICB2YXIgbXlBbmltYWwgPSBBbmltYWwuY3JlYXRlKCk7XG4gKlxuICogQHJldHVybiB7Q29yZU9iamVjdH0gQW4gaW5zdGFuY2Ugb2YgYSBDb3JlT2JqZWN0IHN1YmNsYXNzXG4gKiBAdGhpcyB7Kn1cbiAqL1xuQ29yZU9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbigpe1xuICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdCdzIHByb3RvdHlwZVxuICB2YXIgaW5zdCA9IExpYi5vYmouY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcblxuICAvLyBBcHBseSB0aGlzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIHRoZSBuZXcgb2JqZWN0XG4gIHRoaXMuYXBwbHkoaW5zdCwgYXJndW1lbnRzKTtcblxuICAvLyBSZXR1cm4gdGhlIG5ldyBvYmplY3RcbiAgcmV0dXJuIGluc3Q7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb3JlT2JqZWN0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1haW4gZnVuY3Rpb24gc3JjLlxuICovXG5cbmltcG9ydCBQbGF5ZXIgZnJvbSAnLi9wbGF5ZXInO1xuaW1wb3J0IFBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zJztcbmltcG9ydCBPcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi9saWInO1xuaW1wb3J0ICogYXMgVmpzVXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IENvcmVPYmplY3QgZnJvbSAnLi9jb3JlLW9iamVjdCc7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLyoqXG4gKiBEb3VibGVzIGFzIHRoZSBtYWluIGZ1bmN0aW9uIGZvciB1c2VycyB0byBjcmVhdGUgYSBwbGF5ZXIgaW5zdGFuY2UgYW5kIGFsc29cbiAqIHRoZSBtYWluIGxpYnJhcnkgb2JqZWN0LlxuICpcbiAqICoqQUxJQVNFUyoqIHZpZGVvanMsIF9WXyAoZGVwcmVjYXRlZClcbiAqXG4gKiBUaGUgYHZqc2AgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBvciByZXRyaWV2ZSBhIHBsYXllci5cbiAqXG4gKiAgICAgdmFyIG15UGxheWVyID0gdmpzKCdteV92aWRlb19pZCcpO1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xFbGVtZW50fSBpZCAgICAgIFZpZGVvIGVsZW1lbnQgb3IgdmlkZW8gZWxlbWVudCBJRFxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9ucyAgICAgICAgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgZm9yIGNvbmZpZy9zZXR0aW5nc1xuICogQHBhcmFtICB7RnVuY3Rpb249fSByZWFkeSAgICAgICAgT3B0aW9uYWwgcmVhZHkgY2FsbGJhY2tcbiAqIEByZXR1cm4ge1BsYXllcn0gICAgICAgICAgICAgQSBwbGF5ZXIgaW5zdGFuY2VcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHZpZGVvanMgPSBmdW5jdGlvbihpZCwgb3B0aW9ucywgcmVhZHkpe1xuICB2YXIgdGFnOyAvLyBFbGVtZW50IG9mIElEXG5cbiAgLy8gQWxsb3cgZm9yIGVsZW1lbnQgb3IgSUQgdG8gYmUgcGFzc2VkIGluXG4gIC8vIFN0cmluZyBJRFxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuXG4gICAgLy8gQWRqdXN0IGZvciBqUXVlcnkgSUQgc3ludGF4XG4gICAgaWYgKGlkLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgICAgaWQgPSBpZC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHBsYXllciBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHRoaXMgSUQgcmV0dXJuIGl0LlxuICAgIGlmIChQbGF5ZXIucGxheWVyc1tpZF0pIHtcblxuICAgICAgLy8gSWYgb3B0aW9ucyBvciByZWFkeSBmdW50aW9uIGFyZSBwYXNzZWQsIHdhcm5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIExpYi5sb2cud2FybihgUGxheWVyIFwiJHtpZH1cIiBpcyBhbHJlYWR5IGluaXRpYWxpc2VkLiBPcHRpb25zIHdpbGwgbm90IGJlIGFwcGxpZWQuYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWFkeSkge1xuICAgICAgICBQbGF5ZXIucGxheWVyc1tpZF0ucmVhZHkocmVhZHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUGxheWVyLnBsYXllcnNbaWRdO1xuXG4gICAgLy8gT3RoZXJ3aXNlIGdldCBlbGVtZW50IGZvciBJRFxuICAgIH0gZWxzZSB7XG4gICAgICB0YWcgPSBMaWIuZWwoaWQpO1xuICAgIH1cblxuICAvLyBJRCBpcyBhIG1lZGlhIGVsZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB0YWcgPSBpZDtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBhIHVzZWFibGUgZWxlbWVudFxuICBpZiAoIXRhZyB8fCAhdGFnLm5vZGVOYW1lKSB7IC8vIHJlOiBub2RlTmFtZSwgY291bGQgYmUgYSBib3ggZGl2IGFsc29cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZWxlbWVudCBvciBJRCBzdXBwbGllZCBpcyBub3QgdmFsaWQuICh2aWRlb2pzKScpOyAvLyBSZXR1cm5zXG4gIH1cblxuICAvLyBFbGVtZW50IG1heSBoYXZlIGEgcGxheWVyIGF0dHIgcmVmZXJyaW5nIHRvIGFuIGFscmVhZHkgY3JlYXRlZCBwbGF5ZXIgaW5zdGFuY2UuXG4gIC8vIElmIG5vdCwgc2V0IHVwIGEgbmV3IHBsYXllciBhbmQgcmV0dXJuIHRoZSBpbnN0YW5jZS5cbiAgcmV0dXJuIHRhZ1sncGxheWVyJ10gfHwgbmV3IFBsYXllcih0YWcsIG9wdGlvbnMsIHJlYWR5KTtcbn07XG5cbi8vIENETiBWZXJzaW9uLiBVc2VkIHRvIHRhcmdldCByaWdodCBmbGFzaCBzd2YuXG52aWRlb2pzLkNETl9WRVJTSU9OID0gJ19fVkVSU0lPTl9OT19QQVRDSF9fJztcbnZpZGVvanMuQUNDRVNTX1BST1RPQ09MID0gKCdodHRwczonID09PSBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCA/ICdodHRwczovLycgOiAnaHR0cDovLycpO1xuXG4vKipcbiogRnVsbCBwbGF5ZXIgdmVyc2lvblxuKiBAdHlwZSB7c3RyaW5nfVxuKi9cbnZpZGVvanNbJ1ZFUlNJT04nXSA9ICdfX1ZFUlNJT05fXyc7XG5cbi8vIFNldCBDRE4gVmVyc2lvbiBvZiBzd2Zcbi8vIFRoZSBhZGRlZCAoKykgYmxvY2tzIHRoZSByZXBsYWNlIGZyb20gY2hhbmdpbmcgdGhpcyBfVkVSU0lPTl9OT19QQVRDSF8gc3RyaW5nXG5pZiAodmlkZW9qcy5DRE5fVkVSU0lPTiAhPT0gJ19fVkVSU0lPTl8nKydOT19QQVRDSF9fJykge1xuICBPcHRpb25zWydmbGFzaCddWydzd2YnXSA9IGAke3ZpZGVvanMuQUNDRVNTX1BST1RPQ09MfXZqcy56ZW5jZG4ubmV0LyR7dmlkZW9qcy5DRE5fVkVSU0lPTn0vdmlkZW8tanMuc3dmYDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBhZGRpbmcgbGFuZ3VhZ2VzIHRvIHRoZSBkZWZhdWx0IG9wdGlvbnMuIFVzZWZ1bCBmb3JcbiAqIGFtZW5kaW5nIG11bHRpcGxlIGxhbmd1YWdlIHN1cHBvcnQgYXQgcnVudGltZS5cbiAqXG4gKiBFeGFtcGxlOiB2aWRlb2pzLmFkZExhbmd1YWdlKCdlcycsIHsnSGVsbG8nOidIb2xhJ30pO1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gY29kZSBUaGUgbGFuZ3VhZ2UgY29kZSBvciBkaWN0aW9uYXJ5IHByb3BlcnR5XG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdmFsdWVzIHRvIGJlIHRyYW5zbGF0ZWRcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyBnbG9iYWwgbGFuZ3VhZ2VzIGRpY3Rpb25hcnkgb2JqZWN0XG4gKi9cbnZpZGVvanMuYWRkTGFuZ3VhZ2UgPSBmdW5jdGlvbihjb2RlLCBkYXRhKXtcbiAgaWYoT3B0aW9uc1snbGFuZ3VhZ2VzJ11bY29kZV0gIT09IHVuZGVmaW5lZCkge1xuICAgIE9wdGlvbnNbJ2xhbmd1YWdlcyddW2NvZGVdID0gVmpzVXRpbC5tZXJnZU9wdGlvbnMoT3B0aW9uc1snbGFuZ3VhZ2VzJ11bY29kZV0sIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIE9wdGlvbnNbJ2xhbmd1YWdlcyddW2NvZGVdID0gZGF0YTtcbiAgfVxuICByZXR1cm4gT3B0aW9uc1snbGFuZ3VhZ2VzJ107XG59O1xuXG4vKipcbiAqIEN1c3RvbSBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRClcbiAqXG4gKiBWaWRlby5qcyB3aWxsIG5ldmVyIGJlIGEgbm9uLWJyb3dzZXIgbGliIHNvIHdlIGNhbiBzaW1wbGlmeSBVTUQgYSBidW5jaCBhbmRcbiAqIHN0aWxsIHN1cHBvcnQgcmVxdWlyZWpzIGFuZCBicm93c2VyaWZ5LiBUaGlzIGFsc28gbmVlZHMgdG8gYmUgY2xvc3VyZVxuICogY29tcGlsZXIgY29tcGF0aWJsZSwgc28gc3RyaW5nIGtleXMgYXJlIHVzZWQuXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgZGVmaW5lKCd2aWRlb2pzJywgW10sIGZ1bmN0aW9uKCl7IHJldHVybiB2aWRlb2pzOyB9KTtcblxuLy8gY2hlY2tpbmcgdGhhdCBtb2R1bGUgaXMgYW4gb2JqZWN0IHRvbyBiZWNhdXNlIG9mIHVtZGpzL3VtZCMzNVxufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlWydleHBvcnRzJ10gPSB2aWRlb2pzO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2aWRlb2pzO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudCc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi9saWInO1xuXG4vKipcbiAqIERpc3BsYXkgdGhhdCBhbiBlcnJvciBoYXMgb2NjdXJyZWQgbWFraW5nIHRoZSB2aWRlbyB1bnBsYXlhYmxlXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgRXJyb3JEaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ2Vycm9yJywgdGhpcy51cGRhdGUpO1xuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gc3VwZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1lcnJvci1kaXNwbGF5J1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gTGliLmNyZWF0ZUVsKCdkaXYnKTtcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLnBsYXllcigpLmVycm9yKCkpIHtcbiAgICAgIHRoaXMuY29udGVudEVsXy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKHRoaXMucGxheWVyKCkuZXJyb3IoKS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdFcnJvckRpc3BsYXknLCBFcnJvckRpc3BsYXkpO1xuZXhwb3J0IGRlZmF1bHQgRXJyb3JEaXNwbGF5O1xuIiwiaW1wb3J0ICogYXMgRXZlbnRzIGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYic7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSBmdW5jdGlvbigpIHt9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge307XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICAvLyBSZW1vdmUgdGhlIGFkZEV2ZW50TGlzdGVuZXIgYWxpYXMgYmVmb3JlIGNhbGxpbmcgRXZlbnRzLm9uXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxuICBsZXQgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIEV2ZW50cy5vbih0aGlzLCB0eXBlLCBmbik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFlbDtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gIEV2ZW50cy5vZmYodGhpcywgdHlwZSwgZm4pO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gIEV2ZW50cy5vbmUodGhpcywgdHlwZSwgZm4pO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgbGV0IHR5cGUgPSBldmVudC50eXBlIHx8IGV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZXZlbnQgPSB7XG4gICAgICB0eXBlOiB0eXBlXG4gICAgfTtcbiAgfVxuICBldmVudCA9IEV2ZW50cy5maXhFdmVudChldmVudCk7XG5cbiAgaWYgKHRoaXMuYWxsb3dlZEV2ZW50c19bdHlwZV0gJiYgdGhpc1snb24nICsgdHlwZV0pIHtcbiAgICB0aGlzWydvbicgKyB0eXBlXShldmVudCk7XG4gIH1cblxuICBFdmVudHMudHJpZ2dlcih0aGlzLCBldmVudCk7XG59O1xuLy8gVGhlIHN0YW5kYXJkIERPTSBFdmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KCkgaXMgYWxpYXNlZCB0byB0cmlnZ2VyKClcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUudHJpZ2dlcjtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV2ZW50IFN5c3RlbSAoSm9obiBSZXNpZyAtIFNlY3JldHMgb2YgYSBKUyBOaW5qYSBodHRwOi8vanNuaW5qYS5jb20vKVxuICogKE9yaWdpbmFsIGJvb2sgdmVyc2lvbiB3YXNuJ3QgY29tcGxldGVseSB1c2FibGUsIHNvIGZpeGVkIHNvbWUgdGhpbmdzIGFuZCBtYWRlIENsb3N1cmUgQ29tcGlsZXIgY29tcGF0aWJsZSlcbiAqIFRoaXMgc2hvdWxkIHdvcmsgdmVyeSBzaW1pbGFybHkgdG8galF1ZXJ5J3MgZXZlbnRzLCBob3dldmVyIGl0J3MgYmFzZWQgb2ZmIHRoZSBib29rIHZlcnNpb24gd2hpY2ggaXNuJ3QgYXNcbiAqIHJvYnVzdCBhcyBqcXVlcnkncywgc28gdGhlcmUncyBwcm9iYWJseSBzb21lIGRpZmZlcmVuY2VzLlxuICovXG5cbmltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYic7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qKlxuICogRml4IGEgbmF0aXZlIGV2ZW50IHRvIGhhdmUgc3RhbmRhcmQgcHJvcGVydHkgdmFsdWVzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdCB0byBmaXhcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBmaXhFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFRlc3QgaWYgZml4aW5nIHVwIGlzIG5lZWRlZFxuICAvLyBVc2VkIHRvIGNoZWNrIGlmICFldmVudC5zdG9wUHJvcGFnYXRpb24gaW5zdGVhZCBvZiBpc1Byb3BhZ2F0aW9uU3RvcHBlZFxuICAvLyBCdXQgbmF0aXZlIGV2ZW50cyByZXR1cm4gdHJ1ZSBmb3Igc3RvcFByb3BhZ2F0aW9uLCBidXQgZG9uJ3QgaGF2ZVxuICAvLyBvdGhlciBleHBlY3RlZCBtZXRob2RzIGxpa2UgaXNQcm9wYWdhdGlvblN0b3BwZWQuIFNlZW1zIHRvIGJlIGEgcHJvYmxlbVxuICAvLyB3aXRoIHRoZSBKYXZhc2NyaXB0IE5pbmphIGNvZGUuIFNvIHdlJ3JlIGp1c3Qgb3ZlcnJpZGluZyBhbGwgZXZlbnRzIG5vdy5cbiAgaWYgKCFldmVudCB8fCAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICB2YXIgb2xkID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgZXZlbnQgPSB7fTtcbiAgICAvLyBDbG9uZSB0aGUgb2xkIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBtb2RpZnkgdGhlIHZhbHVlcyBldmVudCA9IHt9O1xuICAgIC8vIElFOCBEb2Vzbid0IGxpa2Ugd2hlbiB5b3UgbWVzcyB3aXRoIG5hdGl2ZSBldmVudCBwcm9wZXJ0aWVzXG4gICAgLy8gRmlyZWZveCByZXR1cm5zIGZhbHNlIGZvciBldmVudC5oYXNPd25Qcm9wZXJ0eSgndHlwZScpIGFuZCBvdGhlciBwcm9wc1xuICAgIC8vICB3aGljaCBtYWtlcyBjb3B5aW5nIG1vcmUgZGlmZmljdWx0LlxuICAgIC8vIFRPRE86IFByb2JhYmx5IGJlc3QgdG8gY3JlYXRlIGEgd2hpdGVsaXN0IG9mIGV2ZW50IHByb3BzXG4gICAgZm9yICh2YXIga2V5IGluIG9sZCkge1xuICAgICAgLy8gU2FmYXJpIDYuMC4zIHdhcm5zIHlvdSBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCBsYXllclgvWVxuICAgICAgLy8gQ2hyb21lIHdhcm5zIHlvdSBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCBrZXlib2FyZEV2ZW50LmtleUxvY2F0aW9uXG4gICAgICBpZiAoa2V5ICE9PSAnbGF5ZXJYJyAmJiBrZXkgIT09ICdsYXllclknICYmIGtleSAhPT0gJ2tleUxvY2F0aW9uJykge1xuICAgICAgICAvLyBDaHJvbWUgMzIrIHdhcm5zIGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIHJldHVyblZhbHVlLCBidXRcbiAgICAgICAgLy8gd2Ugc3RpbGwgd2FudCB0byBpZiBwcmV2ZW50RGVmYXVsdCBpc24ndCBzdXBwb3J0ZWQgKElFOCkuXG4gICAgICAgIGlmICghKGtleSA9PT0gJ3JldHVyblZhbHVlJyAmJiBvbGQucHJldmVudERlZmF1bHQpKSB7XG4gICAgICAgICAgZXZlbnRba2V5XSA9IG9sZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGV2ZW50IG9jY3VycmVkIG9uIHRoaXMgZWxlbWVudFxuICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB3aGljaCBvdGhlciBlbGVtZW50IHRoZSBldmVudCBpcyByZWxhdGVkIHRvXG4gICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgP1xuICAgICAgZXZlbnQudG9FbGVtZW50IDpcbiAgICAgIGV2ZW50LmZyb21FbGVtZW50O1xuXG4gICAgLy8gU3RvcCB0aGUgZGVmYXVsdCBicm93c2VyIGFjdGlvblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9sZC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBvbGQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBidWJibGluZ1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbGQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIG9sZC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICAvLyBTdG9wIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nIGFuZCBleGVjdXRpbmcgb3RoZXIgaGFuZGxlcnNcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuXG4gICAgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5GYWxzZTtcblxuICAgIC8vIEhhbmRsZSBtb3VzZSBwb3NpdGlvblxuICAgIGlmIChldmVudC5jbGllbnRYICE9IG51bGwpIHtcbiAgICAgIHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gICAgICBldmVudC5wYWdlWCA9IGV2ZW50LmNsaWVudFggK1xuICAgICAgICAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC1cbiAgICAgICAgKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgIGV2ZW50LnBhZ2VZID0gZXZlbnQuY2xpZW50WSArXG4gICAgICAgIChkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wIHx8IDApIC1cbiAgICAgICAgKGRvYyAmJiBkb2MuY2xpZW50VG9wIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgfHwgMCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGtleSBwcmVzc2VzXG4gICAgZXZlbnQud2hpY2ggPSBldmVudC5jaGFyQ29kZSB8fCBldmVudC5rZXlDb2RlO1xuXG4gICAgLy8gRml4IGJ1dHRvbiBmb3IgbW91c2UgY2xpY2tzOlxuICAgIC8vIDAgPT0gbGVmdDsgMSA9PSBtaWRkbGU7IDIgPT0gcmlnaHRcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9IG51bGwpIHtcbiAgICAgIGV2ZW50LmJ1dHRvbiA9IChldmVudC5idXR0b24gJiAxID8gMCA6XG4gICAgICAgIChldmVudC5idXR0b24gJiA0ID8gMSA6XG4gICAgICAgICAgKGV2ZW50LmJ1dHRvbiAmIDIgPyAyIDogMCkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGZpeGVkLXVwIGluc3RhbmNlXG4gIHJldHVybiBldmVudDtcbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnRcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcbiAqIGFsb25nIHdpdGggYSB1bmlxdWUgaWQgKGd1aWQpIHRvIHRoZSBlbGVtZW50LlxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9ICAgZWxlbSBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSAgIHR5cGUgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgRXZlbnQgbGlzdGVuZXIuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgb24gPSBmdW5jdGlvbihlbGVtLCB0eXBlLCBmbil7XG4gIGlmIChMaWIub2JqLmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICBsZXQgZGF0YSA9IExpYi5nZXREYXRhKGVsZW0pO1xuXG4gIC8vIFdlIG5lZWQgYSBwbGFjZSB0byBzdG9yZSBhbGwgb3VyIGhhbmRsZXIgZGF0YVxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIGRhdGEuaGFuZGxlcnMgPSB7fTtcblxuICBpZiAoIWRhdGEuaGFuZGxlcnNbdHlwZV0pIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBbXTtcblxuICBpZiAoIWZuLmd1aWQpIGZuLmd1aWQgPSBMaWIuZ3VpZCsrO1xuXG4gIGRhdGEuaGFuZGxlcnNbdHlwZV0ucHVzaChmbik7XG5cbiAgaWYgKCFkYXRhLmRpc3BhdGNoZXIpIHtcbiAgICBkYXRhLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICBkYXRhLmRpc3BhdGNoZXIgPSBmdW5jdGlvbiAoZXZlbnQpe1xuXG4gICAgICBpZiAoZGF0YS5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IGRhdGEuaGFuZGxlcnNbZXZlbnQudHlwZV07XG5cbiAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAvLyBDb3B5IGhhbmRsZXJzIHNvIGlmIGhhbmRsZXJzIGFyZSBhZGRlZC9yZW1vdmVkIGR1cmluZyB0aGUgcHJvY2VzcyBpdCBkb2Vzbid0IHRocm93IGV2ZXJ5dGhpbmcgb2ZmLlxuICAgICAgICB2YXIgaGFuZGxlcnNDb3B5ID0gaGFuZGxlcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgZm9yICh2YXIgbSA9IDAsIG4gPSBoYW5kbGVyc0NvcHkubGVuZ3RoOyBtIDwgbjsgbSsrKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVyc0NvcHlbbV0uY2FsbChlbGVtLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBkYXRhLmRpc3BhdGNoZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYW4gZWxlbWVudFxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9ICAgZWxlbSBPYmplY3QgdG8gcmVtb3ZlIGxpc3RlbmVycyBmcm9tXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXk9fSAgIHR5cGUgVHlwZSBvZiBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGFsbCBldmVudHMgZnJvbSBlbGVtZW50LlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgU3BlY2lmaWMgbGlzdGVuZXIgdG8gcmVtb3ZlLiBEb24ndCBpbmNsdWRlIHRvIHJlbW92ZSBsaXN0ZW5lcnMgZm9yIGFuIGV2ZW50IHR5cGUuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgb2ZmID0gZnVuY3Rpb24oZWxlbSwgdHlwZSwgZm4pIHtcbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBjYWNoZSBvYmplY3QgdGhyb3VnaCBnZXREYXRhIGlmIG5vdCBuZWVkZWRcbiAgaWYgKCFMaWIuaGFzRGF0YShlbGVtKSkgcmV0dXJuO1xuXG4gIGxldCBkYXRhID0gTGliLmdldERhdGEoZWxlbSk7XG5cbiAgLy8gSWYgbm8gZXZlbnRzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIHsgcmV0dXJuOyB9XG5cbiAgaWYgKExpYi5vYmouaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob2ZmLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uXG4gIHZhciByZW1vdmVUeXBlID0gZnVuY3Rpb24odCl7XG4gICAgIGRhdGEuaGFuZGxlcnNbdF0gPSBbXTtcbiAgICAgY2xlYW5VcEV2ZW50cyhlbGVtLHQpO1xuICB9O1xuXG4gIC8vIEFyZSB3ZSByZW1vdmluZyBhbGwgYm91bmQgZXZlbnRzP1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3IgKGxldCB0IGluIGRhdGEuaGFuZGxlcnMpIHJlbW92ZVR5cGUodCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1t0eXBlXTtcblxuICAvLyBJZiBubyBoYW5kbGVycyBleGlzdCwgbm90aGluZyB0byB1bmJpbmRcbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuO1xuXG4gIC8vIElmIG5vIGxpc3RlbmVyIHdhcyBwcm92aWRlZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHR5cGVcbiAgaWYgKCFmbikge1xuICAgIHJlbW92ZVR5cGUodHlwZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UncmUgb25seSByZW1vdmluZyBhIHNpbmdsZSBoYW5kbGVyXG4gIGlmIChmbi5ndWlkKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBoYW5kbGVycy5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKGhhbmRsZXJzW25dLmd1aWQgPT09IGZuLmd1aWQpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKG4tLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKTtcbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdGhlIGxpc3RlbmVyIGNhY2hlIGFuZCBkaXNwYXRjaGVyc1xuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9IGVsZW0gRWxlbWVudCB0byBjbGVhbiB1cFxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgZXZlbnQgdG8gY2xlYW4gdXBcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjbGVhblVwRXZlbnRzID0gZnVuY3Rpb24oZWxlbSwgdHlwZSkge1xuICB2YXIgZGF0YSA9IExpYi5nZXREYXRhKGVsZW0pO1xuXG4gIC8vIFJlbW92ZSB0aGUgZXZlbnRzIG9mIGEgcGFydGljdWxhciB0eXBlIGlmIHRoZXJlIGFyZSBub25lIGxlZnRcbiAgaWYgKGRhdGEuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIGRhdGEuaGFuZGxlcnNbdHlwZV07XG4gICAgLy8gZGF0YS5oYW5kbGVyc1t0eXBlXSA9IG51bGw7XG4gICAgLy8gU2V0dGluZyB0byBudWxsIHdhcyBjYXVzaW5nIGFuIGVycm9yIHdpdGggZGF0YS5oYW5kbGVyc1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBtZXRhLWhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBkYXRhLmRpc3BhdGNoZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBldmVudHMgb2JqZWN0IGlmIHRoZXJlIGFyZSBubyB0eXBlcyBsZWZ0XG4gIGlmIChMaWIuaXNFbXB0eShkYXRhLmhhbmRsZXJzKSkge1xuICAgIGRlbGV0ZSBkYXRhLmhhbmRsZXJzO1xuICAgIGRlbGV0ZSBkYXRhLmRpc3BhdGNoZXI7XG4gICAgZGVsZXRlIGRhdGEuZGlzYWJsZWQ7XG5cbiAgICAvLyBkYXRhLmhhbmRsZXJzID0gbnVsbDtcbiAgICAvLyBkYXRhLmRpc3BhdGNoZXIgPSBudWxsO1xuICAgIC8vIGRhdGEuZGlzYWJsZWQgPSBudWxsO1xuICB9XG5cbiAgLy8gRmluYWxseSByZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUgaXMgbm8gZGF0YSBsZWZ0XG4gIGlmIChMaWIuaXNFbXB0eShkYXRhKSkge1xuICAgIExpYi5yZW1vdmVEYXRhKGVsZW0pO1xuICB9XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSAgICAgIGVsZW0gIEVsZW1lbnQgdG8gdHJpZ2dlciBhbiBldmVudCBvblxuICogQHBhcmFtICB7RXZlbnR8T2JqZWN0fFN0cmluZ30gZXZlbnQgQSBzdHJpbmcgKHRoZSB0eXBlKSBvciBhbiBldmVudCBvYmplY3Qgd2l0aCBhIHR5cGUgYXR0cmlidXRlXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdHJpZ2dlciA9IGZ1bmN0aW9uKGVsZW0sIGV2ZW50KSB7XG4gIC8vIEZldGNoZXMgZWxlbWVudCBkYXRhIGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IChmb3IgYnViYmxpbmcpLlxuICAvLyBEb24ndCB3YW50IHRvIGFkZCBhIGRhdGEgb2JqZWN0IHRvIGNhY2hlIGZvciBldmVyeSBwYXJlbnQsXG4gIC8vIHNvIGNoZWNraW5nIGhhc0RhdGEgZmlyc3QuXG4gIHZhciBlbGVtRGF0YSA9IChMaWIuaGFzRGF0YShlbGVtKSkgPyBMaWIuZ2V0RGF0YShlbGVtKSA6IHt9O1xuICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlIHx8IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgIC8vIHR5cGUgPSBldmVudC50eXBlIHx8IGV2ZW50LFxuICAgICAgLy8gaGFuZGxlcjtcblxuICAvLyBJZiBhbiBldmVudCBuYW1lIHdhcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGNyZWF0ZXMgYW4gZXZlbnQgb3V0IG9mIGl0XG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZXZlbnQgPSB7IHR5cGU6ZXZlbnQsIHRhcmdldDplbGVtIH07XG4gIH1cbiAgLy8gTm9ybWFsaXplcyB0aGUgZXZlbnQgcHJvcGVydGllcy5cbiAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgLy8gSWYgdGhlIHBhc3NlZCBlbGVtZW50IGhhcyBhIGRpc3BhdGNoZXIsIGV4ZWN1dGVzIHRoZSBlc3RhYmxpc2hlZCBoYW5kbGVycy5cbiAgaWYgKGVsZW1EYXRhLmRpc3BhdGNoZXIpIHtcbiAgICBlbGVtRGF0YS5kaXNwYXRjaGVyLmNhbGwoZWxlbSwgZXZlbnQpO1xuICB9XG5cbiAgLy8gVW5sZXNzIGV4cGxpY2l0bHkgc3RvcHBlZCBvciB0aGUgZXZlbnQgZG9lcyBub3QgYnViYmxlIChlLmcuIG1lZGlhIGV2ZW50cylcbiAgICAvLyByZWN1cnNpdmVseSBjYWxscyB0aGlzIGZ1bmN0aW9uIHRvIGJ1YmJsZSB0aGUgZXZlbnQgdXAgdGhlIERPTS5cbiAgICBpZiAocGFyZW50ICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICYmIGV2ZW50LmJ1YmJsZXMgIT09IGZhbHNlKSB7XG4gICAgdHJpZ2dlcihwYXJlbnQsIGV2ZW50KTtcblxuICAvLyBJZiBhdCB0aGUgdG9wIG9mIHRoZSBET00sIHRyaWdnZXJzIHRoZSBkZWZhdWx0IGFjdGlvbiB1bmxlc3MgZGlzYWJsZWQuXG4gIH0gZWxzZSBpZiAoIXBhcmVudCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHZhciB0YXJnZXREYXRhID0gTGliLmdldERhdGEoZXZlbnQudGFyZ2V0KTtcblxuICAgIC8vIENoZWNrcyBpZiB0aGUgdGFyZ2V0IGhhcyBhIGRlZmF1bHQgYWN0aW9uIGZvciB0aGlzIGV2ZW50LlxuICAgIGlmIChldmVudC50YXJnZXRbZXZlbnQudHlwZV0pIHtcbiAgICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGVzIGV2ZW50IGRpc3BhdGNoaW5nIG9uIHRoZSB0YXJnZXQgYXMgd2UgaGF2ZSBhbHJlYWR5IGV4ZWN1dGVkIHRoZSBoYW5kbGVyLlxuICAgICAgdGFyZ2V0RGF0YS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAvLyBFeGVjdXRlcyB0aGUgZGVmYXVsdCBhY3Rpb24uXG4gICAgICBpZiAodHlwZW9mIGV2ZW50LnRhcmdldFtldmVudC50eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudC50YXJnZXRbZXZlbnQudHlwZV0oKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlLWVuYWJsZXMgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICB0YXJnZXREYXRhLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5mb3JtIHRoZSB0cmlnZ2VyZXIgaWYgdGhlIGRlZmF1bHQgd2FzIHByZXZlbnRlZCBieSByZXR1cm5pbmcgZmFsc2VcbiAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgbGlzdGVuZXIgb25seSBvbmNlIGZvciBhbiBldmVudFxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9ICAgZWxlbSBFbGVtZW50IG9yIG9iamVjdCB0b1xuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSAgIHR5cGVcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHByaXZhdGVcbiAqL1xudmFyIG9uZSA9IGZ1bmN0aW9uKGVsZW0sIHR5cGUsIGZuKSB7XG4gIGlmIChMaWIub2JqLmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uZSwgZWxlbSwgdHlwZSwgZm4pO1xuICB9XG4gIHZhciBmdW5jID0gZnVuY3Rpb24oKXtcbiAgICBvZmYoZWxlbSwgdHlwZSwgZnVuYyk7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgLy8gY29weSB0aGUgZ3VpZCB0byB0aGUgbmV3IGZ1bmN0aW9uIHNvIGl0IGNhbiByZW1vdmVkIHVzaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbidzIElEXG4gIGZ1bmMuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IExpYi5ndWlkKys7XG4gIG9uKGVsZW0sIHR5cGUsIGZ1bmMpO1xufTtcblxuLyoqXG4gKiBMb29wcyB0aHJvdWdoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFuZCBjYWxscyB0aGUgcmVxdWVzdGVkIG1ldGhvZCBmb3IgZWFjaCB0eXBlLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgVGhlIGV2ZW50IG1ldGhvZCB3ZSB3YW50IHRvIHVzZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEVsZW1lbnQgb3Igb2JqZWN0IHRvIGJpbmQgbGlzdGVuZXJzIHRvXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgdHlwZSBUeXBlIG9mIGV2ZW50IHRvIGJpbmQgdG8uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBFdmVudCBsaXN0ZW5lci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhmbiwgZWxlbSwgdHlwZSwgY2FsbGJhY2spIHtcbiAgTGliLmFyci5mb3JFYWNoKHR5cGUsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBmbihlbGVtLCB0eXBlLCBjYWxsYmFjayk7IC8vQ2FsbCB0aGUgZXZlbnQgbWV0aG9kIGZvciBlYWNoIG9uZSBvZiB0aGUgdHlwZXNcbiAgfSk7XG59XG5cbmV4cG9ydCB7IG9uLCBvZmYsIGNsZWFuVXBFdmVudHMsIGZpeEV2ZW50LCBvbmUsIHRyaWdnZXIgfTtcbiIsImltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYic7XG5cbi8qKlxuICogQSBjb21iaW5hdGlvbiBvZiBub2RlIGluaGVyaXRzIGFuZCBiYWJlbCdzIGluaGVyaXRzIChhZnRlciB0cmFuc3BpbGUpLlxuICogQm90aCB3b3JrIHRoZSBzYW1lIGJ1dCBub2RlIGFkZHMgYHN1cGVyX2AgdG8gdGhlIHN1YkNsYXNzXG4gKiBhbmQgQmFibGUgYWRkcyB0aGUgc3VwZXJDbGFzcyBhcyBfX3Byb3RvX18uIEJvdGggc2VlbSB1c2VmdWwuXG4gKi9cbmNvbnN0IF9pbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAoc3VwZXJDbGFzcykge1xuICAgIC8vIG5vZGVcbiAgICBzdWJDbGFzcy5zdXBlcl8gPSBzdXBlckNsYXNzO1xuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBzdWJjbGFzc2luZyB1c2luZyB0aGUgc2FtZSBpbmhlcml0YW5jZSB0aGF0XG4gKiB2aWRlb2pzIHVzZXMgaW50ZXJuYWxseVxuICpcbiAqIGBgYFxuICogdmFyIEJ1dHRvbiA9IHZpZGVvanMuZ2V0Q29tcG9uZW50KCdCdXR0b24nKTtcbiAqXG4gKiB2YXIgTXlCdXR0b24gPSB2aWRlb2pzLmV4dGVuZHMoQnV0dG9uLCB7XG4gKiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAqICAgICBCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuICogICB9LFxuICpcbiAqICAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgLy8gZG9Tb21ldGhpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xuY29uc3QgZXh0ZW5kc0ZuID0gZnVuY3Rpb24oc3VwZXJDbGFzcywgc3ViQ2xhc3NNZXRob2RzPXt9KSB7XG4gIGxldCBzdWJDbGFzcyA9IGZ1bmN0aW9uKCkge1xuICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgbGV0IG1ldGhvZHMgPSB7fTtcblxuICBpZiAoc3ViQ2xhc3NNZXRob2RzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3I7XG4gICAgbWV0aG9kcyA9IHN1YkNsYXNzTWV0aG9kcztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3ViQ2xhc3NNZXRob2RzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHM7XG4gIH1cblxuICBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuXG4gIC8vIEV4dGVuZCBzdWJPYmoncyBwcm90b3R5cGUgd2l0aCBmdW5jdGlvbnMgYW5kIG90aGVyIHByb3BlcnRpZXMgZnJvbSBwcm9wc1xuICBmb3IgKHZhciBuYW1lIGluIG1ldGhvZHMpIHtcbiAgICBpZiAobWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc3ViQ2xhc3MucHJvdG90eXBlW25hbWVdID0gbWV0aG9kc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ViQ2xhc3M7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHRlbmRzRm47XG4iLCJpbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLyoqXG4gKiBTdG9yZSB0aGUgYnJvd3Nlci1zcGVjaWZpYyBtZXRob2RzIGZvciB0aGUgZnVsbHNjcmVlbiBBUElcbiAqIEB0eXBlIHtPYmplY3R8dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xubGV0IEZ1bGxzY3JlZW5BcGkgPSB7fTtcblxuLy8gYnJvd3NlciBBUEkgbWV0aG9kc1xuLy8gbWFwIGFwcHJvYWNoIGZyb20gU2NyZWVuZnVsLmpzIC0gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9zY3JlZW5mdWxsLmpzXG5jb25zdCBhcGlNYXAgPSBbXG4gIC8vIFNwZWM6IGh0dHBzOi8vZHZjcy53My5vcmcvaGcvZnVsbHNjcmVlbi9yYXctZmlsZS90aXAvT3ZlcnZpZXcuaHRtbFxuICBbXG4gICAgJ3JlcXVlc3RGdWxsc2NyZWVuJyxcbiAgICAnZXhpdEZ1bGxzY3JlZW4nLFxuICAgICdmdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgJ2Z1bGxzY3JlZW5FbmFibGVkJyxcbiAgICAnZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgJ2Z1bGxzY3JlZW5lcnJvcidcbiAgXSxcbiAgLy8gV2ViS2l0XG4gIFtcbiAgICAnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsXG4gICAgJ3dlYmtpdEZ1bGxzY3JlZW5FbGVtZW50JyxcbiAgICAnd2Via2l0RnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ1xuICBdLFxuICAvLyBPbGQgV2ViS2l0IChTYWZhcmkgNS4xKVxuICBbXG4gICAgJ3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJyxcbiAgICAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsXG4gICAgJ3dlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudCcsXG4gICAgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuICAgICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ1xuICBdLFxuICAvLyBNb3ppbGxhXG4gIFtcbiAgICAnbW96UmVxdWVzdEZ1bGxTY3JlZW4nLFxuICAgICdtb3pDYW5jZWxGdWxsU2NyZWVuJyxcbiAgICAnbW96RnVsbFNjcmVlbkVsZW1lbnQnLFxuICAgICdtb3pGdWxsU2NyZWVuRW5hYmxlZCcsXG4gICAgJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLFxuICAgICdtb3pmdWxsc2NyZWVuZXJyb3InXG4gIF0sXG4gIC8vIE1pY3Jvc29mdFxuICBbXG4gICAgJ21zUmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICdtc0V4aXRGdWxsc2NyZWVuJyxcbiAgICAnbXNGdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgJ21zRnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICdNU0Z1bGxzY3JlZW5DaGFuZ2UnLFxuICAgICdNU0Z1bGxzY3JlZW5FcnJvcidcbiAgXVxuXTtcblxubGV0IHNwZWNBcGkgPSBhcGlNYXBbMF07XG5sZXQgYnJvd3NlckFwaTtcblxuLy8gZGV0ZXJtaW5lIHRoZSBzdXBwb3J0ZWQgc2V0IG9mIGZ1bmN0aW9uc1xuZm9yIChsZXQgaSA9IDA7IGkgPCBhcGlNYXAubGVuZ3RoOyBpKyspIHtcbiAgLy8gY2hlY2sgZm9yIGV4aXRGdWxsc2NyZWVuIGZ1bmN0aW9uXG4gIGlmIChhcGlNYXBbaV1bMV0gaW4gZG9jdW1lbnQpIHtcbiAgICBicm93c2VyQXBpID0gYXBpTWFwW2ldO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbi8vIG1hcCB0aGUgYnJvd3NlciBBUEkgbmFtZXMgdG8gdGhlIHNwZWMgQVBJIG5hbWVzXG5pZiAoYnJvd3NlckFwaSkge1xuICBmb3IgKGxldCBpPTA7IGk8YnJvd3NlckFwaS5sZW5ndGg7IGkrKykge1xuICAgIEZ1bGxzY3JlZW5BcGlbc3BlY0FwaVtpXV0gPSBicm93c2VyQXBpW2ldO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZ1bGxzY3JlZW5BcGk7XG4iLCJpbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5sZXQgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcblxubGV0IGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCBhbmQgYXBwbGllcyBwcm9wZXJ0aWVzLlxuICogQHBhcmFtICB7U3RyaW5nPX0gdGFnTmFtZSAgICBOYW1lIG9mIHRhZyB0byBiZSBjcmVhdGVkLlxuICogQHBhcmFtICB7T2JqZWN0PX0gcHJvcGVydGllcyBFbGVtZW50IHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlRWwgPSBmdW5jdGlvbih0YWdOYW1lPSdkaXYnLCBwcm9wZXJ0aWVzPXt9KXtcbiAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICBvYmouZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wTmFtZSwgdmFsKXtcbiAgICAvLyBOb3QgcmVtZW1iZXJpbmcgd2h5IHdlIHdlcmUgY2hlY2tpbmcgZm9yIGRhc2hcbiAgICAvLyBidXQgdXNpbmcgc2V0QXR0cmlidXRlIG1lYW5zIHlvdSBoYXZlIHRvIHVzZSBnZXRBdHRyaWJ1dGVcblxuICAgIC8vIFRoZSBjaGVjayBmb3IgZGFzaCBjaGVja3MgZm9yIHRoZSBhcmlhLSogYXR0cmlidXRlcywgbGlrZSBhcmlhLWxhYmVsLCBhcmlhLXZhbHVlbWluLlxuICAgIC8vIFRoZSBhZGRpdGlvbmFsIGNoZWNrIGZvciBcInJvbGVcIiBpcyBiZWNhdXNlIHRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgYWRkaW5nIGF0dHJpYnV0ZXMgZG9lcyBub3RcbiAgICAvLyBhZGQgdGhlIGF0dHJpYnV0ZSBcInJvbGVcIi4gTXkgZ3Vlc3MgaXMgYmVjYXVzZSBpdCdzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBpbiBzb21lIG5hbWVzcGFjZXMsIGFsdGhvdWdoXG4gICAgLy8gYnJvd3NlcnMgaGFuZGxlIHRoZSBhdHRyaWJ1dGUganVzdCBmaW5lLiBUaGUgVzNDIGFsbG93cyBmb3IgYXJpYS0qIGF0dHJpYnV0ZXMgdG8gYmUgdXNlZCBpbiBwcmUtSFRNTDUgZG9jcy5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmltZXIvI2FyaWFodG1sLiBVc2luZyBzZXRBdHRyaWJ1dGUgZ2V0cyBhcm91bmQgdGhpcyBwcm9ibGVtLlxuICAgIGlmIChwcm9wTmFtZS5pbmRleE9mKCdhcmlhLScpICE9PSAtMSB8fCBwcm9wTmFtZSA9PT0gJ3JvbGUnKSB7XG4gICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wTmFtZSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICBlbFtwcm9wTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWw7XG59O1xuXG4vKipcbiAqIFVwcGVyY2FzZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gYmUgdXBwZXJjYXNlZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbihzdHJpbmcpe1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBPYmplY3QgZnVuY3Rpb25zIGNvbnRhaW5lclxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBvYmogPSB7fTtcblxuLyoqXG4gKiBPYmplY3QuY3JlYXRlIHNoaW0gZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2VcbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGVcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSAge09iamVjdH0gICBvYmogT2JqZWN0IHRvIHVzZSBhcyBwcm90b3R5cGVcbiAqIEBwcml2YXRlXG4gKi9cbm9iai5jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uKG9iail7XG4gIC8vQ3JlYXRlIGEgbmV3IGZ1bmN0aW9uIGNhbGxlZCAnRicgd2hpY2ggaXMganVzdCBhbiBlbXB0eSBvYmplY3QuXG4gIGZ1bmN0aW9uIEYoKSB7fVxuXG4gIC8vdGhlIHByb3RvdHlwZSBvZiB0aGUgJ0YnIGZ1bmN0aW9uIHNob3VsZCBwb2ludCB0byB0aGVcbiAgLy9wYXJhbWV0ZXIgb2YgdGhlIGFub255bW91cyBmdW5jdGlvbi5cbiAgRi5wcm90b3R5cGUgPSBvYmo7XG5cbiAgLy9jcmVhdGUgYSBuZXcgY29uc3RydWN0b3IgZnVuY3Rpb24gYmFzZWQgb2ZmIG9mIHRoZSAnRicgZnVuY3Rpb24uXG4gIHJldHVybiBuZXcgRigpO1xufTtcblxuLyoqXG4gKiBMb29wIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBpbiBhbiBvYmplY3QgYW5kIGNhbGwgYSBmdW5jdGlvblxuICogd2hvc2UgYXJndW1lbnRzIGFyZSAoa2V5LHZhbHVlKVxuICogQHBhcmFtICB7T2JqZWN0fSAgIG9iaiBPYmplY3Qgb2YgcHJvcGVydGllc1xuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICBGdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZWFjaCBwcm9wZXJ0eS5cbiAqIEB0aGlzIHsqfVxuICogQHByaXZhdGVcbiAqL1xub2JqLmVhY2ggPSBmdW5jdGlvbihvYmosIGZuLCBjb250ZXh0KXtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBmbi5jYWxsKGNvbnRleHQgfHwgdGhpcywga2V5LCBvYmpba2V5XSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzIHRvZ2V0aGVyIGFuZCByZXR1cm4gdGhlIG9yaWdpbmFsLlxuICogQHBhcmFtICB7T2JqZWN0fSBvYmoxXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iajJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbm9iai5tZXJnZSA9IGZ1bmN0aW9uKG9iajEsIG9iajIpe1xuICBpZiAoIW9iajIpIHsgcmV0dXJuIG9iajE7IH1cbiAgZm9yICh2YXIga2V5IGluIG9iajIpe1xuICAgIGlmIChoYXNPd25Qcm9wLmNhbGwob2JqMiwga2V5KSkge1xuICAgICAgb2JqMVtrZXldID0gb2JqMltrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqMTtcbn07XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGFuZCBtZXJnZSBhbnkgcHJvcGVydGllcyB0aGF0IGFyZSBvYmplY3RzXG4gKiBpbnN0ZWFkIG9mIGp1c3Qgb3ZlcndyaXRpbmcgb25lLiBVc2VzIHRvIG1lcmdlIG9wdGlvbnMgaGFzaGVzXG4gKiB3aGVyZSBkZWVwZXIgZGVmYXVsdCBzZXR0aW5ncyBhcmUgaW1wb3J0YW50LlxuICogQHBhcmFtICB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBvdmVycmlkZVxuICogQHBhcmFtICB7T2JqZWN0fSBvYmoyIE92ZXJyaWRpbmcgb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgTmV3IG9iamVjdC4gT2JqMSBhbmQgT2JqMiB3aWxsIGJlIHVudG91Y2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbm9iai5kZWVwTWVyZ2UgPSBmdW5jdGlvbihvYmoxLCBvYmoyKXtcbiAgdmFyIGtleSwgdmFsMSwgdmFsMjtcblxuICAvLyBtYWtlIGEgY29weSBvZiBvYmoxIHNvIHdlJ3JlIG5vdCBvdmVyd3JpdGluZyBvcmlnaW5hbCB2YWx1ZXMuXG4gIC8vIGxpa2UgcHJvdG90eXBlLm9wdGlvbnNfIGFuZCBhbGwgc3ViIG9wdGlvbnMgb2JqZWN0c1xuICBvYmoxID0gb2JqLmNvcHkob2JqMSk7XG5cbiAgZm9yIChrZXkgaW4gb2JqMil7XG4gICAgaWYgKGhhc093blByb3AuY2FsbChvYmoyLCBrZXkpKSB7XG4gICAgICB2YWwxID0gb2JqMVtrZXldO1xuICAgICAgdmFsMiA9IG9iajJba2V5XTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYm90aCBwcm9wZXJ0aWVzIGFyZSBwdXJlIG9iamVjdHMgYW5kIGRvIGEgZGVlcCBtZXJnZSBpZiBzb1xuICAgICAgaWYgKG9iai5pc1BsYWluKHZhbDEpICYmIG9iai5pc1BsYWluKHZhbDIpKSB7XG4gICAgICAgIG9iajFba2V5XSA9IG9iai5kZWVwTWVyZ2UodmFsMSwgdmFsMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmoxW2tleV0gPSBvYmoyW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmoxO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgY29weSBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gY29weVxuICogQHJldHVybiB7T2JqZWN0fSAgICAgQ29weSBvZiBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbm9iai5jb3B5ID0gZnVuY3Rpb24ob2JqVG9Db3B5KXtcbiAgcmV0dXJuIG9iai5tZXJnZSh7fSwgb2JqVG9Db3B5KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIHBsYWluLCBhbmQgbm90IGEgZG9tIG5vZGUgb3IgYW55IG9iamVjdCBzdWItaW5zdGFuY2VcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqIE9iamVjdCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgaWYgcGxhaW4sIGZhbHNlIG90aGVyd2lzZVxuICogQHByaXZhdGVcbiAqL1xub2JqLmlzUGxhaW4gPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gISFvYmpcbiAgICAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xuICAgICYmIG9iai50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgQXJyYXlcbiogIFNpbmNlIGluc3RhbmNlb2YgQXJyYXkgd2lsbCBub3Qgd29yayBvbiBhcnJheXMgY3JlYXRlZCBpbiBhbm90aGVyIGZyYW1lIHdlIG5lZWQgdG8gdXNlIEFycmF5LmlzQXJyYXksIGJ1dCBzaW5jZSBJRTggZG9lcyBub3Qgc3VwcG9ydCBBcnJheS5pc0FycmF5IHdlIG5lZWQgdGhpcyBzaGltXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIHBsYWluLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBwcml2YXRlXG4gKi9cbm9iai5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBCaW5kIChhLmsuYSBwcm94eSBvciBDb250ZXh0KS4gQSBzaW1wbGUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgY29udGV4dCBvZiBhIGZ1bmN0aW9uXG4gICBJdCBhbHNvIHN0b3JlcyBhIHVuaXF1ZSBpZCBvbiB0aGUgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGVhc2lseSByZW1vdmVkIGZyb20gZXZlbnRzXG4gKiBAcGFyYW0gIHsqfSAgIGNvbnRleHQgVGhlIG9iamVjdCB0byBiaW5kIGFzIHNjb3BlXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgYm91bmQgdG8gYSBzY29wZVxuICogQHBhcmFtICB7TnVtYmVyPX0gICB1aWQgICAgIEFuIG9wdGlvbmFsIHVuaXF1ZSBJRCBmb3IgdGhlIGZ1bmN0aW9uIHRvIGJlIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYmluZCA9IGZ1bmN0aW9uKGNvbnRleHQsIGZuLCB1aWQpIHtcbiAgLy8gTWFrZSBzdXJlIHRoZSBmdW5jdGlvbiBoYXMgYSB1bmlxdWUgSURcbiAgaWYgKCFmbi5ndWlkKSB7IGZuLmd1aWQgPSBndWlkKys7IH1cblxuICAvLyBDcmVhdGUgdGhlIG5ldyBmdW5jdGlvbiB0aGF0IGNoYW5nZXMgdGhlIGNvbnRleHRcbiAgbGV0IHJldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEFsbG93IGZvciB0aGUgYWJpbGl0eSB0byBpbmRpdmlkdWFsaXplIHRoaXMgZnVuY3Rpb25cbiAgLy8gTmVlZGVkIGluIHRoZSBjYXNlIHdoZXJlIG11bHRpcGxlIG9iamVjdHMgbWlnaHQgc2hhcmUgdGhlIHNhbWUgcHJvdG90eXBlXG4gIC8vIElGIGJvdGggaXRlbXMgYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHdpdGggdGhlIHNhbWUgZnVuY3Rpb24sIHRoZW4geW91IHRyeSB0byByZW1vdmUganVzdCBvbmVcbiAgLy8gaXQgd2lsbCByZW1vdmUgYm90aCBiZWNhdXNlIHRoZXkgYm90aCBoYXZlIHRoZSBzYW1lIGd1aWQuXG4gIC8vIHdoZW4gdXNpbmcgdGhpcywgeW91IG5lZWQgdG8gdXNlIHRoZSBiaW5kIG1ldGhvZCB3aGVuIHlvdSByZW1vdmUgdGhlIGxpc3RlbmVyIGFzIHdlbGwuXG4gIC8vIGN1cnJlbnRseSB1c2VkIGluIHRleHQgdHJhY2tzXG4gIHJldC5ndWlkID0gKHVpZCkgPyB1aWQgKyAnXycgKyBmbi5ndWlkIDogZm4uZ3VpZDtcblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBFbGVtZW50IERhdGEgU3RvcmUuIEFsbG93cyBmb3IgYmluZGluZyBkYXRhIHRvIGFuIGVsZW1lbnQgd2l0aG91dCBwdXR0aW5nIGl0IGRpcmVjdGx5IG9uIHRoZSBlbGVtZW50LlxuICogRXguIEV2ZW50IGxpc3RlbmVycyBhcmUgc3RvcmVkIGhlcmUuXG4gKiAoYWxzbyBmcm9tIGpzbmluamEuY29tLCBzbGlnaHRseSBtb2RpZmllZCBhbmQgdXBkYXRlZCBmb3IgY2xvc3VyZSBjb21waWxlcilcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBVbmlxdWUgSUQgZm9yIGFuIGVsZW1lbnQgb3IgZnVuY3Rpb25cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZ3VpZCA9IDE7XG5cbi8qKlxuICogVW5pcXVlIGF0dHJpYnV0ZSBuYW1lIHRvIHN0b3JlIGFuIGVsZW1lbnQncyBndWlkIGluXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGNvbnN0YW50XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhwYW5kbyA9ICd2ZGF0YScgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNhY2hlIG9iamVjdCB3aGVyZSBkYXRhIGZvciBhbiBlbGVtZW50IGlzIHN0b3JlZFxuICogQHBhcmFtICB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBzdG9yZSBkYXRhIGZvci5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBnZXREYXRhID0gZnVuY3Rpb24oZWwpe1xuICB2YXIgaWQgPSBlbFtleHBhbmRvXTtcbiAgaWYgKCFpZCkge1xuICAgIGlkID0gZWxbZXhwYW5kb10gPSBndWlkKys7XG4gIH1cbiAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICBjYWNoZVtpZF0gPSB7fTtcbiAgfVxuICByZXR1cm4gY2FjaGVbaWRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgd2hlcmUgZGF0YSBmb3IgYW4gZWxlbWVudCBpcyBzdG9yZWRcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsIEVsZW1lbnQgdG8gc3RvcmUgZGF0YSBmb3IuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaGFzRGF0YSA9IGZ1bmN0aW9uKGVsKXtcbiAgdmFyIGlkID0gZWxbZXhwYW5kb107XG4gIHJldHVybiAhKCFpZCB8fCBpc0VtcHR5KGNhY2hlW2lkXSkpO1xufTtcblxuLyoqXG4gKiBEZWxldGUgZGF0YSBmb3IgdGhlIGVsZW1lbnQgZnJvbSB0aGUgY2FjaGUgYW5kIHRoZSBndWlkIGF0dHIgZnJvbSBnZXRFbGVtZW50QnlJZFxuICogQHBhcmFtICB7RWxlbWVudH0gZWwgUmVtb3ZlIGRhdGEgZm9yIGFuIGVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciByZW1vdmVEYXRhID0gZnVuY3Rpb24oZWwpe1xuICB2YXIgaWQgPSBlbFtleHBhbmRvXTtcbiAgaWYgKCFpZCkgeyByZXR1cm47IH1cbiAgLy8gUmVtb3ZlIGFsbCBzdG9yZWQgZGF0YVxuICAvLyBDaGFuZ2VkIHRvID0gbnVsbFxuICAvLyBodHRwOi8vY29kaW5nLnNtYXNoaW5nbWFnYXppbmUuY29tLzIwMTIvMTEvMDUvd3JpdGluZy1mYXN0LW1lbW9yeS1lZmZpY2llbnQtamF2YXNjcmlwdC9cbiAgLy8gY2FjaGVbaWRdID0gbnVsbDtcbiAgZGVsZXRlIGNhY2hlW2lkXTtcblxuICAvLyBSZW1vdmUgdGhlIGV4cGFuZG8gcHJvcGVydHkgZnJvbSB0aGUgRE9NIG5vZGVcbiAgdHJ5IHtcbiAgICBkZWxldGUgZWxbZXhwYW5kb107XG4gIH0gY2F0Y2goZSkge1xuICAgIGlmIChlbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShleHBhbmRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgZG9lc24ndCBhcHBlYXIgdG8gc3VwcG9ydCByZW1vdmVBdHRyaWJ1dGUgb24gdGhlIGRvY3VtZW50IGVsZW1lbnRcbiAgICAgIGVsW2V4cGFuZG9dID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGVtcHR5XG4gKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogVGhlIG9iamVjdCB0byBjaGVjayBmb3IgZW1wdGluZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAvLyBJbmx1ZGUgbnVsbCBwcm9wZXJ0aWVzIGFzIGVtcHR5LlxuICAgIGlmIChvYmpbcHJvcF0gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9DaGVjayBDbGFzc25hbWUgdG8gY2hlY2tcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBoYXNDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzVG9DaGVjayl7XG4gIHJldHVybiAoKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzVG9DaGVjayArICcgJykgIT09IC0xKTtcbn07XG5cbi8qKlxuICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gYW4gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgIEVsZW1lbnQgdG8gYWRkIGNsYXNzIG5hbWUgdG9cbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc1RvQWRkIENsYXNzbmFtZSB0byBhZGRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzVG9BZGQpe1xuICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzVG9BZGQpKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSA9PT0gJycgPyBjbGFzc1RvQWRkIDogZWxlbWVudC5jbGFzc05hbWUgKyAnICcgKyBjbGFzc1RvQWRkO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gYW4gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgIEVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gY2xhc3MgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9BZGQgQ2xhc3NuYW1lIHRvIHJlbW92ZVxuICogQHByaXZhdGVcbiAqL1xudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NUb1JlbW92ZSl7XG4gIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1JlbW92ZSkpIHtyZXR1cm47fVxuXG4gIGxldCBjbGFzc05hbWVzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcblxuICAvLyBubyBhcnIuaW5kZXhPZiBpbiBpZTgsIGFuZCB3ZSBkb24ndCB3YW50IHRvIGFkZCBhIGJpZyBzaGltXG4gIGZvciAobGV0IGkgPSBjbGFzc05hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGNsYXNzTmFtZXNbaV0gPT09IGNsYXNzVG9SZW1vdmUpIHtcbiAgICAgIGNsYXNzTmFtZXMuc3BsaWNlKGksMSk7XG4gICAgfVxuICB9XG5cbiAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogRWxlbWVudCBmb3IgdGVzdGluZyBicm93c2VyIEhUTUw1IHZpZGVvIGNhcGFiaWxpdGllc1xuICogQHR5cGUge0VsZW1lbnR9XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBURVNUX1ZJRCA9IGNyZWF0ZUVsKCd2aWRlbycpO1xubGV0IHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcbnRyYWNrLmtpbmQgPSAnY2FwdGlvbnMnO1xudHJhY2suc3JjbGFuZyA9ICdlbic7XG50cmFjay5sYWJlbCA9ICdFbmdsaXNoJztcblRFU1RfVklELmFwcGVuZENoaWxkKHRyYWNrKTtcblxuLyoqXG4gKiBVc2VyYWdlbnQgZm9yIGJyb3dzZXIgdGVzdGluZy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBVU0VSX0FHRU5UID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuLyoqXG4gKiBEZXZpY2UgaXMgYW4gaVBob25lXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xudmFyIElTX0lQSE9ORSA9ICgvaVBob25lL2kpLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfSVBBRCA9ICgvaVBhZC9pKS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIElTX0lQT0QgPSAoL2lQb2QvaSkudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19JT1MgPSBJU19JUEhPTkUgfHwgSVNfSVBBRCB8fCBJU19JUE9EO1xuXG52YXIgSU9TX1ZFUlNJT04gPSAoZnVuY3Rpb24oKXtcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvT1MgKFxcZCspXy9pKTtcbiAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7IHJldHVybiBtYXRjaFsxXTsgfVxufSkoKTtcblxudmFyIElTX0FORFJPSUQgPSAoL0FuZHJvaWQvaSkudGVzdChVU0VSX0FHRU5UKTtcbnZhciBBTkRST0lEX1ZFUlNJT04gPSAoZnVuY3Rpb24oKSB7XG4gIC8vIFRoaXMgbWF0Y2hlcyBBbmRyb2lkIE1ham9yLk1pbm9yLlBhdGNoIHZlcnNpb25zXG4gIC8vIEFORFJPSURfVkVSU0lPTiBpcyBNYWpvci5NaW5vciBhcyBhIE51bWJlciwgaWYgTWlub3IgaXNuJ3QgYXZhaWxhYmxlLCB0aGVuIG9ubHkgTWFqb3IgaXMgcmV0dXJuZWRcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvQW5kcm9pZCAoXFxkKykoPzpcXC4oXFxkKykpPyg/OlxcLihcXGQrKSkqL2kpLFxuICAgIG1ham9yLFxuICAgIG1pbm9yO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG1ham9yID0gbWF0Y2hbMV0gJiYgcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIG1pbm9yID0gbWF0Y2hbMl0gJiYgcGFyc2VGbG9hdChtYXRjaFsyXSk7XG5cbiAgaWYgKG1ham9yICYmIG1pbm9yKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0gKyAnLicgKyBtYXRjaFsyXSk7XG4gIH0gZWxzZSBpZiAobWFqb3IpIHtcbiAgICByZXR1cm4gbWFqb3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0pKCk7XG4vLyBPbGQgQW5kcm9pZCBpcyBkZWZpbmVkIGFzIFZlcnNpb24gb2xkZXIgdGhhbiAyLjMsIGFuZCByZXF1aXJpbmcgYSB3ZWJraXQgdmVyc2lvbiBvZiB0aGUgYW5kcm9pZCBicm93c2VyXG52YXIgSVNfT0xEX0FORFJPSUQgPSBJU19BTkRST0lEICYmICgvd2Via2l0L2kpLnRlc3QoVVNFUl9BR0VOVCkgJiYgQU5EUk9JRF9WRVJTSU9OIDwgMi4zO1xuXG52YXIgSVNfRklSRUZPWCA9ICgvRmlyZWZveC9pKS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIElTX0NIUk9NRSA9ICgvQ2hyb21lL2kpLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfSUU4ID0gKC9NU0lFXFxzOFxcLjAvKS50ZXN0KFVTRVJfQUdFTlQpO1xuXG52YXIgVE9VQ0hfRU5BQkxFRCA9ICEhKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpO1xudmFyIEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQgPSAnYmFja2dyb3VuZFNpemUnIGluIFRFU1RfVklELnN0eWxlO1xuXG4vKipcbiAqIEFwcGx5IGF0dHJpYnV0ZXMgdG8gYW4gSFRNTCBlbGVtZW50LlxuICogQHBhcmFtICB7RWxlbWVudH0gZWwgICAgICAgICBUYXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSAge09iamVjdD19IGF0dHJpYnV0ZXMgRWxlbWVudCBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgc2V0RWxlbWVudEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbCwgYXR0cmlidXRlcyl7XG4gIG9iai5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHJOYW1lLCBhdHRyVmFsdWUpIHtcbiAgICBpZiAoYXR0clZhbHVlID09PSBudWxsIHx8IHR5cGVvZiBhdHRyVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IGF0dHJWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgKGF0dHJWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYXR0clZhbHVlKSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWVzLCBhcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRhZ1xuICogQXR0cmlidXRlcyBhcmUgbm90IHRoZSBzYW1lIGFzIHByb3BlcnRpZXMuIFRoZXkncmUgZGVmaW5lZCBvbiB0aGUgdGFnXG4gKiBvciB3aXRoIHNldEF0dHJpYnV0ZSAod2hpY2ggc2hvdWxkbid0IGJlIHVzZWQgd2l0aCBIVE1MKVxuICogVGhpcyB3aWxsIHJldHVybiB0cnVlIG9yIGZhbHNlIGZvciBib29sZWFuIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSB0YWcgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCB0YWcgYXR0cmlidXRlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGdldEVsZW1lbnRBdHRyaWJ1dGVzID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIG9iaiwga25vd25Cb29sZWFucywgYXR0cnMsIGF0dHJOYW1lLCBhdHRyVmFsO1xuXG4gIG9iaiA9IHt9O1xuXG4gIC8vIGtub3duIGJvb2xlYW4gYXR0cmlidXRlc1xuICAvLyB3ZSBjYW4gY2hlY2sgZm9yIG1hdGNoaW5nIGJvb2xlYW4gcHJvcGVydGllcywgYnV0IG9sZGVyIGJyb3dzZXJzXG4gIC8vIHdvbid0IGtub3cgYWJvdXQgSFRNTDUgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgd2Ugc3RpbGwgcmVhZCBmcm9tXG4gIGtub3duQm9vbGVhbnMgPSAnLCcrJ2F1dG9wbGF5LGNvbnRyb2xzLGxvb3AsbXV0ZWQsZGVmYXVsdCcrJywnO1xuXG4gIGlmICh0YWcgJiYgdGFnLmF0dHJpYnV0ZXMgJiYgdGFnLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgIGF0dHJzID0gdGFnLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGF0dHJOYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICAgIGF0dHJWYWwgPSBhdHRyc1tpXS52YWx1ZTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGtub3duIGJvb2xlYW5zXG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgZWxlbWVudCBwcm9wZXJ0eSB3aWxsIHJldHVybiBhIHZhbHVlIGZvciB0eXBlb2ZcbiAgICAgIGlmICh0eXBlb2YgdGFnW2F0dHJOYW1lXSA9PT0gJ2Jvb2xlYW4nIHx8IGtub3duQm9vbGVhbnMuaW5kZXhPZignLCcrYXR0ck5hbWUrJywnKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gdGhlIHZhbHVlIG9mIGFuIGluY2x1ZGVkIGJvb2xlYW4gYXR0cmlidXRlIGlzIHR5cGljYWxseSBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcgKCcnKSB3aGljaCB3b3VsZCBlcXVhbCBmYWxzZSBpZiB3ZSBqdXN0IGNoZWNrIGZvciBhIGZhbHNlIHZhbHVlLlxuICAgICAgICAvLyB3ZSBhbHNvIGRvbid0IHdhbnQgc3VwcG9ydCBiYWQgY29kZSBsaWtlIGF1dG9wbGF5PSdmYWxzZSdcbiAgICAgICAgYXR0clZhbCA9IChhdHRyVmFsICE9PSBudWxsKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb2JqW2F0dHJOYW1lXSA9IGF0dHJWYWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb21wdXRlZCBzdHlsZSB2YWx1ZSBmb3IgYW4gZWxlbWVudFxuICogRnJvbSBodHRwOi8vcm9iZXJ0bnltYW4uY29tLzIwMDYvMDQvMjQvZ2V0LXRoZS1yZW5kZXJlZC1zdHlsZS1vZi1hbi1lbGVtZW50L1xuICogQHBhcmFtICB7RWxlbWVudH0gZWwgICAgICAgIEVsZW1lbnQgdG8gZ2V0IHN0eWxlIHZhbHVlIGZvclxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJDc3NSdWxlIFN0eWxlIG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICBTdHlsZSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xudmFyIGdldENvbXB1dGVkRGltZW5zaW9uID0gZnVuY3Rpb24oZWwsIHN0ckNzc1J1bGUpe1xuICB2YXIgc3RyVmFsdWUgPSAnJztcbiAgaWYoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSl7XG4gICAgc3RyVmFsdWUgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJykuZ2V0UHJvcGVydHlWYWx1ZShzdHJDc3NSdWxlKTtcblxuICB9IGVsc2UgaWYoZWwuY3VycmVudFN0eWxlKXtcbiAgICAvLyBJRTggV2lkdGgvSGVpZ2h0IHN1cHBvcnRcbiAgICBsZXQgdXBwZXJDYXNlZFJ1bGUgPSBzdHJDc3NSdWxlLnN1YnN0cigwLDEpLnRvVXBwZXJDYXNlKCkgKyBzdHJDc3NSdWxlLnN1YnN0cigxKTtcbiAgICBzdHJWYWx1ZSA9IGVsW2BjbGllbnQke3VwcGVyQ2FzZWRSdWxlfWBdICsgJ3B4JztcbiAgfVxuICByZXR1cm4gc3RyVmFsdWU7XG59O1xuXG4vKipcbiAqIEluc2VydCBhbiBlbGVtZW50IGFzIHRoZSBmaXJzdCBjaGlsZCBub2RlIG9mIGFub3RoZXJcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGNoaWxkICAgRWxlbWVudCB0byBpbnNlcnRcbiAqIEBwYXJhbSAge1t0eXBlXX0gcGFyZW50IEVsZW1lbnQgdG8gaW5zZXJ0IGNoaWxkIGludG9cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpbnNlcnRGaXJzdCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpe1xuICBpZiAocGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYmplY3QgdG8gaG9sZCBicm93c2VyIHN1cHBvcnQgaW5mb3JtYXRpb25cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYnJvd3NlciA9IHt9O1xuXG4vKipcbiAqIFNob3J0aGFuZCBmb3IgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoKVxuICogQWxzbyBhbGxvd3MgZm9yIENTUyAoalF1ZXJ5KSBJRCBzeW50YXguIEJ1dCBub3RoaW5nIG90aGVyIHRoYW4gSURzLlxuICogQHBhcmFtICB7U3RyaW5nfSBpZCAgRWxlbWVudCBJRFxuICogQHJldHVybiB7RWxlbWVudH0gICAgRWxlbWVudCB3aXRoIHN1cHBsaWVkIElEXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZWwgPSBmdW5jdGlvbihpZCl7XG4gIGlmIChpZC5pbmRleE9mKCcjJykgPT09IDApIHtcbiAgICBpZCA9IGlkLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbn07XG5cbi8qKlxuICogRm9ybWF0IHNlY29uZHMgYXMgYSB0aW1lIHN0cmluZywgSDpNTTpTUyBvciBNOlNTXG4gKiBTdXBwbHlpbmcgYSBndWlkZSAoaW4gc2Vjb25kcykgd2lsbCBmb3JjZSBhIG51bWJlciBvZiBsZWFkaW5nIHplcm9zXG4gKiB0byBjb3ZlciB0aGUgbGVuZ3RoIG9mIHRoZSBndWlkZVxuICogQHBhcmFtICB7TnVtYmVyfSBzZWNvbmRzIE51bWJlciBvZiBzZWNvbmRzIHRvIGJlIHR1cm5lZCBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGd1aWRlICAgTnVtYmVyIChpbiBzZWNvbmRzKSB0byBtb2RlbCB0aGUgc3RyaW5nIGFmdGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgVGltZSBmb3JtYXR0ZWQgYXMgSDpNTTpTUyBvciBNOlNTXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZm9ybWF0VGltZSA9IGZ1bmN0aW9uKHNlY29uZHMsIGd1aWRlPXNlY29uZHMpIHtcbiAgbGV0IHMgPSBNYXRoLmZsb29yKHNlY29uZHMgJSA2MCk7XG4gIGxldCBtID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjAgJSA2MCk7XG4gIGxldCBoID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gMzYwMCk7XG4gIGNvbnN0IGdtID0gTWF0aC5mbG9vcihndWlkZSAvIDYwICUgNjApO1xuICBjb25zdCBnaCA9IE1hdGguZmxvb3IoZ3VpZGUgLyAzNjAwKTtcblxuICAvLyBoYW5kbGUgaW52YWxpZCB0aW1lc1xuICBpZiAoaXNOYU4oc2Vjb25kcykgfHwgc2Vjb25kcyA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyAnLScgaXMgZmFsc2UgZm9yIGFsbCByZWxhdGlvbmFsIG9wZXJhdG9ycyAoZS5nLiA8LCA+PSkgc28gdGhpcyBzZXR0aW5nXG4gICAgLy8gd2lsbCBhZGQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGZpZWxkcyBzcGVjaWZpZWQgYnkgdGhlIGd1aWRlXG4gICAgaCA9IG0gPSBzID0gJy0nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzaG93IGhvdXJzXG4gIGggPSAoaCA+IDAgfHwgZ2ggPiAwKSA/IGggKyAnOicgOiAnJztcblxuICAvLyBJZiBob3VycyBhcmUgc2hvd2luZywgd2UgbWF5IG5lZWQgdG8gYWRkIGEgbGVhZGluZyB6ZXJvLlxuICAvLyBBbHdheXMgc2hvdyBhdCBsZWFzdCBvbmUgZGlnaXQgb2YgbWludXRlcy5cbiAgbSA9ICgoKGggfHwgZ20gPj0gMTApICYmIG0gPCAxMCkgPyAnMCcgKyBtIDogbSkgKyAnOic7XG5cbiAgLy8gQ2hlY2sgaWYgbGVhZGluZyB6ZXJvIGlzIG5lZWQgZm9yIHNlY29uZHNcbiAgcyA9IChzIDwgMTApID8gJzAnICsgcyA6IHM7XG5cbiAgcmV0dXJuIGggKyBtICsgcztcbn07XG5cbi8vIEF0dGVtcHQgdG8gYmxvY2sgdGhlIGFiaWxpdHkgdG8gc2VsZWN0IHRleHQgd2hpbGUgZHJhZ2dpbmcgY29udHJvbHNcbnZhciBibG9ja1RleHRTZWxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gIGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbn07XG4vLyBUdXJuIG9mZiB0ZXh0IHNlbGVjdGlvbiBibG9ja2luZ1xudmFyIHVuYmxvY2tUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24oKXsgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07IH07XG5cbi8qKlxuICogVHJpbSB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZHMgb2YgYSBzdHJpbmcuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgVHJpbW1lZCBzdHJpbmdcbiAqIEBwcml2YXRlXG4gKi9cbnZhciB0cmltID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIChzdHIrJycpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIHJvdW5kIG9mZiBhIG51bWJlciB0byBhIGRlY2ltYWwgcGxhY2VcbiAqIEBwYXJhbSAge051bWJlcn0gbnVtIE51bWJlciB0byByb3VuZFxuICogQHBhcmFtICB7TnVtYmVyfSBkZWMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kIHRvXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBSb3VuZGVkIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xudmFyIHJvdW5kID0gZnVuY3Rpb24obnVtLCBkZWM9MCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0qTWF0aC5wb3coMTAsZGVjKSkvTWF0aC5wb3coMTAsZGVjKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGNyZWF0ZSBhIGZha2UgVGltZVJhbmdlIG9iamVjdFxuICogTWltaWNzIGFuIEhUTUw1IHRpbWUgcmFuZ2UgaW5zdGFuY2UsIHdoaWNoIGhhcyBmdW5jdGlvbnMgdGhhdFxuICogcmV0dXJuIHRoZSBzdGFydCBhbmQgZW5kIHRpbWVzIGZvciBhIHJhbmdlXG4gKiBUaW1lUmFuZ2VzIGFyZSByZXR1cm5lZCBieSB0aGUgYnVmZmVyZWQoKSBtZXRob2RcbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnQgU3RhcnQgdGltZSBpbiBzZWNvbmRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZCAgIEVuZCB0aW1lIGluIHNlY29uZHNcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgRmFrZSBUaW1lUmFuZ2Ugb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlVGltZVJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCl7XG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiAxLFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YXJ0OyB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7IHJldHVybiBlbmQ7IH1cbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIHRvIGxvY2FsIHN0b3JhZ2UgKG1heWJlIHJlbW92YWJsZSlcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBzZXRMb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgdHJ5IHtcbiAgICAvLyBJRSB3YXMgdGhyb3dpbmcgZXJyb3JzIHJlZmVyZW5jaW5nIHRoZSB2YXIgYW55d2hlcmUgd2l0aG91dCB0aGlzXG4gICAgbGV0IGxvY2FsU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UgfHwgZmFsc2U7XG4gICAgaWYgKCFsb2NhbFN0b3JhZ2UpIHsgcmV0dXJuOyB9XG4gICAgbG9jYWxTdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgaWYgKGUuY29kZSA9PT0gMjIgfHwgZS5jb2RlID09PSAxMDE0KSB7IC8vIFdlYmtpdCA9PSAyMiAvIEZpcmVmb3ggPT0gMTAxNFxuICAgICAgbG9nKCdMb2NhbFN0b3JhZ2UgRnVsbCAoVmlkZW9KUyknLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGUuY29kZSA9PT0gMTgpIHtcbiAgICAgICAgbG9nKCdMb2NhbFN0b3JhZ2Ugbm90IGFsbG93ZWQgKFZpZGVvSlMpJywgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2coJ0xvY2FsU3RvcmFnZSBFcnJvciAoVmlkZW9KUyknLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGFic29sdXRlIHZlcnNpb24gb2YgcmVsYXRpdmUgVVJMLiBVc2VkIHRvIHRlbGwgZmxhc2ggY29ycmVjdCBVUkwuXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ3MDgzMi9nZXR0aW5nLWFuLWFic29sdXRlLXVybC1mcm9tLWEtcmVsYXRpdmUtb25lLWllNi1pc3N1ZVxuICogQHBhcmFtICB7U3RyaW5nfSB1cmwgVVJMIHRvIG1ha2UgYWJzb2x1dGVcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgIEFic29sdXRlIFVSTFxuICogQHByaXZhdGVcbiAqL1xudmFyIGdldEFic29sdXRlVVJMID0gZnVuY3Rpb24odXJsKXtcbiAgLy8gQ2hlY2sgaWYgYWJzb2x1dGUgVVJMXG4gIGlmICghdXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy8pKSB7XG4gICAgLy8gQ29udmVydCB0byBhYnNvbHV0ZSBVUkwuIEZsYXNoIGhvc3RlZCBvZmYtc2l0ZSBuZWVkcyBhbiBhYnNvbHV0ZSBVUkwuXG4gICAgdXJsID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGlubmVySFRNTDogYDxhIGhyZWY9XCIke3VybH1cIj54PC9hPmBcbiAgICB9KS5maXJzdENoaWxkLmhyZWY7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIGFuZCBwYXJzZSB0aGUgZWxlbWVudHMgb2YgYSBVUkxcbiAqIEBwYXJhbSAge1N0cmluZ30gdXJsIFRoZSB1cmwgdG8gcGFyc2VcbiAqIEByZXR1cm4ge09iamVjdH0gICAgIEFuIG9iamVjdCBvZiB1cmwgZGV0YWlsc1xuICovXG52YXIgcGFyc2VVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgY29uc3QgcHJvcHMgPSBbJ3Byb3RvY29sJywgJ2hvc3RuYW1lJywgJ3BvcnQnLCAncGF0aG5hbWUnLCAnc2VhcmNoJywgJ2hhc2gnLCAnaG9zdCddO1xuXG4gIC8vIGFkZCB0aGUgdXJsIHRvIGFuIGFuY2hvciBhbmQgbGV0IHRoZSBicm93c2VyIHBhcnNlIHRoZSBVUkxcbiAgbGV0IGEgPSBjcmVhdGVFbCgnYScsIHsgaHJlZjogdXJsIH0pO1xuXG4gIC8vIElFOCAoYW5kIDk/KSBGaXhcbiAgLy8gaWU4IGRvZXNuJ3QgcGFyc2UgdGhlIFVSTCBjb3JyZWN0bHkgdW50aWwgdGhlIGFuY2hvciBpcyBhY3R1YWxseVxuICAvLyBhZGRlZCB0byB0aGUgYm9keSwgYW5kIGFuIGlubmVySFRNTCBpcyBuZWVkZWQgdG8gdHJpZ2dlciB0aGUgcGFyc2luZ1xuICBsZXQgYWRkVG9Cb2R5ID0gKGEuaG9zdCA9PT0gJycgJiYgYS5wcm90b2NvbCAhPT0gJ2ZpbGU6Jyk7XG4gIGxldCBkaXY7XG4gIGlmIChhZGRUb0JvZHkpIHtcbiAgICBkaXYgPSBjcmVhdGVFbCgnZGl2Jyk7XG4gICAgZGl2LmlubmVySFRNTCA9IGA8YSBocmVmPVwiJHt1cmx9XCI+PC9hPmA7XG4gICAgYSA9IGRpdi5maXJzdENoaWxkO1xuICAgIC8vIHByZXZlbnQgdGhlIGRpdiBmcm9tIGFmZmVjdGluZyBsYXlvdXRcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5Om5vbmU7IHBvc2l0aW9uOmFic29sdXRlOycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIC8vIENvcHkgdGhlIHNwZWNpZmljIFVSTCBwcm9wZXJ0aWVzIHRvIGEgbmV3IG9iamVjdFxuICAvLyBUaGlzIGlzIGFsc28gbmVlZGVkIGZvciBJRTggYmVjYXVzZSB0aGUgYW5jaG9yIGxvc2VzIGl0c1xuICAvLyBwcm9wZXJ0aWVzIHdoZW4gaXQncyByZW1vdmVkIGZyb20gdGhlIGRvbVxuICBsZXQgZGV0YWlscyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGV0YWlsc1twcm9wc1tpXV0gPSBhW3Byb3BzW2ldXTtcbiAgfVxuXG4gIC8vIElFOSBhZGRzIHRoZSBwb3J0IHRvIHRoZSBob3N0IHByb3BlcnR5IHVubGlrZSBldmVyeW9uZSBlbHNlLiBJZlxuICAvLyBhIHBvcnQgaWRlbnRpZmllciBpcyBhZGRlZCBmb3Igc3RhbmRhcmQgcG9ydHMsIHN0cmlwIGl0LlxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIGRldGFpbHMuaG9zdCA9IGRldGFpbHMuaG9zdC5yZXBsYWNlKC86ODAkLywgJycpO1xuICB9XG4gIGlmIChkZXRhaWxzLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIGRldGFpbHMuaG9zdCA9IGRldGFpbHMuaG9zdC5yZXBsYWNlKC86NDQzJC8sICcnKTtcbiAgfVxuXG4gIGlmIChhZGRUb0JvZHkpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gIH1cblxuICByZXR1cm4gZGV0YWlscztcbn07XG5cbi8qKlxuICogTG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlIGFuZCBoaXN0b3J5IGJhc2VkIG9uIHRoZSB0eXBlIG9mIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgbWVzc2FnZSwgb3IgYG51bGxgIGZvciBgbG9nYFxuICogQHBhcmFtICB7W3R5cGVdfSBhcmdzIFRoZSBhcmdzIHRvIGJlIHBhc3NlZCB0byB0aGUgbG9nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfbG9nVHlwZSh0eXBlLCBhcmdzKXtcbiAgLy8gY29udmVydCBhcmdzIHRvIGFuIGFycmF5IHRvIGdldCBhcnJheSBmdW5jdGlvbnNcbiAgbGV0IGFyZ3NBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAvLyBpZiB0aGVyZSdzIG5vIGNvbnNvbGUgdGhlbiBkb24ndCB0cnkgdG8gb3V0cHV0IG1lc3NhZ2VzXG4gIC8vIHRoZXkgd2lsbCBzdGlsbCBiZSBzdG9yZWQgaW4gTGliLmxvZy5oaXN0b3J5XG4gIC8vIFdhcyBzZXR0aW5nIHRoZXNlIG9uY2Ugb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLCBidXQgY29udGFpbmluZyB0aGVtXG4gIC8vIGluIHRoZSBmdW5jdGlvbiBtYWtlcyBpdCBlYXNpZXIgdG8gdGVzdCBjYXNlcyB3aGVyZSBjb25zb2xlIGRvZXNuJ3QgZXhpc3RcbiAgbGV0IG5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgbGV0IGNvbnNvbGUgPSB3aW5kb3dbJ2NvbnNvbGUnXSB8fCB7XG4gICAgJ2xvZyc6IG5vb3AsXG4gICAgJ3dhcm4nOiBub29wLFxuICAgICdlcnJvcic6IG5vb3BcbiAgfTtcblxuICBpZiAodHlwZSkge1xuICAgIC8vIGFkZCB0aGUgdHlwZSB0byB0aGUgZnJvbnQgb2YgdGhlIG1lc3NhZ2VcbiAgICBhcmdzQXJyYXkudW5zaGlmdCh0eXBlLnRvVXBwZXJDYXNlKCkrJzonKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBkZWZhdWx0IHRvIGxvZyB3aXRoIG5vIHByZWZpeFxuICAgIHR5cGUgPSAnbG9nJztcbiAgfVxuXG4gIC8vIGFkZCB0byBoaXN0b3J5XG4gIGxvZy5oaXN0b3J5LnB1c2goYXJnc0FycmF5KTtcblxuICAvLyBhZGQgY29uc29sZSBwcmVmaXggYWZ0ZXIgYWRkaW5nIHRvIGhpc3RvcnlcbiAgYXJnc0FycmF5LnVuc2hpZnQoJ1ZJREVPSlM6Jyk7XG5cbiAgLy8gY2FsbCBhcHByb3ByaWF0ZSBsb2cgZnVuY3Rpb25cbiAgaWYgKGNvbnNvbGVbdHlwZV0uYXBwbHkpIHtcbiAgICBjb25zb2xlW3R5cGVdLmFwcGx5KGNvbnNvbGUsIGFyZ3NBcnJheSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWU4IGRvZXNuJ3QgYWxsb3cgZXJyb3IuYXBwbHksIGJ1dCBpdCB3aWxsIGp1c3Qgam9pbigpIHRoZSBhcnJheSBhbnl3YXlcbiAgICBjb25zb2xlW3R5cGVdKGFyZ3NBcnJheS5qb2luKCcgJykpO1xuICB9XG59XG5cbi8qKlxuICogTG9nIHBsYWluIGRlYnVnIG1lc3NhZ2VzXG4gKi9cbnZhciBsb2cgPSBmdW5jdGlvbigpe1xuICBfbG9nVHlwZShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBLZWVwIGEgaGlzdG9yeSBvZiBsb2cgbWVzc2FnZXNcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xubG9nLmhpc3RvcnkgPSBbXTtcblxuLyoqXG4gKiBMb2cgZXJyb3IgbWVzc2FnZXNcbiAqL1xubG9nLmVycm9yID0gZnVuY3Rpb24oKXtcbiAgX2xvZ1R5cGUoJ2Vycm9yJywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogTG9nIHdhcm5pbmcgbWVzc2FnZXNcbiAqL1xubG9nLndhcm4gPSBmdW5jdGlvbigpe1xuICBfbG9nVHlwZSgnd2FybicsIGFyZ3VtZW50cyk7XG59O1xuXG4vLyBPZmZzZXQgTGVmdFxuLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRlY2huaXF1ZSBmcm9tIEpvaG4gUmVzaWcgaHR0cDovL2Vqb2huLm9yZy9ibG9nL2dldGJvdW5kaW5nY2xpZW50cmVjdC1pcy1hd2Vzb21lL1xudmFyIGZpbmRQb3NpdGlvbiA9IGZ1bmN0aW9uKGVsKSB7XG4gIGxldCBib3g7XG5cbiAgaWYgKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBpZiAoIWJveCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICBjb25zdCBjbGllbnRMZWZ0ID0gZG9jRWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcbiAgY29uc3Qgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBib2R5LnNjcm9sbExlZnQ7XG4gIGNvbnN0IGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xuXG4gIGNvbnN0IGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICBjb25zdCBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgYm9keS5zY3JvbGxUb3A7XG4gIGNvbnN0IHRvcCA9IGJveC50b3AgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3A7XG5cbiAgLy8gQW5kcm9pZCBzb21ldGltZXMgcmV0dXJucyBzbGlnaHRseSBvZmYgZGVjaW1hbCB2YWx1ZXMsIHNvIG5lZWQgdG8gcm91bmRcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiByb3VuZChsZWZ0KSxcbiAgICB0b3A6IHJvdW5kKHRvcClcbiAgfTtcbn07XG5cbi8qKlxuICogQXJyYXkgZnVuY3Rpb25zIGNvbnRhaW5lclxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhcnIgPSB7fTtcblxuLypcbiAqIExvb3BzIHRocm91Z2ggYW4gYXJyYXkgYW5kIHJ1bnMgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtIGluc2lkZSBpdC5cbiAqIEBwYXJhbSAge0FycmF5fSAgICBhcnJheSAgICAgICBUaGUgYXJyYXlcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgICBUaGUgZnVuY3Rpb24gdG8gYmUgcnVuIGZvciBlYWNoIGl0ZW1cbiAqIEBwYXJhbSAgeyp9ICAgICAgICB0aGlzQXJnICAgICBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtBcnJheX0gICAgICAgICAgICAgICBUaGUgYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbmFyci5mb3JFYWNoID0gZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIHRoaXNBcmcgPSB0aGlzQXJnIHx8IHRoaXM7XG5cbiAgaWYgKG9iai5pc0FycmF5KGFycmF5KSAmJiBjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gb2YgdGhlIHBhc3NlZCBmaWxlIG5hbWUuIEl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IHN0cmluZyBpZiB5b3UgcGFzcyBhbiBpbnZhbGlkIHBhdGhcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gICAgcGF0aCAgICBUaGUgZmlsZU5hbWUgcGF0aCBsaWtlICcvcGF0aC90by9maWxlLm1wNCdcbiAqIEByZXR1cm5zIHtTdHJpbmd9ICAgICAgICAgIFRoZSBleHRlbnNpb24gaW4gbG93ZXIgY2FzZSBvciBhbiBlbXB0eSBzdHJpbmcgaWYgbm8gZXh0ZW5zaW9uIGNvdWxkIGJlIGZvdW5kLlxuICovXG52YXIgZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKXtcbiAgICBsZXQgc3BsaXRQYXRoUmUgPSAvXihcXC8/KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rPykoXFwuKFteXFwuXFwvXFw/XSspKSkoPzpbXFwvXSp8W1xcP10uKikkL2k7XG4gICAgbGV0IHBhdGhQYXJ0cyA9IHNwbGl0UGF0aFJlLmV4ZWMocGF0aCk7XG5cbiAgICBpZiAocGF0aFBhcnRzKSB7XG4gICAgICByZXR1cm4gcGF0aFBhcnRzLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0IHtcbiAgY3JlYXRlRWwsXG4gIGNhcGl0YWxpemUsXG4gIG9iaixcbiAgaXNOYU4sXG4gIGJpbmQsXG4gIGNhY2hlLFxuICBndWlkLFxuICBleHBhbmRvLFxuICBnZXREYXRhLFxuICBoYXNEYXRhLFxuICByZW1vdmVEYXRhLFxuICBpc0VtcHR5LFxuICBoYXNDbGFzcyxcbiAgYWRkQ2xhc3MsXG4gIHJlbW92ZUNsYXNzLFxuICBURVNUX1ZJRCxcbiAgVVNFUl9BR0VOVCxcbiAgSVNfSVBIT05FLFxuICBJU19JUEFELFxuICBJU19JUE9ELFxuICBJU19JT1MsXG4gIElPU19WRVJTSU9OLFxuICBJU19BTkRST0lELFxuICBBTkRST0lEX1ZFUlNJT04sXG4gIElTX09MRF9BTkRST0lELFxuICBJU19GSVJFRk9YLFxuICBJU19JRTgsXG4gIElTX0NIUk9NRSxcbiAgVE9VQ0hfRU5BQkxFRCxcbiAgQkFDS0dST1VORF9TSVpFX1NVUFBPUlRFRCxcbiAgc2V0RWxlbWVudEF0dHJpYnV0ZXMsXG4gIGdldEVsZW1lbnRBdHRyaWJ1dGVzLFxuICBnZXRDb21wdXRlZERpbWVuc2lvbixcbiAgaW5zZXJ0Rmlyc3QsXG4gIGJyb3dzZXIsXG4gIGVsLFxuICBmb3JtYXRUaW1lLFxuICBibG9ja1RleHRTZWxlY3Rpb24sXG4gIHVuYmxvY2tUZXh0U2VsZWN0aW9uLFxuICB0cmltLFxuICByb3VuZCxcbiAgY3JlYXRlVGltZVJhbmdlLFxuICBzZXRMb2NhbFN0b3JhZ2UsXG4gIGdldEFic29sdXRlVVJMLFxuICBwYXJzZVVybCxcbiAgbG9nLFxuICBmaW5kUG9zaXRpb24sXG4gIGFycixcbiAgZ2V0RmlsZUV4dGVuc2lvblxufTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuXG4vKiBMb2FkaW5nIFNwaW5uZXJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIExvYWRpbmcgc3Bpbm5lciBmb3Igd2FpdGluZyBldmVudHNcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIExvYWRpbmdTcGlubmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbG9hZGluZy1zcGlubmVyJ1xuICAgIH0pO1xuICB9XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTG9hZGluZ1NwaW5uZXInLCBMb2FkaW5nU3Bpbm5lcik7XG5leHBvcnQgZGVmYXVsdCBMb2FkaW5nU3Bpbm5lcjtcbiIsImltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYic7XG5cbi8qKlxuICogQ3VzdG9tIE1lZGlhRXJyb3IgdG8gbWltaWMgdGhlIEhUTUw1IE1lZGlhRXJyb3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBtZWRpYSBlcnJvciBjb2RlXG4gKi9cbmxldCBNZWRpYUVycm9yID0gZnVuY3Rpb24oY29kZSl7XG4gIGlmICh0eXBlb2YgY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykge1xuICAgIC8vIGRlZmF1bHQgY29kZSBpcyB6ZXJvLCBzbyB0aGlzIGlzIGEgY3VzdG9tIGVycm9yXG4gICAgdGhpcy5tZXNzYWdlID0gY29kZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSA9PT0gJ29iamVjdCcpIHsgLy8gb2JqZWN0XG4gICAgTGliLm9iai5tZXJnZSh0aGlzLCBjb2RlKTtcbiAgfVxuXG4gIGlmICghdGhpcy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gTWVkaWFFcnJvci5kZWZhdWx0TWVzc2FnZXNbdGhpcy5jb2RlXSB8fCAnJztcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgZXJyb3IgY29kZSB0aGF0IHJlZmVycyB0d28gb25lIG9mIHRoZSBkZWZpbmVkXG4gKiBNZWRpYUVycm9yIHR5cGVzXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5jb2RlID0gMDtcblxuLyoqXG4gKiBBbiBvcHRpb25hbCBtZXNzYWdlIHRvIGJlIHNob3duIHdpdGggdGhlIGVycm9yLlxuICogTWVzc2FnZSBpcyBub3QgcGFydCBvZiB0aGUgSFRNTDUgdmlkZW8gc3BlY1xuICogYnV0IGFsbG93cyBmb3IgbW9yZSBpbmZvcm1hdGl2ZSBjdXN0b20gZXJyb3JzLlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuTWVkaWFFcnJvci5wcm90b3R5cGUubWVzc2FnZSA9ICcnO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIHN0YXR1cyBjb2RlIHRoYXQgY2FuIGJlIHNldCBieSBwbHVnaW5zXG4gKiB0byBhbGxvdyBldmVuIG1vcmUgZGV0YWlsIGFib3V0IHRoZSBlcnJvci5cbiAqIEZvciBleGFtcGxlIHRoZSBITFMgcGx1Z2luIG1pZ2h0IHByb3ZpZGUgdGhlIHNwZWNpZmljXG4gKiBIVFRQIHN0YXR1cyBjb2RlIHRoYXQgd2FzIHJldHVybmVkIHdoZW4gdGhlIGVycm9yXG4gKiBvY2N1cnJlZCwgdGhlbiBhbGxvd2luZyBhIGN1c3RvbSBlcnJvciBvdmVybGF5XG4gKiB0byBkaXNwbGF5IG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAdHlwZSB7W3R5cGVdfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5zdGF0dXMgPSBudWxsO1xuXG5NZWRpYUVycm9yLmVycm9yVHlwZXMgPSBbXG4gICdNRURJQV9FUlJfQ1VTVE9NJywgICAgICAgICAgICAvLyA9IDBcbiAgJ01FRElBX0VSUl9BQk9SVEVEJywgICAgICAgICAgIC8vID0gMVxuICAnTUVESUFfRVJSX05FVFdPUksnLCAgICAgICAgICAgLy8gPSAyXG4gICdNRURJQV9FUlJfREVDT0RFJywgICAgICAgICAgICAvLyA9IDNcbiAgJ01FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRCcsIC8vID0gNFxuICAnTUVESUFfRVJSX0VOQ1JZUFRFRCcgICAgICAgICAgLy8gPSA1XG5dO1xuXG5NZWRpYUVycm9yLmRlZmF1bHRNZXNzYWdlcyA9IHtcbiAgMTogJ1lvdSBhYm9ydGVkIHRoZSB2aWRlbyBwbGF5YmFjaycsXG4gIDI6ICdBIG5ldHdvcmsgZXJyb3IgY2F1c2VkIHRoZSB2aWRlbyBkb3dubG9hZCB0byBmYWlsIHBhcnQtd2F5LicsXG4gIDM6ICdUaGUgdmlkZW8gcGxheWJhY2sgd2FzIGFib3J0ZWQgZHVlIHRvIGEgY29ycnVwdGlvbiBwcm9ibGVtIG9yIGJlY2F1c2UgdGhlIHZpZGVvIHVzZWQgZmVhdHVyZXMgeW91ciBicm93c2VyIGRpZCBub3Qgc3VwcG9ydC4nLFxuICA0OiAnVGhlIHZpZGVvIGNvdWxkIG5vdCBiZSBsb2FkZWQsIGVpdGhlciBiZWNhdXNlIHRoZSBzZXJ2ZXIgb3IgbmV0d29yayBmYWlsZWQgb3IgYmVjYXVzZSB0aGUgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQuJyxcbiAgNTogJ1RoZSB2aWRlbyBpcyBlbmNyeXB0ZWQgYW5kIHdlIGRvIG5vdCBoYXZlIHRoZSBrZXlzIHRvIGRlY3J5cHQgaXQuJ1xufTtcblxuLy8gQWRkIHR5cGVzIGFzIHByb3BlcnRpZXMgb24gTWVkaWFFcnJvclxuLy8gZS5nLiBNZWRpYUVycm9yLk1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRCA9IDQ7XG5mb3IgKHZhciBlcnJOdW0gPSAwOyBlcnJOdW0gPCBNZWRpYUVycm9yLmVycm9yVHlwZXMubGVuZ3RoOyBlcnJOdW0rKykge1xuICBNZWRpYUVycm9yW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbiAgLy8gdmFsdWVzIHNob3VsZCBiZSBhY2Nlc3NpYmxlIG9uIGJvdGggdGhlIGNsYXNzIGFuZCBpbnN0YW5jZVxuICBNZWRpYUVycm9yLnByb3RvdHlwZVtNZWRpYUVycm9yLmVycm9yVHlwZXNbZXJyTnVtXV0gPSBlcnJOdW07XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lZGlhRXJyb3I7XG4iLCJpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbi5qcyc7XG5pbXBvcnQgTWVudSBmcm9tICcuL21lbnUuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYi5qcyc7XG5cbi8qKlxuICogQSBidXR0b24gY2xhc3Mgd2l0aCBhIHBvcHVwIG1lbnVcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBNZW51QnV0dG9uIGV4dGVuZHMgQnV0dG9uIHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpe1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdGhpcy5vbigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBsZXQgbWVudSA9IHRoaXMuY3JlYXRlTWVudSgpO1xuXG4gICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLm1lbnUpO1xuICAgIH1cblxuICAgIHRoaXMubWVudSA9IG1lbnU7XG4gICAgdGhpcy5hZGRDaGlsZChtZW51KTtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrIHRoZSBzdGF0ZSBvZiB0aGUgbWVudSBidXR0b25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVNZW51KCkge1xuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXJfKTtcblxuICAgIC8vIEFkZCBhIHRpdGxlIGxpc3QgaXRlbSB0byB0aGUgdG9wXG4gICAgaWYgKHRoaXMub3B0aW9ucygpLnRpdGxlKSB7XG4gICAgICBtZW51LmNvbnRlbnRFbCgpLmFwcGVuZENoaWxkKExpYi5jcmVhdGVFbCgnbGknLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LXRpdGxlJyxcbiAgICAgICAgaW5uZXJIVE1MOiBMaWIuY2FwaXRhbGl6ZSh0aGlzLm9wdGlvbnMoKS50aXRsZSksXG4gICAgICAgIHRhYmluZGV4OiAtMVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHRoaXMuaXRlbXMgPSB0aGlzWydjcmVhdGVJdGVtcyddKCk7XG5cbiAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgLy8gQWRkIG1lbnUgaXRlbXMgdG8gdGhlIG1lbnVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZW51LmFkZEl0ZW0odGhpcy5pdGVtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBsaXN0IG9mIG1lbnUgaXRlbXMuIFNwZWNpZmljIHRvIGVhY2ggc3ViY2xhc3MuXG4gICAqL1xuICBjcmVhdGVJdGVtcygpe31cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jbGFzc05hbWV9IHZqcy1tZW51LWJ1dHRvbiAke3N1cGVyLmJ1aWxkQ1NTQ2xhc3MoKX1gO1xuICB9XG5cbiAgLy8gRm9jdXMgLSBBZGQga2V5Ym9hcmQgZnVuY3Rpb25hbGl0eSB0byBlbGVtZW50XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IG5lZWRlZCBhbnltb3JlLiBJbnN0ZWFkLCB0aGUga2V5Ym9hcmQgZnVuY3Rpb25hbGl0eSBpcyBoYW5kbGVkIGJ5XG4gIC8vIHRyZWF0aW5nIHRoZSBidXR0b24gYXMgdHJpZ2dlcmluZyBhIHN1Ym1lbnUuIFdoZW4gdGhlIGJ1dHRvbiBpcyBwcmVzc2VkLCB0aGUgc3VibWVudVxuICAvLyBhcHBlYXJzLiBQcmVzc2luZyB0aGUgYnV0dG9uIGFnYWluIG1ha2VzIHRoZSBzdWJtZW51IGRpc2FwcGVhci5cbiAgaGFuZGxlRm9jdXMoKSB7fVxuXG4gIC8vIENhbid0IHR1cm4gb2ZmIGxpc3QgZGlzcGxheSB0aGF0IHdlIHR1cm5lZCBvbiB3aXRoIGZvY3VzLCBiZWNhdXNlIGxpc3Qgd291bGQgZ28gYXdheS5cbiAgaGFuZGxlQmx1cigpIHt9XG5cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgLy8gV2hlbiB5b3UgY2xpY2sgdGhlIGJ1dHRvbiBpdCBhZGRzIGZvY3VzLCB3aGljaCB3aWxsIHNob3cgdGhlIG1lbnUgaW5kZWZpbml0ZWx5LlxuICAgIC8vIFNvIHdlJ2xsIHJlbW92ZSBmb2N1cyB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGJ1dHRvbi5cbiAgICAvLyBGb2N1cyBpcyBuZWVkZWQgZm9yIHRhYiBuYXZpZ2F0aW9uLlxuICAgIHRoaXMub25lKCdtb3VzZW91dCcsIExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLm1lbnUudW5sb2NrU2hvd2luZygpO1xuICAgICAgdGhpcy5lbF8uYmx1cigpO1xuICAgIH0pKTtcbiAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXyl7XG4gICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVzc0J1dHRvbigpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBDaGVjayBmb3Igc3BhY2UgYmFyICgzMikgb3IgZW50ZXIgKDEzKSBrZXlzXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzMiB8fCBldmVudC53aGljaCA9PT0gMTMpIHtcbiAgICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKXtcbiAgICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXNzQnV0dG9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIENoZWNrIGZvciBlc2NhcGUgKDI3KSBrZXlcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAyNyl7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXyl7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBwcmVzc0J1dHRvbigpIHtcbiAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gdHJ1ZTtcbiAgICB0aGlzLm1lbnUubG9ja1Nob3dpbmcoKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRydWUpO1xuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5pdGVtc1swXS5lbCgpLmZvY3VzKCk7IC8vIHNldCB0aGUgZm9jdXMgdG8gdGhlIHRpdGxlIG9mIHRoZSBzdWJtZW51XG4gICAgfVxuICB9XG5cbiAgdW5wcmVzc0J1dHRvbigpIHtcbiAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gZmFsc2U7XG4gICAgdGhpcy5tZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIGZhbHNlKTtcbiAgfVxufVxuXG5CdXR0b24ucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVCdXR0b24nLCBNZW51QnV0dG9uKTtcbmV4cG9ydCBkZWZhdWx0IE1lbnVCdXR0b247XG4iLCJpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbi5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBhIG1lbnUgaXRlbS4gYDxsaT5gXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTWVudUl0ZW0gZXh0ZW5kcyBCdXR0b24ge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucykge1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5zZWxlY3RlZChvcHRpb25zWydzZWxlY3RlZCddKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBjcmVhdGVFbCh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnbGknLCBMaWIub2JqLm1lcmdlKHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LWl0ZW0nLFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc19bJ2xhYmVsJ10pXG4gICAgfSwgcHJvcHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBjbGljayBvbiB0aGUgbWVudSBpdGVtLCBhbmQgc2V0IGl0IHRvIHNlbGVjdGVkXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIG1lbnUgaXRlbSBhcyBzZWxlY3RlZCBvciBub3RcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gc2VsZWN0ZWRcbiAgICovXG4gIHNlbGVjdGVkKHNlbGVjdGVkKSB7XG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2VsZWN0ZWQnKTtcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWxlY3RlZCcpO1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJyxmYWxzZSk7XG4gICAgfVxuICB9XG5cbn1cblxuQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51SXRlbScsIE1lbnVJdGVtKTtcbmV4cG9ydCBkZWZhdWx0IE1lbnVJdGVtO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYi5qcyc7XG5pbXBvcnQgKiBhcyBFdmVudHMgZnJvbSAnLi4vZXZlbnRzLmpzJztcblxuLyogTWVudVxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogVGhlIE1lbnUgY29tcG9uZW50IGlzIHVzZWQgdG8gYnVpbGQgcG9wIHVwIG1lbnVzLCBpbmNsdWRpbmcgc3VidGl0bGUgYW5kXG4gKiBjYXB0aW9ucyBzZWxlY3Rpb24gbWVudXMuXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgTWVudSBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1lbnUgaXRlbSB0byB0aGUgbWVudVxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGNvbXBvbmVudCBDb21wb25lbnQgb3IgY29tcG9uZW50IHR5cGUgdG8gYWRkXG4gICAqL1xuICBhZGRJdGVtKGNvbXBvbmVudCkge1xuICAgIHRoaXMuYWRkQ2hpbGQoY29tcG9uZW50KTtcbiAgICBjb21wb25lbnQub24oJ2NsaWNrJywgTGliLmJpbmQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMudW5sb2NrU2hvd2luZygpO1xuICAgIH0pKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIGxldCBjb250ZW50RWxUeXBlID0gdGhpcy5vcHRpb25zKCkuY29udGVudEVsVHlwZSB8fCAndWwnO1xuICAgIHRoaXMuY29udGVudEVsXyA9IExpYi5jcmVhdGVFbChjb250ZW50RWxUeXBlLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1jb250ZW50J1xuICAgIH0pO1xuICAgIHZhciBlbCA9IHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBhcHBlbmQ6IHRoaXMuY29udGVudEVsXyxcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51J1xuICAgIH0pO1xuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG5cbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBmcm9tIGJ1YmJsaW5nIHVwLiBOZWVkZWQgZm9yIE1lbnUgQnV0dG9ucyxcbiAgICAvLyB3aGVyZSBhIGNsaWNrIG9uIHRoZSBwYXJlbnQgaXMgc2lnbmlmaWNhbnRcbiAgICBFdmVudHMub24oZWwsICdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbDtcbiAgfVxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lbnUnLCBNZW51KTtcbmV4cG9ydCBkZWZhdWx0IE1lbnU7XG4iLCJpbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5sZXQgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcblxuLyoqXG4gKiBHbG9iYWwgUGxheWVyIGluc3RhbmNlIG9wdGlvbnMsIHN1cmZhY2VkIGZyb20gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zX1xuICogb3B0aW9ucyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc19cbiAqIEFsbCBvcHRpb25zIHNob3VsZCB1c2Ugc3RyaW5nIGtleXMgc28gdGhleSBhdm9pZFxuICogcmVuYW1pbmcgYnkgY2xvc3VyZSBjb21waWxlclxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvLyBEZWZhdWx0IG9yZGVyIG9mIGZhbGxiYWNrIHRlY2hub2xvZ3lcbiAgJ3RlY2hPcmRlcic6IFsnaHRtbDUnLCdmbGFzaCddLFxuICAvLyB0ZWNoT3JkZXI6IFsnZmxhc2gnLCdodG1sNSddLFxuXG4gICdodG1sNSc6IHt9LFxuICAnZmxhc2gnOiB7fSxcblxuICAvLyBEZWZhdWx0IG9mIHdlYiBicm93c2VyIGlzIDMwMHgxNTAuIFNob3VsZCByZWx5IG9uIHNvdXJjZSB3aWR0aC9oZWlnaHQuXG4gICd3aWR0aCc6IDMwMCxcbiAgJ2hlaWdodCc6IDE1MCxcbiAgLy8gZGVmYXVsdFZvbHVtZTogMC44NSxcbiAgJ2RlZmF1bHRWb2x1bWUnOiAwLjAwLCAvLyBUaGUgZnJlYWtpbiBzZWFndWxzIGFyZSBkcml2aW5nIG1lIGNyYXp5IVxuXG4gIC8vIGRlZmF1bHQgaW5hY3Rpdml0eSB0aW1lb3V0XG4gICdpbmFjdGl2aXR5VGltZW91dCc6IDIwMDAsXG5cbiAgLy8gZGVmYXVsdCBwbGF5YmFjayByYXRlc1xuICAncGxheWJhY2tSYXRlcyc6IFtdLFxuICAvLyBBZGQgcGxheWJhY2sgcmF0ZSBzZWxlY3Rpb24gYnkgYWRkaW5nIHJhdGVzXG4gIC8vICdwbGF5YmFja1JhdGVzJzogWzAuNSwgMSwgMS41LCAyXSxcblxuICAvLyBJbmNsdWRlZCBjb250cm9sIHNldHNcbiAgJ2NoaWxkcmVuJzoge1xuICAgICdtZWRpYUxvYWRlcic6IHt9LFxuICAgICdwb3N0ZXJJbWFnZSc6IHt9LFxuICAgICd0ZXh0VHJhY2tEaXNwbGF5Jzoge30sXG4gICAgJ2xvYWRpbmdTcGlubmVyJzoge30sXG4gICAgJ2JpZ1BsYXlCdXR0b24nOiB7fSxcbiAgICAnY29udHJvbEJhcic6IHt9LFxuICAgICdlcnJvckRpc3BsYXknOiB7fSxcbiAgICAndGV4dFRyYWNrU2V0dGluZ3MnOiB7fVxuICB9LFxuXG4gICdsYW5ndWFnZSc6IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0uZ2V0QXR0cmlidXRlKCdsYW5nJykgfHwgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLmxhbmd1YWdlIHx8ICdlbicsXG5cbiAgLy8gbG9jYWxlcyBhbmQgdGhlaXIgbGFuZ3VhZ2UgdHJhbnNsYXRpb25zXG4gICdsYW5ndWFnZXMnOiB7fSxcblxuICAvLyBEZWZhdWx0IG1lc3NhZ2UgdG8gc2hvdyB3aGVuIGEgdmlkZW8gY2Fubm90IGJlIHBsYXllZC5cbiAgJ25vdFN1cHBvcnRlZE1lc3NhZ2UnOiAnTm8gY29tcGF0aWJsZSBzb3VyY2Ugd2FzIGZvdW5kIGZvciB0aGlzIHZpZGVvLidcbn07XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYi5qcyc7XG5pbXBvcnQgKiBhcyBFdmVudHMgZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IEZ1bGxzY3JlZW5BcGkgZnJvbSAnLi9mdWxsc2NyZWVuLWFwaS5qcyc7XG5pbXBvcnQgTWVkaWFFcnJvciBmcm9tICcuL21lZGlhLWVycm9yLmpzJztcbmltcG9ydCBPcHRpb25zIGZyb20gJy4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgc2FmZVBhcnNlVHVwbGUgZnJvbSAnc2FmZS1qc29uLXBhcnNlL3R1cGxlJztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLy8gSW5jbHVkZSByZXF1aXJlZCBjaGlsZCBjb21wb25lbnRzXG5pbXBvcnQgTWVkaWFMb2FkZXIgZnJvbSAnLi90ZWNoL2xvYWRlci5qcyc7XG5pbXBvcnQgUG9zdGVyIGZyb20gJy4vcG9zdGVyLWltYWdlLmpzJztcbmltcG9ydCBUZXh0VHJhY2tEaXNwbGF5IGZyb20gJy4vdHJhY2tzL3RleHQtdHJhY2stZGlzcGxheS5qcyc7XG5pbXBvcnQgTG9hZGluZ1NwaW5uZXIgZnJvbSAnLi9sb2FkaW5nLXNwaW5uZXIuanMnO1xuaW1wb3J0IEJpZ1BsYXlCdXR0b24gZnJvbSAnLi9iaWctcGxheS1idXR0b24uanMnO1xuaW1wb3J0IGNvbnRyb2xCYXIgZnJvbSAnLi9jb250cm9sLWJhci9jb250cm9sLWJhci5qcyc7XG5pbXBvcnQgRXJyb3JEaXNwbGF5IGZyb20gJy4vZXJyb3ItZGlzcGxheS5qcyc7XG5pbXBvcnQgVGV4dFRyYWNrU2V0dGluZ3MgZnJvbSAnLi90cmFja3MvdGV4dC10cmFjay1zZXR0aW5ncy5qcyc7XG4vLyBSZXF1aXJlIGh0bWw1IGZvciBkaXNwb3NpbmcgdGhlIG9yaWdpbmFsIHZpZGVvIHRhZ1xuaW1wb3J0IEh0bWw1IGZyb20gJy4vdGVjaC9odG1sNS5qcyc7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIGBQbGF5ZXJgIGNsYXNzIGlzIGNyZWF0ZWQgd2hlbiBhbnkgb2YgdGhlIFZpZGVvLmpzIHNldHVwIG1ldGhvZHMgYXJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBhIHZpZGVvLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbXlQbGF5ZXIgPSB2aWRlb2pzKCdleGFtcGxlX3ZpZGVvXzEnKTtcbiAqIGBgYFxuICpcbiAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgdGhlIGBkYXRhLXNldHVwYCBhdHRyaWJ1dGUgdGVsbHMgdGhlIFZpZGVvLmpzIGxpYnJhcnkgdG8gY3JlYXRlIGEgcGxheWVyIGluc3RhbmNlIHdoZW4gdGhlIGxpYnJhcnkgaXMgcmVhZHkuXG4gKlxuICogYGBgaHRtbFxuICogPHZpZGVvIGlkPVwiZXhhbXBsZV92aWRlb18xXCIgZGF0YS1zZXR1cD0ne30nIGNvbnRyb2xzPlxuICogICA8c291cmNlIHNyYz1cIm15LXNvdXJjZS5tcDRcIiB0eXBlPVwidmlkZW8vbXA0XCI+XG4gKiA8L3ZpZGVvPlxuICogYGBgXG4gKlxuICogQWZ0ZXIgYW4gaW5zdGFuY2UgaGFzIGJlZW4gY3JlYXRlZCBpdCBjYW4gYmUgYWNjZXNzZWQgZ2xvYmFsbHkgdXNpbmcgYFZpZGVvKCdleGFtcGxlX3ZpZGVvXzEnKWAuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuY2xhc3MgUGxheWVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogcGxheWVyJ3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICpcbiAgICogQGNvbnN0cnVjdHNcbiAgICogQG1ldGhvZCBpbml0XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnICAgICAgICBUaGUgb3JpZ2luYWwgdmlkZW8gdGFnIHVzZWQgZm9yIGNvbmZpZ3VyaW5nIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zICAgIFBsYXllciBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSByZWFkeSAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IodGFnLCBvcHRpb25zLCByZWFkeSl7XG4gICAgLy8gTWFrZSBzdXJlIHRhZyBJRCBleGlzdHNcbiAgICB0YWcuaWQgPSB0YWcuaWQgfHwgYHZqc192aWRlb18ke0xpYi5ndWlkKyt9YDtcblxuICAgIC8vIFNldCBPcHRpb25zXG4gICAgLy8gVGhlIG9wdGlvbnMgYXJndW1lbnQgb3ZlcnJpZGVzIG9wdGlvbnMgc2V0IGluIHRoZSB2aWRlbyB0YWdcbiAgICAvLyB3aGljaCBvdmVycmlkZXMgZ2xvYmFsbHkgc2V0IG9wdGlvbnMuXG4gICAgLy8gVGhpcyBsYXR0ZXIgcGFydCBjb2luY2lkZXMgd2l0aCB0aGUgbG9hZCBvcmRlclxuICAgIC8vICh0YWcgbXVzdCBleGlzdCBiZWZvcmUgUGxheWVyKVxuICAgIG9wdGlvbnMgPSBMaWIub2JqLm1lcmdlKFBsYXllci5nZXRUYWdTZXR0aW5ncyh0YWcpLCBvcHRpb25zKTtcblxuICAgIC8vIERlbGF5IHRoZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZHJlbiBiZWNhdXNlIHdlIG5lZWQgdG8gc2V0IHVwXG4gICAgLy8gcGxheWVyIHByb3BlcnRpZXMgZmlyc3QsIGFuZCBjYW4ndCB1c2UgYHRoaXNgIGJlZm9yZSBgc3VwZXIoKWBcbiAgICBvcHRpb25zLmluaXRDaGlsZHJlbiA9IGZhbHNlO1xuXG4gICAgLy8gU2FtZSB3aXRoIGNyZWF0aW5nIHRoZSBlbGVtZW50XG4gICAgb3B0aW9ucy5jcmVhdGVFbCA9IGZhbHNlO1xuXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgcGxheWVyIHRvIHJlcG9ydCB0b3VjaCBhY3Rpdml0eSBvbiBpdHNlbGZcbiAgICAvLyBzZWUgZW5hYmxlVG91Y2hBY3Rpdml0eSBpbiBDb21wb25lbnRcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcblxuICAgIC8vIFJ1biBiYXNlIGNvbXBvbmVudCBpbml0aWFsaXppbmcgd2l0aCBuZXcgb3B0aW9uc1xuICAgIHN1cGVyKG51bGwsIG9wdGlvbnMsIHJlYWR5KTtcblxuXG4gICAgLy8gaWYgdGhlIGdsb2JhbCBvcHRpb24gb2JqZWN0IHdhcyBhY2NpZGVudGFsbHkgYmxvd24gYXdheSBieVxuICAgIC8vIHNvbWVvbmUsIGJhaWwgZWFybHkgd2l0aCBhbiBpbmZvcm1hdGl2ZSBlcnJvclxuICAgIGlmICghdGhpcy5vcHRpb25zXyB8fFxuICAgICAgICAhdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIgfHxcbiAgICAgICAgIXRoaXMub3B0aW9uc18udGVjaE9yZGVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0ZWNoT3JkZXIgc3BlY2lmaWVkLiBEaWQgeW91IG92ZXJ3cml0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAndmlkZW9qcy5vcHRpb25zIGluc3RlYWQgb2YganVzdCBjaGFuZ2luZyB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnRpZXMgeW91IHdhbnQgdG8gb3ZlcnJpZGU/Jyk7XG4gICAgfVxuXG4gICAgdGhpcy50YWcgPSB0YWc7IC8vIFN0b3JlIHRoZSBvcmlnaW5hbCB0YWcgdXNlZCB0byBzZXQgb3B0aW9uc1xuXG4gICAgLy8gU3RvcmUgdGhlIHRhZyBhdHRyaWJ1dGVzIHVzZWQgdG8gcmVzdG9yZSBodG1sNSBlbGVtZW50XG4gICAgdGhpcy50YWdBdHRyaWJ1dGVzID0gdGFnICYmIExpYi5nZXRFbGVtZW50QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgLy8gVXBkYXRlIEN1cnJlbnQgTGFuZ3VhZ2VcbiAgICB0aGlzLmxhbmd1YWdlXyA9IG9wdGlvbnNbJ2xhbmd1YWdlJ10gfHwgT3B0aW9uc1snbGFuZ3VhZ2UnXTtcblxuICAgIC8vIFVwZGF0ZSBTdXBwb3J0ZWQgTGFuZ3VhZ2VzXG4gICAgdGhpcy5sYW5ndWFnZXNfID0gb3B0aW9uc1snbGFuZ3VhZ2VzJ10gfHwgT3B0aW9uc1snbGFuZ3VhZ2VzJ107XG5cbiAgICAvLyBDYWNoZSBmb3IgdmlkZW8gcHJvcGVydHkgdmFsdWVzLlxuICAgIHRoaXMuY2FjaGVfID0ge307XG5cbiAgICAvLyBTZXQgcG9zdGVyXG4gICAgdGhpcy5wb3N0ZXJfID0gb3B0aW9uc1sncG9zdGVyJ10gfHwgJyc7XG5cbiAgICAvLyBTZXQgY29udHJvbHNcbiAgICB0aGlzLmNvbnRyb2xzXyA9ICEhb3B0aW9uc1snY29udHJvbHMnXTtcbiAgICAvLyBPcmlnaW5hbCB0YWcgc2V0dGluZ3Mgc3RvcmVkIGluIG9wdGlvbnNcbiAgICAvLyBub3cgcmVtb3ZlIGltbWVkaWF0ZWx5IHNvIG5hdGl2ZSBjb250cm9scyBkb24ndCBmbGFzaC5cbiAgICAvLyBNYXkgYmUgdHVybmVkIGJhY2sgb24gYnkgSFRNTDUgdGVjaCBpZiBuYXRpdmVDb250cm9sc0ZvclRvdWNoIGlzIHRydWVcbiAgICB0YWcuY29udHJvbHMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICogU3RvcmUgdGhlIGludGVybmFsIHN0YXRlIG9mIHNjcnViYmluZ1xuICAgICogQHByaXZhdGVcbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHVzZXIgaXMgc2NydWJiaW5nXG4gICAgKi9cbiAgICB0aGlzLnNjcnViYmluZ18gPSBmYWxzZTtcblxuICAgIHRoaXMuZWxfID0gdGhpcy5jcmVhdGVFbCgpO1xuXG4gICAgLy8gTG9hZCBwbHVnaW5zXG4gICAgaWYgKG9wdGlvbnNbJ3BsdWdpbnMnXSkge1xuICAgICAgTGliLm9iai5lYWNoKG9wdGlvbnNbJ3BsdWdpbnMnXSwgZnVuY3Rpb24oa2V5LCB2YWwpe1xuICAgICAgICB0aGlzW2tleV0odmFsKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdENoaWxkcmVuKCk7XG5cbiAgICAvLyBTZXQgaXNBdWRpbyBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBhbiBhdWRpbyB0YWcgd2FzIHVzZWRcbiAgICB0aGlzLmlzQXVkaW8odGFnLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhdWRpbycpO1xuXG4gICAgLy8gVXBkYXRlIGNvbnRyb2xzIGNsYXNzTmFtZS4gQ2FuJ3QgZG8gdGhpcyB3aGVuIHRoZSBjb250cm9scyBhcmUgaW5pdGlhbGx5XG4gICAgLy8gc2V0IGJlY2F1c2UgdGhlIGVsZW1lbnQgZG9lc24ndCBleGlzdCB5ZXQuXG4gICAgaWYgKHRoaXMuY29udHJvbHMoKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNBdWRpbygpKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtYXVkaW8nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mbGV4Tm90U3VwcG9ydGVkXygpKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtbm8tZmxleCcpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBzbWFydGVyLiBUb2dnbGUgdXNlciBzdGF0ZSBiZXR3ZWVuIHRvdWNoaW5nL21vdXNpbmdcbiAgICAvLyB1c2luZyBldmVudHMsIHNpbmNlIGRldmljZXMgY2FuIGhhdmUgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzLlxuICAgIC8vIGlmIChMaWIuVE9VQ0hfRU5BQkxFRCkge1xuICAgIC8vICAgdGhpcy5hZGRDbGFzcygndmpzLXRvdWNoLWVuYWJsZWQnKTtcbiAgICAvLyB9XG5cbiAgICAvLyBNYWtlIHBsYXllciBlYXNpbHkgZmluZGFibGUgYnkgSURcbiAgICBQbGF5ZXIucGxheWVyc1t0aGlzLmlkX10gPSB0aGlzO1xuXG4gICAgLy8gV2hlbiB0aGUgcGxheWVyIGlzIGZpcnN0IGluaXRpYWxpemVkLCB0cmlnZ2VyIGFjdGl2aXR5IHNvIGNvbXBvbmVudHNcbiAgICAvLyBsaWtlIHRoZSBjb250cm9sIGJhciBzaG93IHRoZW1zZWx2ZXMgaWYgbmVlZGVkXG4gICAgdGhpcy51c2VyQWN0aXZlXyA9IHRydWU7XG4gICAgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcbiAgICB0aGlzLmxpc3RlbkZvclVzZXJBY3Rpdml0eSgpO1xuXG4gICAgdGhpcy5vbignZnVsbHNjcmVlbmNoYW5nZScsIHRoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgdGhpcy5vbignc3RhZ2VjbGljaycsIHRoaXMuaGFuZGxlU3RhZ2VDbGljayk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIHZpZGVvIHBsYXllciBhbmQgZG9lcyBhbnkgbmVjZXNzYXJ5IGNsZWFudXBcbiAgICpcbiAgICogICAgIG15UGxheWVyLmRpc3Bvc2UoKTtcbiAgICpcbiAgICogVGhpcyBpcyBlc3BlY2lhbGx5IGhlbHBmdWwgaWYgeW91IGFyZSBkeW5hbWljYWxseSBhZGRpbmcgYW5kIHJlbW92aW5nIHZpZGVvc1xuICAgKiB0by9mcm9tIHRoZSBET00uXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMudHJpZ2dlcignZGlzcG9zZScpO1xuICAgIC8vIHByZXZlbnQgZGlzcG9zZSBmcm9tIGJlaW5nIGNhbGxlZCB0d2ljZVxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJyk7XG5cbiAgICAvLyBLaWxsIHJlZmVyZW5jZSB0byB0aGlzIHBsYXllclxuICAgIFBsYXllci5wbGF5ZXJzW3RoaXMuaWRfXSA9IG51bGw7XG4gICAgaWYgKHRoaXMudGFnICYmIHRoaXMudGFnWydwbGF5ZXInXSkgeyB0aGlzLnRhZ1sncGxheWVyJ10gPSBudWxsOyB9XG4gICAgaWYgKHRoaXMuZWxfICYmIHRoaXMuZWxfWydwbGF5ZXInXSkgeyB0aGlzLmVsX1sncGxheWVyJ10gPSBudWxsOyB9XG5cbiAgICBpZiAodGhpcy50ZWNoKSB7IHRoaXMudGVjaC5kaXNwb3NlKCk7IH1cblxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIGxldCBlbCA9IHRoaXMuZWxfID0gc3VwZXIuY3JlYXRlRWwoJ2RpdicpO1xuICAgIGxldCB0YWcgPSB0aGlzLnRhZztcblxuICAgIC8vIFJlbW92ZSB3aWR0aC9oZWlnaHQgYXR0cnMgZnJvbSB0YWcgc28gQ1NTIGNhbiBtYWtlIGl0IDEwMCUgd2lkdGgvaGVpZ2h0XG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcblxuICAgIC8vIENvcHkgb3ZlciBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGFnLCBpbmNsdWRpbmcgSUQgYW5kIGNsYXNzXG4gICAgLy8gSUQgd2lsbCBub3cgcmVmZXJlbmNlIHBsYXllciBib3gsIG5vdCB0aGUgdmlkZW8gdGFnXG4gICAgY29uc3QgYXR0cnMgPSBMaWIuZ2V0RWxlbWVudEF0dHJpYnV0ZXModGFnKTtcbiAgICBMaWIub2JqLmVhY2goYXR0cnMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgc28gd2UgZG9uJ3QgdG90YWxseSBicmVhayBJRTdcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzY1MzQ0NC9jc3Mtc3R5bGVzLW5vdC1hcHBsaWVkLW9uLWR5bmFtaWMtZWxlbWVudHMtaW4taW50ZXJuZXQtZXhwbG9yZXItN1xuICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gYXR0cnNbYXR0cl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHRhZyBpZC9jbGFzcyBmb3IgdXNlIGFzIEhUTUw1IHBsYXliYWNrIHRlY2hcbiAgICAvLyBNaWdodCB0aGluayB3ZSBzaG91bGQgZG8gdGhpcyBhZnRlciBlbWJlZGRpbmcgaW4gY29udGFpbmVyIHNvIC52anMtdGVjaCBjbGFzc1xuICAgIC8vIGRvZXNuJ3QgZmxhc2ggMTAwJSB3aWR0aC9oZWlnaHQsIGJ1dCBjbGFzcyBvbmx5IGFwcGxpZXMgd2l0aCAudmlkZW8tanMgcGFyZW50XG4gICAgdGFnLmlkICs9ICdfaHRtbDVfYXBpJztcbiAgICB0YWcuY2xhc3NOYW1lID0gJ3Zqcy10ZWNoJztcblxuICAgIC8vIE1ha2UgcGxheWVyIGZpbmRhYmxlIG9uIGVsZW1lbnRzXG4gICAgdGFnWydwbGF5ZXInXSA9IGVsWydwbGF5ZXInXSA9IHRoaXM7XG4gICAgLy8gRGVmYXVsdCBzdGF0ZSBvZiB2aWRlbyBpcyBwYXVzZWRcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGF1c2VkJyk7XG5cbiAgICAvLyBNYWtlIGJveCB1c2Ugd2lkdGgvaGVpZ2h0IG9mIHRhZywgb3IgcmVseSBvbiBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgLy8gRW5mb3JjZSB3aXRoIENTUyBzaW5jZSB3aWR0aC9oZWlnaHQgYXR0cnMgZG9uJ3Qgd29yayBvbiBkaXZzXG4gICAgdGhpcy53aWR0aCh0aGlzLm9wdGlvbnNfWyd3aWR0aCddLCB0cnVlKTsgLy8gKHRydWUpIFNraXAgcmVzaXplIGxpc3RlbmVyIG9uIGxvYWRcbiAgICB0aGlzLmhlaWdodCh0aGlzLm9wdGlvbnNfWydoZWlnaHQnXSwgdHJ1ZSk7XG5cbiAgICAvLyBMaWIuaW5zZXJ0Rmlyc3Qgc2VlbXMgdG8gY2F1c2UgdGhlIG5ldHdvcmtTdGF0ZSB0byBmbGlja2VyIGZyb20gMyB0byAyLCBzb1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIG9yaWdpbmFsIGZvciBsYXRlciBzbyB3ZSBjYW4ga25vdyBpZiB0aGUgc291cmNlIG9yaWdpbmFsbHkgZmFpbGVkXG4gICAgdGFnLmluaXROZXR3b3JrU3RhdGVfID0gdGFnLm5ldHdvcmtTdGF0ZTtcblxuICAgIC8vIFdyYXAgdmlkZW8gdGFnIGluIGRpdiAoZWwvYm94KSBjb250YWluZXJcbiAgICBpZiAodGFnLnBhcmVudE5vZGUpIHtcbiAgICAgIHRhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdGFnKTtcbiAgICB9XG4gICAgTGliLmluc2VydEZpcnN0KHRhZywgZWwpOyAvLyBCcmVha3MgaVBob25lLCBmaXhlZCBpbiBIVE1MNSBzZXR1cC5cblxuICAgIHRoaXMuZWxfID0gZWw7XG5cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCB0aGUgTWVkaWEgUGxheWJhY2sgVGVjaG5vbG9neSAodGVjaClcbiAgICogTG9hZC9DcmVhdGUgYW4gaW5zdGFuY2Ugb2YgcGxheWJhY2sgdGVjaG5vbG9neSBpbmNsdWRpbmcgZWxlbWVudCBhbmQgQVBJIG1ldGhvZHNcbiAgICogQW5kIGFwcGVuZCBwbGF5YmFjayBlbGVtZW50IGluIHBsYXllciBkaXYuXG4gICAqL1xuICBsb2FkVGVjaCh0ZWNoTmFtZSwgc291cmNlKSB7XG5cbiAgICAvLyBQYXVzZSBhbmQgcmVtb3ZlIGN1cnJlbnQgcGxheWJhY2sgdGVjaG5vbG9neVxuICAgIGlmICh0aGlzLnRlY2gpIHtcbiAgICAgIHRoaXMudW5sb2FkVGVjaCgpO1xuICAgIH1cblxuICAgIC8vIGdldCByaWQgb2YgdGhlIEhUTUw1IHZpZGVvIHRhZyBhcyBzb29uIGFzIHdlIGFyZSB1c2luZyBhbm90aGVyIHRlY2hcbiAgICBpZiAodGVjaE5hbWUgIT09ICdIdG1sNScgJiYgdGhpcy50YWcpIHtcbiAgICAgIENvbXBvbmVudC5nZXRDb21wb25lbnQoJ0h0bWw1JykuZGlzcG9zZU1lZGlhRWxlbWVudCh0aGlzLnRhZyk7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudGVjaE5hbWUgPSB0ZWNoTmFtZTtcblxuICAgIC8vIFR1cm4gb2ZmIEFQSSBhY2Nlc3MgYmVjYXVzZSB3ZSdyZSBsb2FkaW5nIGEgbmV3IHRlY2ggdGhhdCBtaWdodCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgdmFyIHRlY2hSZWFkeSA9IExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgICB9KTtcblxuICAgIC8vIEdyYWIgdGVjaC1zcGVjaWZpYyBvcHRpb25zIGZyb20gcGxheWVyIG9wdGlvbnMgYW5kIGFkZCBzb3VyY2UgYW5kIHBhcmVudCBlbGVtZW50IHRvIHVzZS5cbiAgICB2YXIgdGVjaE9wdGlvbnMgPSBMaWIub2JqLm1lcmdlKHtcbiAgICAgICdzb3VyY2UnOiBzb3VyY2UsXG4gICAgICAncGxheWVySWQnOiB0aGlzLmlkKCksXG4gICAgICAndGV4dFRyYWNrcyc6IHRoaXMudGV4dFRyYWNrc19cbiAgICB9LCB0aGlzLm9wdGlvbnNfW3RlY2hOYW1lLnRvTG93ZXJDYXNlKCldKTtcblxuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgdGVjaE9wdGlvbnMudGFnID0gdGhpcy50YWc7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5jdXJyZW50VHlwZV8gPSBzb3VyY2UudHlwZTtcbiAgICAgIGlmIChzb3VyY2Uuc3JjID09PSB0aGlzLmNhY2hlXy5zcmMgJiYgdGhpcy5jYWNoZV8uY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICAgIHRlY2hPcHRpb25zWydzdGFydFRpbWUnXSA9IHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhY2hlXy5zcmMgPSBzb3VyY2Uuc3JjO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGVjaCBpbnN0YW5jZVxuICAgIGxldCB0ZWNoQ29tcG9uZW50ID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XG4gICAgdGhpcy50ZWNoID0gbmV3IHRlY2hDb21wb25lbnQodGVjaE9wdGlvbnMpO1xuXG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdyZWFkeScsIHRoaXMuaGFuZGxlVGVjaFJlYWR5KTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3VzZW5hdGl2ZWNvbnRyb2xzJywgdGhpcy5oYW5kbGVUZWNoVXNlTmF0aXZlQ29udHJvbHMpO1xuXG4gICAgLy8gTGlzdGVuIHRvIGV2ZXJ5IEhUTUw1IGV2ZW50cyBhbmQgdHJpZ2dlciB0aGVtIGJhY2sgb24gdGhlIHBsYXllciBmb3IgdGhlIHBsdWdpbnNcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ2xvYWRzdGFydCcsIHRoaXMuaGFuZGxlVGVjaExvYWRTdGFydCk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICd3YWl0aW5nJywgdGhpcy5oYW5kbGVUZWNoV2FpdGluZyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdjYW5wbGF5JywgdGhpcy5oYW5kbGVUZWNoQ2FuUGxheSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3BsYXlpbmcnLCB0aGlzLmhhbmRsZVRlY2hQbGF5aW5nKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ2VuZGVkJywgdGhpcy5oYW5kbGVUZWNoRW5kZWQpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnc2Vla2luZycsIHRoaXMuaGFuZGxlVGVjaFNlZWtpbmcpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnc2Vla2VkJywgdGhpcy5oYW5kbGVUZWNoU2Vla2VkKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3BsYXknLCB0aGlzLmhhbmRsZVRlY2hQbGF5KTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ2ZpcnN0cGxheScsIHRoaXMuaGFuZGxlVGVjaEZpcnN0UGxheSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdwYXVzZScsIHRoaXMuaGFuZGxlVGVjaFBhdXNlKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3Byb2dyZXNzJywgdGhpcy5oYW5kbGVUZWNoUHJvZ3Jlc3MpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnZHVyYXRpb25jaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdlcnJvcicsIHRoaXMuaGFuZGxlVGVjaEVycm9yKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3N1c3BlbmQnLCB0aGlzLmhhbmRsZVRlY2hTdXNwZW5kKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ2Fib3J0JywgdGhpcy5oYW5kbGVUZWNoQWJvcnQpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnZW1wdGllZCcsIHRoaXMuaGFuZGxlVGVjaEVtcHRpZWQpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnc3RhbGxlZCcsIHRoaXMuaGFuZGxlVGVjaFN0YWxsZWQpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnbG9hZGVkbWV0YWRhdGEnLCB0aGlzLmhhbmRsZVRlY2hMb2FkZWRNZXRhRGF0YSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdtZXRhZGF0YXVwZGF0ZScsIHRoaXMuaGFuZGxlTWV0YURhdGFVcGRhdGUpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAnbG9hZGVkZGF0YScsIHRoaXMuaGFuZGxlVGVjaExvYWRlZERhdGEpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAndGltZXVwZGF0ZScsIHRoaXMuaGFuZGxlVGVjaFRpbWVVcGRhdGUpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAncmF0ZWNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaFJhdGVDaGFuZ2UpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAndm9sdW1lY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoVm9sdW1lQ2hhbmdlKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaCwgJ3RleHR0cmFja2NoYW5nZScsIHRoaXMub25UZXh0VHJhY2tDaGFuZ2UpO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbHMoKSAmJiAhdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSB0ZWNoIGVsZW1lbnQgaW4gdGhlIERPTSBpZiBpdCB3YXMgbm90IGFscmVhZHkgdGhlcmVcbiAgICAvLyBNYWtlIHN1cmUgdG8gbm90IGluc2VydCB0aGUgb3JpZ2luYWwgdmlkZW8gZWxlbWVudCBpZiB1c2luZyBIdG1sNVxuICAgIGlmICh0aGlzLnRlY2guZWwoKS5wYXJlbnROb2RlICE9PSB0aGlzLmVsKCkgJiYgKHRlY2hOYW1lICE9PSAnSHRtbDUnIHx8ICF0aGlzLnRhZykpIHtcbiAgICAgIExpYi5pbnNlcnRGaXJzdCh0aGlzLnRlY2guZWwoKSwgdGhpcy5lbCgpKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcmlkIG9mIHRoZSBvcmlnaW5hbCB2aWRlbyB0YWcgcmVmZXJlbmNlIGFmdGVyIHRoZSBmaXJzdCB0ZWNoIGlzIGxvYWRlZFxuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgdGhpcy50YWcucGxheWVyID0gbnVsbDtcbiAgICAgIHRoaXMudGFnID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnRlY2gucmVhZHkodGVjaFJlYWR5KTtcbiAgfVxuXG4gIHVubG9hZFRlY2goKSB7XG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCB0ZXh0IHRyYWNrcyBzbyB0aGF0IHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0ZXh0IHRyYWNrcyB3aXRoIHRoZSBuZXh0IHRlY2hcbiAgICB0aGlzLnRleHRUcmFja3NfID0gdGhpcy50ZXh0VHJhY2tzKCk7XG5cbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICB0aGlzLnRlY2guZGlzcG9zZSgpO1xuXG4gICAgdGhpcy50ZWNoID0gZmFsc2U7XG4gIH1cblxuICBhZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnMoKSB7XG4gICAgLy8gU29tZSBicm93c2VycyAoQ2hyb21lICYgSUUpIGRvbid0IHRyaWdnZXIgYSBjbGljayBvbiBhIGZsYXNoIHN3ZiwgYnV0IGRvXG4gICAgLy8gdHJpZ2dlciBtb3VzZWRvd24vdXAuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDQ0NTYyL2phdmFzY3JpcHQtb25jbGljay1ldmVudC1vdmVyLWZsYXNoLW9iamVjdFxuICAgIC8vIEFueSB0b3VjaCBldmVudHMgYXJlIHNldCB0byBibG9jayB0aGUgbW91c2Vkb3duIGV2ZW50IGZyb20gaGFwcGVuaW5nXG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGljayk7XG5cbiAgICAvLyBJZiB0aGUgY29udHJvbHMgd2VyZSBoaWRkZW4gd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGNoYW5nZSB3aXRob3V0IGEgdGFwIGV2ZW50XG4gICAgLy8gc28gd2UnbGwgY2hlY2sgaWYgdGhlIGNvbnRyb2xzIHdlcmUgYWxyZWFkeSBzaG93aW5nIGJlZm9yZSByZXBvcnRpbmcgdXNlclxuICAgIC8vIGFjdGl2aXR5XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoVG91Y2hTdGFydCk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2gsICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaE1vdmUpO1xuICAgIHRoaXMub24odGhpcy50ZWNoLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaEVuZCk7XG5cbiAgICAvLyBUdXJuIG9uIGNvbXBvbmVudCB0YXAgZXZlbnRzXG4gICAgdGhpcy50ZWNoLmVtaXRUYXBFdmVudHMoKTtcblxuICAgIC8vIFRoZSB0YXAgbGlzdGVuZXIgbmVlZHMgdG8gY29tZSBhZnRlciB0aGUgdG91Y2hlbmQgbGlzdGVuZXIgYmVjYXVzZSB0aGUgdGFwXG4gICAgLy8gbGlzdGVuZXIgY2FuY2VscyBvdXQgYW55IHJlcG9ydGVkVXNlckFjdGl2aXR5IHdoZW4gc2V0dGluZyB1c2VyQWN0aXZlKGZhbHNlKVxuICAgIHRoaXMub24odGhpcy50ZWNoLCAndGFwJywgdGhpcy5oYW5kbGVUZWNoVGFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGxpc3RlbmVycyB1c2VkIGZvciBjbGljayBhbmQgdGFwIGNvbnRyb2xzLiBUaGlzIGlzIG5lZWRlZCBmb3JcbiAgICogdG9nZ2xpbmcgdG8gY29udHJvbHMgZGlzYWJsZWQsIHdoZXJlIGEgdGFwL3RvdWNoIHNob3VsZCBkbyBub3RoaW5nLlxuICAgKi9cbiAgcmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzKCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8ganVzdCB1c2UgYHRoaXMub2ZmKClgIGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbmVlZGVkXG4gICAgLy8gbGlzdGVuZXJzIGFkZGVkIGJ5IHRlY2hzIHRoYXQgZXh0ZW5kIHRoaXMuXG4gICAgdGhpcy5vZmYodGhpcy50ZWNoLCAndGFwJywgdGhpcy5oYW5kbGVUZWNoVGFwKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2gsICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoVG91Y2hTdGFydCk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2gsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoRW5kKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2gsICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGljayk7XG4gIH1cblxuICAvKipcbiAgICogUGxheWVyIHdhaXRzIGZvciB0aGUgdGVjaCB0byBiZSByZWFkeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVGVjaFJlYWR5KCkge1xuICAgIHRoaXMudHJpZ2dlclJlYWR5KCk7XG5cbiAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGhhdmUgaXNzdWVzIHdpdGggYXV0b3BsYXkuXG4gICAgLy8gSW4gU2FmYXJpICg1LjEuMSksIHdoZW4gd2UgbW92ZSB0aGUgdmlkZW8gZWxlbWVudCBpbnRvIHRoZSBjb250YWluZXIgZGl2LCBhdXRvcGxheSBkb2Vzbid0IHdvcmsuXG4gICAgLy8gSW4gQ2hyb21lICgxNSksIGlmIHlvdSBoYXZlIGF1dG9wbGF5ICsgYSBwb3N0ZXIgKyBubyBjb250cm9scywgdGhlIHZpZGVvIGdldHMgaGlkZGVuIChidXQgYXVkaW8gcGxheXMpXG4gICAgLy8gVGhpcyBmaXhlcyBib3RoIGlzc3Vlcy4gTmVlZCB0byB3YWl0IGZvciBBUEksIHNvIGl0IHVwZGF0ZXMgZGlzcGxheXMgY29ycmVjdGx5XG4gICAgaWYgKHRoaXMudGFnICYmIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgJiYgdGhpcy5wYXVzZWQoKSkge1xuICAgICAgZGVsZXRlIHRoaXMudGFnLnBvc3RlcjsgLy8gQ2hyb21lIEZpeC4gRml4ZWQgaW4gQ2hyb21lIHYxNi5cbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBuYXRpdmUgY29udHJvbHMgYXJlIHVzZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVRlY2hVc2VOYXRpdmVDb250cm9scygpIHtcbiAgICB0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHModHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBhZ2VudCBiZWdpbnMgbG9va2luZyBmb3IgbWVkaWEgZGF0YVxuICAgKiBAZXZlbnQgbG9hZHN0YXJ0XG4gICAqL1xuICBoYW5kbGVUZWNoTG9hZFN0YXJ0KCkge1xuICAgIC8vIFRPRE86IFVwZGF0ZSB0byB1c2UgYGVtcHRpZWRgIGV2ZW50IGluc3RlYWQuIFNlZSAjMTI3Ny5cblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuXG4gICAgLy8gcmVzZXQgdGhlIGVycm9yIHN0YXRlXG4gICAgdGhpcy5lcnJvcihudWxsKTtcblxuICAgIC8vIElmIGl0J3MgYWxyZWFkeSBwbGF5aW5nIHdlIHdhbnQgdG8gdHJpZ2dlciBhIGZpcnN0cGxheSBldmVudCBub3cuXG4gICAgLy8gVGhlIGZpcnN0cGxheSBldmVudCByZWxpZXMgb24gYm90aCB0aGUgcGxheSBhbmQgbG9hZHN0YXJ0IGV2ZW50c1xuICAgIC8vIHdoaWNoIGNhbiBoYXBwZW4gaW4gYW55IG9yZGVyIGZvciBhIG5ldyBzb3VyY2VcbiAgICBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZpcnN0cGxheScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXNldCB0aGUgaGFzU3RhcnRlZCBzdGF0ZVxuICAgICAgdGhpcy5oYXNTdGFydGVkKGZhbHNlKTtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgfVxuICB9XG5cbiAgaGFzU3RhcnRlZChoYXNTdGFydGVkKSB7XG4gICAgaWYgKGhhc1N0YXJ0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gb25seSB1cGRhdGUgaWYgdGhpcyBpcyBhIG5ldyB2YWx1ZVxuICAgICAgaWYgKHRoaXMuaGFzU3RhcnRlZF8gIT09IGhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IGhhc1N0YXJ0ZWQ7XG4gICAgICAgIGlmIChoYXNTdGFydGVkKSB7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgICAgICAgLy8gdHJpZ2dlciB0aGUgZmlyc3RwbGF5IGV2ZW50IGlmIHRoaXMgbmV3bHkgaGFzIHBsYXllZFxuICAgICAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmhhc1N0YXJ0ZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBiZWdpbnMgb3IgcmVzdW1lcyBwbGF5YmFja1xuICAgKiBAZXZlbnQgcGxheVxuICAgKi9cbiAgaGFuZGxlVGVjaFBsYXkoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG5cbiAgICAvLyBoaWRlIHRoZSBwb3N0ZXIgd2hlbiB0aGUgdXNlciBoaXRzIHBsYXlcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXlcbiAgICB0aGlzLmhhc1N0YXJ0ZWQodHJ1ZSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3BsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgYmVnaW5zIHdhaXRpbmdcbiAgICogQGV2ZW50IHdhaXRpbmdcbiAgICovXG4gIGhhbmRsZVRlY2hXYWl0aW5nKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCd3YWl0aW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogQSBoYW5kbGVyIGZvciBldmVudHMgdGhhdCBzaWduYWwgdGhhdCB3YWl0aW5nIGhhcyBlbmRlZFxuICAgKiB3aGljaCBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICogQGV2ZW50IGNhbnBsYXlcbiAgICovXG4gIGhhbmRsZVRlY2hDYW5QbGF5KCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdjYW5wbGF5Jyk7XG4gIH1cblxuICAvKipcbiAgICogQSBoYW5kbGVyIGZvciBldmVudHMgdGhhdCBzaWduYWwgdGhhdCB3YWl0aW5nIGhhcyBlbmRlZFxuICAgKiB3aGljaCBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICogQGV2ZW50IGNhbnBsYXl0aHJvdWdoXG4gICAqL1xuICBoYW5kbGVUZWNoQ2FuUGxheVRocm91Z2goKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbnBsYXl0aHJvdWdoJyk7XG4gIH1cblxuICAvKipcbiAgICogQSBoYW5kbGVyIGZvciBldmVudHMgdGhhdCBzaWduYWwgdGhhdCB3YWl0aW5nIGhhcyBlbmRlZFxuICAgKiB3aGljaCBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICogQGV2ZW50IHBsYXlpbmdcbiAgICovXG4gIGhhbmRsZVRlY2hQbGF5aW5nKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdwbGF5aW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHBsYXllciBpcyBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICogQGV2ZW50IHNlZWtpbmdcbiAgICovXG4gIGhhbmRsZVRlY2hTZWVraW5nKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdzZWVraW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBmaW5pc2hlZCBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICogQGV2ZW50IHNlZWtlZFxuICAgKi9cbiAgaGFuZGxlVGVjaFNlZWtlZCgpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2Vla2luZycpO1xuICAgIHRoaXMudHJpZ2dlcignc2Vla2VkJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgdGhlIGZpcnN0IHRpbWUgYSB2aWRlbyBpcyBwbGF5ZWRcbiAgICpcbiAgICogTm90IHBhcnQgb2YgdGhlIEhMUyBzcGVjLCBhbmQgd2UncmUgbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdFxuICAgKiBpbXBsZW1lbnRhdGlvbiB5ZXQsIHNvIHVzZSBzcGFyaW5nbHkuIElmIHlvdSBkb24ndCBoYXZlIGEgcmVhc29uIHRvXG4gICAqIHByZXZlbnQgcGxheWJhY2ssIHVzZSBgbXlQbGF5ZXIub25lKCdwbGF5Jyk7YCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZXZlbnQgZmlyc3RwbGF5XG4gICAqL1xuICBoYW5kbGVUZWNoRmlyc3RQbGF5KCkge1xuICAgIC8vSWYgdGhlIGZpcnN0IHN0YXJ0dGltZSBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkXG4gICAgLy90aGVuIHdlIHdpbGwgc3RhcnQgYXQgdGhlIGdpdmVuIG9mZnNldCBpbiBzZWNvbmRzXG4gICAgaWYodGhpcy5vcHRpb25zX1snc3RhcnR0aW1lJ10pe1xuICAgICAgdGhpcy5jdXJyZW50VGltZSh0aGlzLm9wdGlvbnNfWydzdGFydHRpbWUnXSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgaGFzIGJlZW4gcGF1c2VkXG4gICAqIEBldmVudCBwYXVzZVxuICAgKi9cbiAgaGFuZGxlVGVjaFBhdXNlKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMudHJpZ2dlcigncGF1c2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGlsZSB0aGUgdXNlciBhZ2VudCBpcyBkb3dubG9hZGluZyBtZWRpYSBkYXRhXG4gICAqIEBldmVudCBwcm9ncmVzc1xuICAgKi9cbiAgaGFuZGxlVGVjaFByb2dyZXNzKCkge1xuICAgIHRoaXMudHJpZ2dlcigncHJvZ3Jlc3MnKTtcblxuICAgIC8vIEFkZCBjdXN0b20gZXZlbnQgZm9yIHdoZW4gc291cmNlIGlzIGZpbmlzaGVkIGRvd25sb2FkaW5nLlxuICAgIGlmICh0aGlzLmJ1ZmZlcmVkUGVyY2VudCgpID09PSAxKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2xvYWRlZGFsbGRhdGEnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBtZWRpYSByZXNvdXJjZSBpcyByZWFjaGVkIChjdXJyZW50VGltZSA9PSBkdXJhdGlvbilcbiAgICogQGV2ZW50IGVuZGVkXG4gICAqL1xuICBoYW5kbGVUZWNoRW5kZWQoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgaWYgKHRoaXMub3B0aW9uc19bJ2xvb3AnXSkge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSgwKTtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2VuZGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZHVyYXRpb24gb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIGZpcnN0IGtub3duIG9yIGNoYW5nZWRcbiAgICogQGV2ZW50IGR1cmF0aW9uY2hhbmdlXG4gICAqL1xuICBoYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2UoKSB7XG4gICAgdGhpcy51cGRhdGVEdXJhdGlvbigpO1xuICAgIHRoaXMudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBjbGljayBvbiB0aGUgbWVkaWEgZWxlbWVudCB0byBwbGF5L3BhdXNlXG4gICAqL1xuICBoYW5kbGVUZWNoQ2xpY2soZXZlbnQpIHtcbiAgICAvLyBXZSdyZSB1c2luZyBtb3VzZWRvd24gdG8gZGV0ZWN0IGNsaWNrcyB0aGFua3MgdG8gRmxhc2gsIGJ1dCBtb3VzZWRvd25cbiAgICAvLyB3aWxsIGFsc28gYmUgdHJpZ2dlcmVkIHdpdGggcmlnaHQtY2xpY2tzLCBzbyB3ZSBuZWVkIHRvIHByZXZlbnQgdGhhdFxuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgIC8vIFdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkIGEgY2xpY2sgc2hvdWxkIG5vdCB0b2dnbGUgcGxheWJhY2sgYmVjYXVzZVxuICAgIC8vIHRoZSBjbGljayBpcyBjb25zaWRlcmVkIGEgY29udHJvbFxuICAgIGlmICh0aGlzLmNvbnRyb2xzKCkpIHtcbiAgICAgIGlmICh0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0YXAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHdpbGwgdG9nZ2xlIHRoZSB1c2VyXG4gICAqIGFjdGl2aXR5IHN0YXRlLCB3aGljaCBoaWRlcyBhbmQgc2hvd3MgdGhlIGNvbnRyb2xzLlxuICAgKi9cbiAgaGFuZGxlVGVjaFRhcCgpIHtcbiAgICB0aGlzLnVzZXJBY3RpdmUoIXRoaXMudXNlckFjdGl2ZSgpKTtcbiAgfVxuXG4gIGhhbmRsZVRlY2hUb3VjaFN0YXJ0KCkge1xuICAgIHRoaXMudXNlcldhc0FjdGl2ZSA9IHRoaXMudXNlckFjdGl2ZSgpO1xuICB9XG5cbiAgaGFuZGxlVGVjaFRvdWNoTW92ZSgpIHtcbiAgICBpZiAodGhpcy51c2VyV2FzQWN0aXZlKXtcbiAgICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlVGVjaFRvdWNoRW5kKGV2ZW50KSB7XG4gICAgLy8gU3RvcCB0aGUgbW91c2UgZXZlbnRzIGZyb20gYWxzbyBoYXBwZW5pbmdcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZHVyYXRpb24gb2YgdGhlIHBsYXllciB1c2luZyB0aGUgdGVjaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlRHVyYXRpb24oKSB7XG4gICAgLy8gQWxsb3dzIGZvciBjYWNoaW5nIHZhbHVlIGluc3RlYWQgb2YgYXNraW5nIHBsYXllciBlYWNoIHRpbWUuXG4gICAgLy8gV2UgbmVlZCB0byBnZXQgdGhlIHRlY2hHZXQgcmVzcG9uc2UgYW5kIGNoZWNrIGZvciBhIHZhbHVlIHNvIHdlIGRvbid0XG4gICAgLy8gYWNjaWRlbnRhbGx5IGNhdXNlIHRoZSBzdGFjayB0byBibG93IHVwLlxuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMudGVjaEdldCgnZHVyYXRpb24nKTtcbiAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgIGlmIChkdXJhdGlvbiA8IDApIHtcbiAgICAgICAgZHVyYXRpb24gPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBzdHJlYW0gaXMgbGl2ZSBhbmQgcHJvcGFnYXRlIHN0eWxlcyBkb3duIHRvIFVJLlxuICAgICAgaWYgKGR1cmF0aW9uID09PSBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtbGl2ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWxpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIHN3aXRjaGVzIGluIG9yIG91dCBvZiBmdWxsc2NyZWVuIG1vZGVcbiAgICogQGV2ZW50IGZ1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG4gIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIG5hdGl2ZSBjbGljayBldmVudHMgb24gdGhlIFNXRiBhcmVuJ3QgdHJpZ2dlcmVkIG9uIElFMTEsIFdpbjguMVJUXG4gICAqIHVzZSBzdGFnZWNsaWNrIGV2ZW50cyB0cmlnZ2VyZWQgZnJvbSBpbnNpZGUgdGhlIFNXRiBpbnN0ZWFkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTdGFnZUNsaWNrKCkge1xuICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gIH1cblxuICBoYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgbG9hZGluZyBvZiBhbiBhdWRpby92aWRlb1xuICAgKiBAZXZlbnQgZXJyb3JcbiAgICovXG4gIGhhbmRsZVRlY2hFcnJvcigpIHtcbiAgICB0aGlzLmVycm9yKHRoaXMudGVjaC5lcnJvcigpLmNvZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgaW50ZW50aW9uYWxseSBub3QgZ2V0dGluZyBtZWRpYSBkYXRhXG4gICAqIEBldmVudCBzdXNwZW5kXG4gICAqL1xuICBoYW5kbGVUZWNoU3VzcGVuZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3N1c3BlbmQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvIGlzIGFib3J0ZWRcbiAgICogQGV2ZW50IGFib3J0XG4gICAqL1xuICBoYW5kbGVUZWNoQWJvcnQoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdhYm9ydCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgZW1wdHlcbiAgICogQGV2ZW50IGVtcHRpZWRcbiAgICovXG4gIGhhbmRsZVRlY2hFbXB0aWVkKCkge1xuICAgIHRoaXMudHJpZ2dlcignZW1wdGllZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgdHJ5aW5nIHRvIGdldCBtZWRpYSBkYXRhLCBidXQgZGF0YSBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBldmVudCBzdGFsbGVkXG4gICAqL1xuICBoYW5kbGVUZWNoU3RhbGxlZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3N0YWxsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgbWV0YSBkYXRhIGZvciB0aGUgYXVkaW8vdmlkZW9cbiAgICogQGV2ZW50IGxvYWRlZG1ldGFkYXRhXG4gICAqL1xuICBoYW5kbGVUZWNoTG9hZGVkTWV0YURhdGEoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdsb2FkZWRtZXRhZGF0YScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIHN3ZiBpc3N1ZXMgYSBtZXRhZGF0YXVwZGF0ZSBldmVudCwgYW4gZXZlbnQgc3BlY2lmaWMgdG8gb3VyXG4gICAqIEFiYWNhc3Qgc3RyZWFtIHRoYXQgdXNlcyBGbGFzaCdzIG9uTWV0YURhdGEgZXZlbnQgdG8gc3VyZmFjZSBzeW5jZWQgYmFubmVyXG4gICAqIGFkcyB0byBsaXN0ZW5lcnMuXG4gICAqIEBldmVudCBtZXRhZGF0YXVwZGF0ZVxuICAgKiBAcGFyYW0gZSBldmVudCBvYmplY3QgdG8gYmUgdHJpZ2dlcmVkIGZvciBleHRlcm5hbCBsaXN0ZW5lcnMsIHJldHJpZ2dlcmluZ1xuICAgKiBpdCBoZXJlIGVuc3VyZXMgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdCBtYWtlcyBpdCB0byBhbnkgbGlzdGVuZXJzLlxuICAgKi9cbiAgaGFuZGxlTWV0YURhdGFVcGRhdGUoZSkge1xuICAgIHRoaXMudHJpZ2dlcihlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgdGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIGF1ZGlvL3ZpZGVvXG4gICAqIEBldmVudCBsb2FkZGF0YVxuICAgKi9cbiAgaGFuZGxlVGVjaExvYWRlZERhdGEoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdsb2FkZWRkYXRhJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZFxuICAgKiBAZXZlbnQgdGltZXVwZGF0ZVxuICAgKi9cbiAgaGFuZGxlVGVjaFRpbWVVcGRhdGUoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCd0aW1ldXBkYXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgcGxheWluZyBzcGVlZCBvZiB0aGUgYXVkaW8vdmlkZW8gaXMgY2hhbmdlZFxuICAgKiBAZXZlbnQgcmF0ZWNoYW5nZVxuICAgKi9cbiAgaGFuZGxlVGVjaFJhdGVDaGFuZ2UoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdyYXRlY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgdm9sdW1lIGhhcyBiZWVuIGNoYW5nZWRcbiAgICogQGV2ZW50IHZvbHVtZWNoYW5nZVxuICAgKi9cbiAgaGFuZGxlVGVjaFZvbHVtZUNoYW5nZSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3ZvbHVtZWNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIHRleHQgdHJhY2sgaGFzIGJlZW4gY2hhbmdlZFxuICAgKiBAZXZlbnQgdGV4dHRyYWNrY2hhbmdlXG4gICAqL1xuICBvblRleHRUcmFja0NoYW5nZSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3RleHR0cmFja2NoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCBmb3IgY2FjaGVkIHZhbHVlcy5cbiAgICovXG4gIGdldENhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlXztcbiAgfVxuXG4gIC8vIFBhc3MgdmFsdWVzIHRvIHRoZSBwbGF5YmFjayB0ZWNoXG4gIHRlY2hDYWxsKG1ldGhvZCwgYXJnKSB7XG4gICAgLy8gSWYgaXQncyBub3QgcmVhZHkgeWV0LCBjYWxsIG1ldGhvZCB3aGVuIGl0IGlzXG4gICAgaWYgKHRoaXMudGVjaCAmJiAhdGhpcy50ZWNoLmlzUmVhZHlfKSB7XG4gICAgICB0aGlzLnRlY2gucmVhZHkoZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpc1ttZXRob2RdKGFyZyk7XG4gICAgICB9KTtcblxuICAgIC8vIE90aGVyd2lzZSBjYWxsIG1ldGhvZCBub3dcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy50ZWNoW21ldGhvZF0oYXJnKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBMaWIubG9nKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBjYWxscyBjYW4ndCB3YWl0IGZvciB0aGUgdGVjaCwgYW5kIHNvbWV0aW1lcyBkb24ndCBuZWVkIHRvLlxuICB0ZWNoR2V0KG1ldGhvZCkge1xuICAgIGlmICh0aGlzLnRlY2ggJiYgdGhpcy50ZWNoLmlzUmVhZHlfKSB7XG5cbiAgICAgIC8vIEZsYXNoIGxpa2VzIHRvIGRpZSBhbmQgcmVsb2FkIHdoZW4geW91IGhpZGUgb3IgcmVwb3NpdGlvbiBpdC5cbiAgICAgIC8vIEluIHRoZXNlIGNhc2VzIHRoZSBvYmplY3QgbWV0aG9kcyBnbyBhd2F5IGFuZCB3ZSBnZXQgZXJyb3JzLlxuICAgICAgLy8gV2hlbiB0aGF0IGhhcHBlbnMgd2UnbGwgY2F0Y2ggdGhlIGVycm9ycyBhbmQgaW5mb3JtIHRlY2ggdGhhdCBpdCdzIG5vdCByZWFkeSBhbnkgbW9yZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlY2hbbWV0aG9kXSgpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIFdoZW4gYnVpbGRpbmcgYWRkaXRpb25hbCB0ZWNoIGxpYnMsIGFuIGV4cGVjdGVkIG1ldGhvZCBtYXkgbm90IGJlIGRlZmluZWQgeWV0XG4gICAgICAgIGlmICh0aGlzLnRlY2hbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgTGliLmxvZyhgVmlkZW8uanM6ICR7bWV0aG9kfSBtZXRob2Qgbm90IGRlZmluZWQgZm9yICR7dGhpcy50ZWNoTmFtZX0gcGxheWJhY2sgdGVjaG5vbG9neS5gLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuIGEgbWV0aG9kIGlzbid0IGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0IGl0IHRocm93cyBhIFR5cGVFcnJvclxuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgICBMaWIubG9nKGBWaWRlby5qczogJHttZXRob2R9IHVuYXZhaWxhYmxlIG9uICR7dGhpcy50ZWNoTmFtZX0gcGxheWJhY2sgdGVjaG5vbG9neSBlbGVtZW50LmAsIGUpO1xuICAgICAgICAgICAgdGhpcy50ZWNoLmlzUmVhZHlfID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIExpYi5sb2coZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIHN0YXJ0IG1lZGlhIHBsYXliYWNrXG4gICAqXG4gICAqICAgICBteVBsYXllci5wbGF5KCk7XG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn0gc2VsZlxuICAgKi9cbiAgcGxheSgpIHtcbiAgICB0aGlzLnRlY2hDYWxsKCdwbGF5Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIHZpZGVvIHBsYXliYWNrXG4gICAqXG4gICAqICAgICBteVBsYXllci5wYXVzZSgpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IHNlbGZcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIHRoaXMudGVjaENhbGwoJ3BhdXNlJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBwYXVzZWRcbiAgICpcbiAgICogICAgIHZhciBpc1BhdXNlZCA9IG15UGxheWVyLnBhdXNlZCgpO1xuICAgKiAgICAgdmFyIGlzUGxheWluZyA9ICFteVBsYXllci5wYXVzZWQoKTtcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2UgaWYgdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nLCBvciB0cnVlIG90aGVyd2lzZVxuICAgKi9cbiAgcGF1c2VkKCkge1xuICAgIC8vIFRoZSBpbml0aWFsIHN0YXRlIG9mIHBhdXNlZCBzaG91bGQgYmUgdHJ1ZSAoaW4gU2FmYXJpIGl0J3MgYWN0dWFsbHkgZmFsc2UpXG4gICAgcmV0dXJuICh0aGlzLnRlY2hHZXQoJ3BhdXNlZCcpID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7XG4gIH1cblxuICAvKipcbiAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGlzIFwic2NydWJiaW5nXCIuIFNjcnViYmluZyBpcyB3aGVuIHRoZSB1c2VyXG4gICogaGFzIGNsaWNrZWQgdGhlIHByb2dyZXNzIGJhciBoYW5kbGUgYW5kIGlzIGRyYWdnaW5nIGl0IGFsb25nIHRoZSBwcm9ncmVzcyBiYXIuXG4gICogQHBhcmFtICB7Qm9vbGVhbn0gaXNTY3J1YmJpbmcgICBUcnVlL2ZhbHNlIHRoZSB1c2VyIGlzIHNjcnViYmluZ1xuICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgVGhlIHNjcnViYmluZyBzdGF0dXMgd2hlbiBnZXR0aW5nXG4gICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICBUaGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAqL1xuICBzY3J1YmJpbmcoaXNTY3J1YmJpbmcpIHtcbiAgICBpZiAoaXNTY3J1YmJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zY3J1YmJpbmdfID0gISFpc1NjcnViYmluZztcblxuICAgICAgaWYgKGlzU2NydWJiaW5nKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zY3J1YmJpbmcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zY3J1YmJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2NydWJiaW5nXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHRpbWUgKGluIHNlY29uZHMpXG4gICAqXG4gICAqICAgICAvLyBnZXRcbiAgICogICAgIHZhciB3aGVyZVlvdUF0ID0gbXlQbGF5ZXIuY3VycmVudFRpbWUoKTtcbiAgICpcbiAgICogICAgIC8vIHNldFxuICAgKiAgICAgbXlQbGF5ZXIuY3VycmVudFRpbWUoMTIwKTsgLy8gMiBtaW51dGVzIGludG8gdGhlIHZpZGVvXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmc9fSBzZWNvbmRzIFRoZSB0aW1lIHRvIHNlZWsgdG9cbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgVGhlIHRpbWUgaW4gc2Vjb25kcywgd2hlbiBub3Qgc2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgIHNlbGYsIHdoZW4gdGhlIGN1cnJlbnQgdGltZSBpcyBzZXRcbiAgICovXG4gIGN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICBpZiAoc2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIHRoaXMudGVjaENhbGwoJ3NldEN1cnJlbnRUaW1lJywgc2Vjb25kcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGNhY2hlIGxhc3QgY3VycmVudFRpbWUgYW5kIHJldHVybi4gZGVmYXVsdCB0byAwIHNlY29uZHNcbiAgICAvL1xuICAgIC8vIENhY2hpbmcgdGhlIGN1cnJlbnRUaW1lIGlzIG1lYW50IHRvIHByZXZlbnQgYSBtYXNzaXZlIGFtb3VudCBvZiByZWFkcyBvbiB0aGUgdGVjaCdzXG4gICAgLy8gY3VycmVudFRpbWUgd2hlbiBzY3J1YmJpbmcsIGJ1dCBtYXkgbm90IHByb3ZpZGUgbXVjaCBwZXJmb3JtYW5jZSBiZW5lZml0IGFmdGVyYWxsLlxuICAgIC8vIFNob3VsZCBiZSB0ZXN0ZWQuIEFsc28gc29tZXRoaW5nIGhhcyB0byByZWFkIHRoZSBhY3R1YWwgY3VycmVudCB0aW1lIG9yIHRoZSBjYWNoZSB3aWxsXG4gICAgLy8gbmV2ZXIgZ2V0IHVwZGF0ZWQuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lID0gKHRoaXMudGVjaEdldCgnY3VycmVudFRpbWUnKSB8fCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxlbmd0aCBpbiB0aW1lIG9mIHRoZSB2aWRlbyBpbiBzZWNvbmRzXG4gICAqXG4gICAqICAgICB2YXIgbGVuZ3RoT2ZWaWRlbyA9IG15UGxheWVyLmR1cmF0aW9uKCk7XG4gICAqXG4gICAqICoqTk9URSoqOiBUaGUgdmlkZW8gbXVzdCBoYXZlIHN0YXJ0ZWQgbG9hZGluZyBiZWZvcmUgdGhlIGR1cmF0aW9uIGNhbiBiZVxuICAgKiBrbm93biwgYW5kIGluIHRoZSBjYXNlIG9mIEZsYXNoLCBtYXkgbm90IGJlIGtub3duIHVudGlsIHRoZSB2aWRlbyBzdGFydHNcbiAgICogcGxheWluZy5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIGluIHNlY29uZHNcbiAgICovXG4gIGR1cmF0aW9uKHNlY29uZHMpIHtcbiAgICBpZiAoc2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIC8vIGNhY2hlIHRoZSBsYXN0IHNldCB2YWx1ZSBmb3Igb3B0aW1pemVkIHNjcnViYmluZyAoZXNwLiBGbGFzaClcbiAgICAgIHRoaXMuY2FjaGVfLmR1cmF0aW9uID0gcGFyc2VGbG9hdChzZWNvbmRzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FjaGVfLmR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlRHVyYXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8uZHVyYXRpb24gfHwgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGhvdyBtdWNoIHRpbWUgaXMgbGVmdC5cbiAgICpcbiAgICogICAgIHZhciB0aW1lTGVmdCA9IG15UGxheWVyLnJlbWFpbmluZ1RpbWUoKTtcbiAgICpcbiAgICogTm90IGEgbmF0aXZlIHZpZGVvIGVsZW1lbnQgZnVuY3Rpb24sIGJ1dCB1c2VmdWxcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgdGltZSByZW1haW5pbmcgaW4gc2Vjb25kc1xuICAgKi9cbiAgcmVtYWluaW5nVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kdXJhdGlvbigpIC0gdGhpcy5jdXJyZW50VGltZSgpO1xuICB9XG5cbiAgLy8gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy92aWRlby5odG1sI2RvbS1tZWRpYS1idWZmZXJlZFxuICAvLyBCdWZmZXJlZCByZXR1cm5zIGEgdGltZXJhbmdlIG9iamVjdC5cbiAgLy8gS2luZCBvZiBsaWtlIGFuIGFycmF5IG9mIHBvcnRpb25zIG9mIHRoZSB2aWRlbyB0aGF0IGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuXG4gIC8qKlxuICAgKiBHZXQgYSBUaW1lUmFuZ2Ugb2JqZWN0IHdpdGggdGhlIHRpbWVzIG9mIHRoZSB2aWRlbyB0aGF0IGhhdmUgYmVlbiBkb3dubG9hZGVkXG4gICAqXG4gICAqIElmIHlvdSBqdXN0IHdhbnQgdGhlIHBlcmNlbnQgb2YgdGhlIHZpZGVvIHRoYXQncyBiZWVuIGRvd25sb2FkZWQsXG4gICAqIHVzZSBidWZmZXJlZFBlcmNlbnQuXG4gICAqXG4gICAqICAgICAvLyBOdW1iZXIgb2YgZGlmZmVyZW50IHJhbmdlcyBvZiB0aW1lIGhhdmUgYmVlbiBidWZmZXJlZC4gVXN1YWxseSAxLlxuICAgKiAgICAgbnVtYmVyT2ZSYW5nZXMgPSBidWZmZXJlZFRpbWVSYW5nZS5sZW5ndGgsXG4gICAqXG4gICAqICAgICAvLyBUaW1lIGluIHNlY29uZHMgd2hlbiB0aGUgZmlyc3QgcmFuZ2Ugc3RhcnRzLiBVc3VhbGx5IDAuXG4gICAqICAgICBmaXJzdFJhbmdlU3RhcnQgPSBidWZmZXJlZFRpbWVSYW5nZS5zdGFydCgwKSxcbiAgICpcbiAgICogICAgIC8vIFRpbWUgaW4gc2Vjb25kcyB3aGVuIHRoZSBmaXJzdCByYW5nZSBlbmRzXG4gICAqICAgICBmaXJzdFJhbmdlRW5kID0gYnVmZmVyZWRUaW1lUmFuZ2UuZW5kKDApLFxuICAgKlxuICAgKiAgICAgLy8gTGVuZ3RoIGluIHNlY29uZHMgb2YgdGhlIGZpcnN0IHRpbWUgcmFuZ2VcbiAgICogICAgIGZpcnN0UmFuZ2VMZW5ndGggPSBmaXJzdFJhbmdlRW5kIC0gZmlyc3RSYW5nZVN0YXJ0O1xuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbW9jayBUaW1lUmFuZ2Ugb2JqZWN0IChmb2xsb3dpbmcgSFRNTCBzcGVjKVxuICAgKi9cbiAgYnVmZmVyZWQoKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy50ZWNoR2V0KCdidWZmZXJlZCcpO1xuXG4gICAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICBidWZmZXJlZCA9IExpYi5jcmVhdGVUaW1lUmFuZ2UoMCwwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJjZW50IChhcyBhIGRlY2ltYWwpIG9mIHRoZSB2aWRlbyB0aGF0J3MgYmVlbiBkb3dubG9hZGVkXG4gICAqXG4gICAqICAgICB2YXIgaG93TXVjaElzRG93bmxvYWRlZCA9IG15UGxheWVyLmJ1ZmZlcmVkUGVyY2VudCgpO1xuICAgKlxuICAgKiAwIG1lYW5zIG5vbmUsIDEgbWVhbnMgYWxsLlxuICAgKiAoVGhpcyBtZXRob2QgaXNuJ3QgaW4gdGhlIEhUTUw1IHNwZWMsIGJ1dCBpdCdzIHZlcnkgY29udmVuaWVudClcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxIHJlcHJlc2VudGluZyB0aGUgcGVyY2VudFxuICAgKi9cbiAgYnVmZmVyZWRQZXJjZW50KCkge1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSxcbiAgICAgICAgYnVmZmVyZWQgPSB0aGlzLmJ1ZmZlcmVkKCksXG4gICAgICAgIGJ1ZmZlcmVkRHVyYXRpb24gPSAwLFxuICAgICAgICBzdGFydCwgZW5kO1xuXG4gICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaT0wOyBpPGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKXtcbiAgICAgIHN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICBlbmQgICA9IGJ1ZmZlcmVkLmVuZChpKTtcblxuICAgICAgLy8gYnVmZmVyZWQgZW5kIGNhbiBiZSBiaWdnZXIgdGhhbiBkdXJhdGlvbiBieSBhIHZlcnkgc21hbGwgZnJhY3Rpb25cbiAgICAgIGlmIChlbmQgPiBkdXJhdGlvbikge1xuICAgICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgYnVmZmVyZWREdXJhdGlvbiArPSBlbmQgLSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyZWREdXJhdGlvbiAvIGR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW5kaW5nIHRpbWUgb2YgdGhlIGxhc3QgYnVmZmVyZWQgdGltZSByYW5nZVxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHByb2dyZXNzIGJhciB0byBlbmNhcHN1bGF0ZSBhbGwgdGltZSByYW5nZXMuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGVuZCBvZiB0aGUgbGFzdCBidWZmZXJlZCB0aW1lIHJhbmdlXG4gICAqL1xuICBidWZmZXJlZEVuZCgpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLmJ1ZmZlcmVkKCksXG4gICAgICAgIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpLFxuICAgICAgICBlbmQgPSBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoLTEpO1xuXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgdm9sdW1lIG9mIHRoZSBtZWRpYVxuICAgKlxuICAgKiAgICAgLy8gZ2V0XG4gICAqICAgICB2YXIgaG93TG91ZElzSXQgPSBteVBsYXllci52b2x1bWUoKTtcbiAgICpcbiAgICogICAgIC8vIHNldFxuICAgKiAgICAgbXlQbGF5ZXIudm9sdW1lKDAuNSk7IC8vIFNldCB2b2x1bWUgdG8gaGFsZlxuICAgKlxuICAgKiAwIGlzIG9mZiAobXV0ZWQpLCAxLjAgaXMgYWxsIHRoZSB3YXkgdXAsIDAuNSBpcyBoYWxmIHdheS5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSBwZXJjZW50QXNEZWNpbWFsIFRoZSBuZXcgdm9sdW1lIGFzIGEgZGVjaW1hbCBwZXJjZW50XG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICBUaGUgY3VycmVudCB2b2x1bWUsIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgICAgICAgICAgICBzZWxmLCB3aGVuIHNldHRpbmdcbiAgICovXG4gIHZvbHVtZShwZXJjZW50QXNEZWNpbWFsKSB7XG4gICAgbGV0IHZvbDtcblxuICAgIGlmIChwZXJjZW50QXNEZWNpbWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZvbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHBhcnNlRmxvYXQocGVyY2VudEFzRGVjaW1hbCkpKTsgLy8gRm9yY2UgdmFsdWUgdG8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICB0aGlzLmNhY2hlXy52b2x1bWUgPSB2b2w7XG4gICAgICB0aGlzLnRlY2hDYWxsKCdzZXRWb2x1bWUnLCB2b2wpO1xuICAgICAgTGliLnNldExvY2FsU3RvcmFnZSgndm9sdW1lJywgdm9sKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gMSB3aGVuIHJldHVybmluZyBjdXJyZW50IHZvbHVtZS5cbiAgICB2b2wgPSBwYXJzZUZsb2F0KHRoaXMudGVjaEdldCgndm9sdW1lJykpO1xuICAgIHJldHVybiAoaXNOYU4odm9sKSkgPyAxIDogdm9sO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG11dGVkIHN0YXRlLCBvciB0dXJuIG11dGUgb24gb3Igb2ZmXG4gICAqXG4gICAqICAgICAvLyBnZXRcbiAgICogICAgIHZhciBpc1ZvbHVtZU11dGVkID0gbXlQbGF5ZXIubXV0ZWQoKTtcbiAgICpcbiAgICogICAgIC8vIHNldFxuICAgKiAgICAgbXlQbGF5ZXIubXV0ZWQodHJ1ZSk7IC8vIG11dGUgdGhlIHZvbHVtZVxuICAgKlxuICAgKiBAcGFyYW0gIHtCb29sZWFuPX0gbXV0ZWQgVHJ1ZSB0byBtdXRlLCBmYWxzZSB0byB1bm11dGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBtdXRlIGlzIG9uLCBmYWxzZSBpZiBub3QsIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IHNlbGYsIHdoZW4gc2V0dGluZyBtdXRlXG4gICAqL1xuICBtdXRlZChtdXRlZCkge1xuICAgIGlmIChtdXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsKCdzZXRNdXRlZCcsIG11dGVkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCdtdXRlZCcpIHx8IGZhbHNlOyAvLyBEZWZhdWx0IHRvIGZhbHNlXG4gIH1cblxuICAvLyBDaGVjayBpZiBjdXJyZW50IHRlY2ggY2FuIHN1cHBvcnQgbmF0aXZlIGZ1bGxzY3JlZW5cbiAgLy8gKGUuZy4gd2l0aCBidWlsdCBpbiBjb250cm9scyBsaWtlIGlPUywgc28gbm90IG91ciBmbGFzaCBzd2YpXG4gIHN1cHBvcnRzRnVsbFNjcmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCdzdXBwb3J0c0Z1bGxTY3JlZW4nKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgKlxuICAgKiAgICAgLy8gZ2V0XG4gICAqICAgICB2YXIgZnVsbHNjcmVlbk9yTm90ID0gbXlQbGF5ZXIuaXNGdWxsc2NyZWVuKCk7XG4gICAqXG4gICAqICAgICAvLyBzZXRcbiAgICogICAgIG15UGxheWVyLmlzRnVsbHNjcmVlbih0cnVlKTsgLy8gdGVsbCB0aGUgcGxheWVyIGl0J3MgaW4gZnVsbHNjcmVlblxuICAgKlxuICAgKiBOT1RFOiBBcyBvZiB0aGUgbGF0ZXN0IEhUTUw1IHNwZWMsIGlzRnVsbHNjcmVlbiBpcyBubyBsb25nZXIgYW4gb2ZmaWNpYWxcbiAgICogcHJvcGVydHkgYW5kIGluc3RlYWQgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgaXMgdXNlZC4gQnV0IGlzRnVsbHNjcmVlbiBpc1xuICAgKiBzdGlsbCBhIHZhbHVhYmxlIHByb3BlcnR5IGZvciBpbnRlcm5hbCBwbGF5ZXIgd29ya2luZ3MuXG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW49fSBpc0ZTIFVwZGF0ZSB0aGUgcGxheWVyJ3MgZnVsbHNjcmVlbiBzdGF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGZ1bGxzY3JlZW4sIGZhbHNlIGlmIG5vdFxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IHNlbGYsIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgaXNGdWxsc2NyZWVuKGlzRlMpIHtcbiAgICBpZiAoaXNGUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbl8gPSAhIWlzRlM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuICEhdGhpcy5pc0Z1bGxzY3JlZW5fO1xuICB9XG5cbiAgLyoqXG4gICAqIE9sZCBuYW1pbmcgZm9yIGlzRnVsbHNjcmVlbigpXG4gICAqIEBkZXByZWNhdGVkIGZvciBsb3dlcmNhc2UgJ3MnIHZlcnNpb25cbiAgICovXG4gIGlzRnVsbFNjcmVlbihpc0ZTKSB7XG4gICAgTGliLmxvZy53YXJuKCdwbGF5ZXIuaXNGdWxsU2NyZWVuKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHBsYXllci5pc0Z1bGxzY3JlZW4oKSB3aXRoIGEgbG93ZXJjYXNlIFwic1wiKScpO1xuICAgIHJldHVybiB0aGlzLmlzRnVsbHNjcmVlbihpc0ZTKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGUgdmlkZW8gdG8gZnVsbCBzY3JlZW5cbiAgICpcbiAgICogICAgIG15UGxheWVyLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAqXG4gICAqIEluIHNvbWUgYnJvd3NlcnMsIGZ1bGwgc2NyZWVuIGlzIG5vdCBzdXBwb3J0ZWQgbmF0aXZlbHksIHNvIGl0IGVudGVyc1xuICAgKiBcImZ1bGwgd2luZG93IG1vZGVcIiwgd2hlcmUgdGhlIHZpZGVvIGZpbGxzIHRoZSBicm93c2VyIHdpbmRvdy5cbiAgICogSW4gYnJvd3NlcnMgYW5kIGRldmljZXMgdGhhdCBzdXBwb3J0IG5hdGl2ZSBmdWxsIHNjcmVlbiwgc29tZXRpbWVzIHRoZVxuICAgKiBicm93c2VyJ3MgZGVmYXVsdCBjb250cm9scyB3aWxsIGJlIHNob3duLCBhbmQgbm90IHRoZSBWaWRlby5qcyBjdXN0b20gc2tpbi5cbiAgICogVGhpcyBpbmNsdWRlcyBtb3N0IG1vYmlsZSBkZXZpY2VzIChpT1MsIEFuZHJvaWQpIGFuZCBvbGRlciB2ZXJzaW9ucyBvZlxuICAgKiBTYWZhcmkuXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn0gc2VsZlxuICAgKi9cbiAgcmVxdWVzdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKHRydWUpO1xuXG4gICAgaWYgKGZzQXBpKSB7XG4gICAgICAvLyB0aGUgYnJvd3NlciBzdXBwb3J0cyBnb2luZyBmdWxsc2NyZWVuIGF0IHRoZSBlbGVtZW50IGxldmVsIHNvIHdlIGNhblxuICAgICAgLy8gdGFrZSB0aGUgY29udHJvbHMgZnVsbHNjcmVlbiBhcyB3ZWxsIGFzIHRoZSB2aWRlb1xuXG4gICAgICAvLyBUcmlnZ2VyIGZ1bGxzY3JlZW5jaGFuZ2UgZXZlbnQgYWZ0ZXIgY2hhbmdlXG4gICAgICAvLyBXZSBoYXZlIHRvIHNwZWNpZmljYWxseSBhZGQgdGhpcyBlYWNoIHRpbWUsIGFuZCByZW1vdmVcbiAgICAgIC8vIHdoZW4gY2FuY2VsaW5nIGZ1bGxzY3JlZW4uIE90aGVyd2lzZSBpZiB0aGVyZSdzIG11bHRpcGxlXG4gICAgICAvLyBwbGF5ZXJzIG9uIGEgcGFnZSwgdGhleSB3b3VsZCBhbGwgYmUgcmVhY3RpbmcgdG8gdGhlIHNhbWUgZnVsbHNjcmVlblxuICAgICAgLy8gZXZlbnRzXG4gICAgICBFdmVudHMub24oZG9jdW1lbnQsIGZzQXBpWydmdWxsc2NyZWVuY2hhbmdlJ10sIExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZShlKXtcbiAgICAgICAgdGhpcy5pc0Z1bGxzY3JlZW4oZG9jdW1lbnRbZnNBcGkuZnVsbHNjcmVlbkVsZW1lbnRdKTtcblxuICAgICAgICAvLyBJZiBjYW5jZWxsaW5nIGZ1bGxzY3JlZW4sIHJlbW92ZSBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgRXZlbnRzLm9mZihkb2N1bWVudCwgZnNBcGlbJ2Z1bGxzY3JlZW5jaGFuZ2UnXSwgZG9jdW1lbnRGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgICAgfSkpO1xuXG4gICAgICB0aGlzLmVsX1tmc0FwaS5yZXF1ZXN0RnVsbHNjcmVlbl0oKTtcblxuICAgIH0gZWxzZSBpZiAodGhpcy50ZWNoLnN1cHBvcnRzRnVsbFNjcmVlbigpKSB7XG4gICAgICAvLyB3ZSBjYW4ndCB0YWtlIHRoZSB2aWRlby5qcyBjb250cm9scyBmdWxsc2NyZWVuIGJ1dCB3ZSBjYW4gZ28gZnVsbHNjcmVlblxuICAgICAgLy8gd2l0aCBuYXRpdmUgY29udHJvbHNcbiAgICAgIHRoaXMudGVjaENhbGwoJ2VudGVyRnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmdWxsc2NyZWVuIGlzbid0IHN1cHBvcnRlZCBzbyB3ZSdsbCBqdXN0IHN0cmV0Y2ggdGhlIHZpZGVvIGVsZW1lbnQgdG9cbiAgICAgIC8vIGZpbGwgdGhlIHZpZXdwb3J0XG4gICAgICB0aGlzLmVudGVyRnVsbFdpbmRvdygpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogT2xkIG5hbWluZyBmb3IgcmVxdWVzdEZ1bGxzY3JlZW5cbiAgICogQGRlcHJlY2F0ZWQgZm9yIGxvd2VyIGNhc2UgJ3MnIHZlcnNpb25cbiAgICovXG4gIHJlcXVlc3RGdWxsU2NyZWVuKCkge1xuICAgIExpYi5sb2cud2FybigncGxheWVyLnJlcXVlc3RGdWxsU2NyZWVuKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHBsYXllci5yZXF1ZXN0RnVsbHNjcmVlbigpIHdpdGggYSBsb3dlcmNhc2UgXCJzXCIpJyk7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZpZGVvIHRvIGl0cyBub3JtYWwgc2l6ZSBhZnRlciBoYXZpbmcgYmVlbiBpbiBmdWxsIHNjcmVlbiBtb2RlXG4gICAqXG4gICAqICAgICBteVBsYXllci5leGl0RnVsbHNjcmVlbigpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IHNlbGZcbiAgICovXG4gIGV4aXRGdWxsc2NyZWVuKCkge1xuICAgIHZhciBmc0FwaSA9IEZ1bGxzY3JlZW5BcGk7XG4gICAgdGhpcy5pc0Z1bGxzY3JlZW4oZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGJyb3dzZXIgZWxlbWVudCBmdWxsc2NyZWVuIHN1cHBvcnRcbiAgICBpZiAoZnNBcGkpIHtcbiAgICAgIGRvY3VtZW50W2ZzQXBpLmV4aXRGdWxsc2NyZWVuXSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50ZWNoLnN1cHBvcnRzRnVsbFNjcmVlbigpKSB7XG4gICAgIHRoaXMudGVjaENhbGwoJ2V4aXRGdWxsU2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xuICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPbGQgbmFtaW5nIGZvciBleGl0RnVsbHNjcmVlblxuICAgKiBAZGVwcmVjYXRlZCBmb3IgZXhpdEZ1bGxzY3JlZW5cbiAgICovXG4gIGNhbmNlbEZ1bGxTY3JlZW4oKSB7XG4gICAgTGliLmxvZy53YXJuKCdwbGF5ZXIuY2FuY2VsRnVsbFNjcmVlbigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSBwbGF5ZXIuZXhpdEZ1bGxzY3JlZW4oKScpO1xuICAgIHJldHVybiB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gIH1cblxuICAvLyBXaGVuIGZ1bGxzY3JlZW4gaXNuJ3Qgc3VwcG9ydGVkIHdlIGNhbiBzdHJldGNoIHRoZSB2aWRlbyBjb250YWluZXIgdG8gYXMgd2lkZSBhcyB0aGUgYnJvd3NlciB3aWxsIGxldCB1cy5cbiAgZW50ZXJGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gdHJ1ZTtcblxuICAgIC8vIFN0b3Jpbmcgb3JpZ2luYWwgZG9jIG92ZXJmbG93IHZhbHVlIHRvIHJldHVybiB0byB3aGVuIGZ1bGxzY3JlZW4gaXMgb2ZmXG4gICAgdGhpcy5kb2NPcmlnT3ZlcmZsb3cgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cbiAgICAvLyBBZGQgbGlzdGVuZXIgZm9yIGVzYyBrZXkgdG8gZXhpdCBmdWxsc2NyZWVuXG4gICAgRXZlbnRzLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIExpYi5iaW5kKHRoaXMsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KSk7XG5cbiAgICAvLyBIaWRlIGFueSBzY3JvbGwgYmFyc1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgLy8gQXBwbHkgZnVsbHNjcmVlbiBzdHlsZXNcbiAgICBMaWIuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdlbnRlckZ1bGxXaW5kb3cnKTtcbiAgfVxuXG4gIGZ1bGxXaW5kb3dPbkVzY0tleShldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4aXRGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gZmFsc2U7XG4gICAgRXZlbnRzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmZ1bGxXaW5kb3dPbkVzY0tleSk7XG5cbiAgICAvLyBVbmhpZGUgc2Nyb2xsIGJhcnMuXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gdGhpcy5kb2NPcmlnT3ZlcmZsb3c7XG5cbiAgICAvLyBSZW1vdmUgZnVsbHNjcmVlbiBzdHlsZXNcbiAgICBMaWIucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgLy8gUmVzaXplIHRoZSBib3gsIGNvbnRyb2xsZXIsIGFuZCBwb3N0ZXIgdG8gb3JpZ2luYWwgc2l6ZXNcbiAgICAvLyB0aGlzLnBvc2l0aW9uQWxsKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdleGl0RnVsbFdpbmRvdycpO1xuICB9XG5cbiAgc2VsZWN0U291cmNlKHNvdXJjZXMpIHtcbiAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBwbGF5YmFjayB0ZWNobm9sb2d5IGluIHRoZSBvcHRpb25zIG9yZGVyXG4gICAgZm9yICh2YXIgaT0wLGo9dGhpcy5vcHRpb25zX1sndGVjaE9yZGVyJ107aTxqLmxlbmd0aDtpKyspIHtcbiAgICAgIGxldCB0ZWNoTmFtZSA9IExpYi5jYXBpdGFsaXplKGpbaV0pO1xuICAgICAgbGV0IHRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KHRlY2hOYW1lKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdGVjaCBpcyBkZWZpbmVkIGJlZm9yZSBjb250aW51aW5nXG4gICAgICBpZiAoIXRlY2gpIHtcbiAgICAgICAgTGliLmxvZy5lcnJvcihgVGhlIFwiJHt0ZWNoTmFtZX1cIiB0ZWNoIGlzIHVuZGVmaW5lZC4gU2tpcHBlZCBicm93c2VyIHN1cHBvcnQgY2hlY2sgZm9yIHRoYXQgdGVjaC5gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgaWYgKHRlY2guaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBzb3VyY2Ugb2JqZWN0XG4gICAgICAgIGZvciAodmFyIGE9MCxiPXNvdXJjZXM7YTxiLmxlbmd0aDthKyspIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gYlthXTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIHNvdXJjZSBjYW4gYmUgcGxheWVkIHdpdGggdGhpcyB0ZWNobm9sb2d5XG4gICAgICAgICAgaWYgKHRlY2hbJ2NhblBsYXlTb3VyY2UnXShzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2U6IHNvdXJjZSwgdGVjaDogdGVjaE5hbWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNvdXJjZSBmdW5jdGlvbiB1cGRhdGVzIHRoZSB2aWRlbyBzb3VyY2VcbiAgICpcbiAgICogVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIHZhcmlhYmxlcyB5b3UgY2FuIHBhc3MgYXMgdGhlIGFyZ3VtZW50LlxuICAgKlxuICAgKiAqKlVSTCBTdHJpbmcqKjogQSBVUkwgdG8gdGhlIHRoZSB2aWRlbyBmaWxlLiBVc2UgdGhpcyBtZXRob2QgaWYgeW91IGFyZSBzdXJlXG4gICAqIHRoZSBjdXJyZW50IHBsYXliYWNrIHRlY2hub2xvZ3kgKEhUTUw1L0ZsYXNoKSBjYW4gc3VwcG9ydCB0aGUgc291cmNlIHlvdVxuICAgKiBwcm92aWRlLiBDdXJyZW50bHkgb25seSBNUDQgZmlsZXMgY2FuIGJlIHVzZWQgaW4gYm90aCBIVE1MNSBhbmQgRmxhc2guXG4gICAqXG4gICAqICAgICBteVBsYXllci5zcmMoXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ubXA0XCIpO1xuICAgKlxuICAgKiAqKlNvdXJjZSBPYmplY3QgKG9yIGVsZW1lbnQpOioqIEEgamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvblxuICAgKiBhYm91dCB0aGUgc291cmNlIGZpbGUuIFVzZSB0aGlzIG1ldGhvZCBpZiB5b3Ugd2FudCB0aGUgcGxheWVyIHRvIGRldGVybWluZSBpZlxuICAgKiBpdCBjYW4gc3VwcG9ydCB0aGUgZmlsZSB1c2luZyB0aGUgdHlwZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogICAgIG15UGxheWVyLnNyYyh7IHR5cGU6IFwidmlkZW8vbXA0XCIsIHNyYzogXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ubXA0XCIgfSk7XG4gICAqXG4gICAqICoqQXJyYXkgb2YgU291cmNlIE9iamVjdHM6KiogVG8gcHJvdmlkZSBtdWx0aXBsZSB2ZXJzaW9ucyBvZiB0aGUgc291cmNlIHNvXG4gICAqIHRoYXQgaXQgY2FuIGJlIHBsYXllZCB1c2luZyBIVE1MNSBhY3Jvc3MgYnJvd3NlcnMgeW91IGNhbiB1c2UgYW4gYXJyYXkgb2ZcbiAgICogc291cmNlIG9iamVjdHMuIFZpZGVvLmpzIHdpbGwgZGV0ZWN0IHdoaWNoIHZlcnNpb24gaXMgc3VwcG9ydGVkIGFuZCBsb2FkIHRoYXRcbiAgICogZmlsZS5cbiAgICpcbiAgICogICAgIG15UGxheWVyLnNyYyhbXG4gICAqICAgICAgIHsgdHlwZTogXCJ2aWRlby9tcDRcIiwgc3JjOiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vcGF0aC90by92aWRlby5tcDRcIiB9LFxuICAgKiAgICAgICB7IHR5cGU6IFwidmlkZW8vd2VibVwiLCBzcmM6IFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLndlYm1cIiB9LFxuICAgKiAgICAgICB7IHR5cGU6IFwidmlkZW8vb2dnXCIsIHNyYzogXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ub2d2XCIgfVxuICAgKiAgICAgXSk7XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R8QXJyYXk9fSBzb3VyY2UgVGhlIHNvdXJjZSBVUkwsIG9iamVjdCwgb3IgYXJyYXkgb2Ygc291cmNlc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjdXJyZW50IHZpZGVvIHNvdXJjZSB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgc3JjKHNvdXJjZT10aGlzLnRlY2hHZXQoJ3NyYycpKSB7XG4gICAgbGV0IGN1cnJlbnRUZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0aGlzLnRlY2hOYW1lKTtcblxuICAgIC8vIGNhc2U6IEFycmF5IG9mIHNvdXJjZSBvYmplY3RzIHRvIGNob29zZSBmcm9tIGFuZCBwaWNrIHRoZSBiZXN0IHRvIHBsYXlcbiAgICBpZiAoTGliLm9iai5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHRoaXMuc291cmNlTGlzdF8oc291cmNlKTtcblxuICAgIC8vIGNhc2U6IFVSTCBTdHJpbmcgKGh0dHA6Ly9teXZpZGVvLi4uKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIHNvdXJjZSBvYmplY3QgZnJvbSB0aGUgc3RyaW5nXG4gICAgICB0aGlzLnNyYyh7IHNyYzogc291cmNlIH0pO1xuXG4gICAgLy8gY2FzZTogU291cmNlIG9iamVjdCB7IHNyYzogJycsIHR5cGU6ICcnIC4uLiB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBzb3VyY2UgaGFzIGEgdHlwZSBhbmQgdGhlIGxvYWRlZCB0ZWNoIGNhbm5vdCBwbGF5IHRoZSBzb3VyY2VcbiAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gdHlwZSB3ZSdsbCBqdXN0IHRyeSB0aGUgY3VycmVudCB0ZWNoXG4gICAgICBpZiAoc291cmNlLnR5cGUgJiYgIWN1cnJlbnRUZWNoWydjYW5QbGF5U291cmNlJ10oc291cmNlKSkge1xuICAgICAgICAvLyBjcmVhdGUgYSBzb3VyY2UgbGlzdCB3aXRoIHRoZSBjdXJyZW50IHNvdXJjZSBhbmQgc2VuZCB0aHJvdWdoXG4gICAgICAgIC8vIHRoZSB0ZWNoIGxvb3AgdG8gY2hlY2sgZm9yIGEgY29tcGF0aWJsZSB0ZWNobm9sb2d5XG4gICAgICAgIHRoaXMuc291cmNlTGlzdF8oW3NvdXJjZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZV8uc3JjID0gc291cmNlLnNyYztcbiAgICAgICAgdGhpcy5jdXJyZW50VHlwZV8gPSBzb3VyY2UudHlwZSB8fCAnJztcblxuICAgICAgICAvLyB3YWl0IHVudGlsIHRoZSB0ZWNoIGlzIHJlYWR5IHRvIHNldCB0aGUgc291cmNlXG4gICAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24oKXtcblxuICAgICAgICAgIC8vIFRoZSBzZXRTb3VyY2UgdGVjaCBtZXRob2Qgd2FzIGFkZGVkIHdpdGggc291cmNlIGhhbmRsZXJzXG4gICAgICAgICAgLy8gc28gb2xkZXIgdGVjaHMgd29uJ3Qgc3VwcG9ydCBpdFxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgdGhlIGRpcmVjdCBwcm90b3R5cGUgZm9yIHRoZSBjYXNlIHdoZXJlIHN1YmNsYXNzZXNcbiAgICAgICAgICAvLyBvZiB0aGUgdGVjaCBkbyBub3Qgc3VwcG9ydCBzb3VyY2UgaGFuZGxlcnNcbiAgICAgICAgICBpZiAoY3VycmVudFRlY2gucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzZXRTb3VyY2UnKSkge1xuICAgICAgICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0U291cmNlJywgc291cmNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZWNoQ2FsbCgnc3JjJywgc291cmNlLnNyYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uc19bJ3ByZWxvYWQnXSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zX1snYXV0b3BsYXknXSkge1xuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gYXJyYXkgb2Ygc291cmNlIG9iamVjdHNcbiAgICogQHBhcmFtICB7W3R5cGVdfSBzb3VyY2VzIEFycmF5IG9mIHNvdXJjZSBvYmplY3RzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzb3VyY2VMaXN0Xyhzb3VyY2VzKSB7XG4gICAgdmFyIHNvdXJjZVRlY2ggPSB0aGlzLnNlbGVjdFNvdXJjZShzb3VyY2VzKTtcblxuICAgIGlmIChzb3VyY2VUZWNoKSB7XG4gICAgICBpZiAoc291cmNlVGVjaC50ZWNoID09PSB0aGlzLnRlY2hOYW1lKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgdGVjaG5vbG9neSBpcyBhbHJlYWR5IGxvYWRlZCwgc2V0IHRoZSBzb3VyY2VcbiAgICAgICAgdGhpcy5zcmMoc291cmNlVGVjaC5zb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbG9hZCB0aGlzIHRlY2hub2xvZ3kgd2l0aCB0aGUgY2hvc2VuIHNvdXJjZVxuICAgICAgICB0aGlzLmxvYWRUZWNoKHNvdXJjZVRlY2gudGVjaCwgc291cmNlVGVjaC5zb3VyY2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhIHRpbWVvdXQgdG8gZ2l2ZSBmb2xrcyBhIGNoYW5jZSB0byBhZGQgZXJyb3IgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHRoaXMuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9ucygpWydub3RTdXBwb3J0ZWRNZXNzYWdlJ10pIH0pO1xuICAgICAgfSwgMCk7XG5cbiAgICAgIC8vIHdlIGNvdWxkIG5vdCBmaW5kIGFuIGFwcHJvcHJpYXRlIHRlY2gsIGJ1dCBsZXQncyBzdGlsbCBub3RpZnkgdGhlIGRlbGVnYXRlIHRoYXQgdGhpcyBpcyBpdFxuICAgICAgLy8gdGhpcyBuZWVkcyBhIGJldHRlciBjb21tZW50IGFib3V0IHdoeSB0aGlzIGlzIG5lZWRlZFxuICAgICAgdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmVnaW4gbG9hZGluZyB0aGUgc3JjIGRhdGEuXG4gICAqIEByZXR1cm4ge1BsYXllcn0gUmV0dXJucyB0aGUgcGxheWVyXG4gICAqL1xuICBsb2FkKCkge1xuICAgIHRoaXMudGVjaENhbGwoJ2xvYWQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmdWxseSBxdWFsaWZpZWQgVVJMIG9mIHRoZSBjdXJyZW50IHNvdXJjZSB2YWx1ZSBlLmcuIGh0dHA6Ly9teXNpdGUuY29tL3ZpZGVvLm1wNFxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggYGN1cnJlbnRUeXBlYCB0byBhc3Npc3QgaW4gcmVidWlsZGluZyB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjdXJyZW50IHNvdXJjZVxuICAgKi9cbiAgY3VycmVudFNyYygpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCdjdXJyZW50U3JjJykgfHwgdGhpcy5jYWNoZV8uc3JjIHx8ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2UgdHlwZSBlLmcuIHZpZGVvL21wNFxuICAgKiBUaGlzIGNhbiBhbGxvdyB5b3UgcmVidWlsZCB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IHNvIHRoYXQgeW91IGNvdWxkIGxvYWQgdGhlIHNhbWVcbiAgICogc291cmNlIGFuZCB0ZWNoIGxhdGVyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHNvdXJjZSBNSU1FIHR5cGVcbiAgICovXG4gIGN1cnJlbnRUeXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFR5cGVfIHx8ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIHByZWxvYWQgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwcmVsb2FkIGF0dHJpYnV0ZSB2YWx1ZSB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSBSZXR1cm5zIHRoZSBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICAqL1xuICBwcmVsb2FkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGVjaENhbGwoJ3NldFByZWxvYWQnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfWydwcmVsb2FkJ10gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCdwcmVsb2FkJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgYXV0b3BsYXkgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBhdXRvcGxheSBhdHRyaWJ1dGUgdmFsdWUgd2hlbiBnZXR0aW5nXG4gICAqIEByZXR1cm4ge1BsYXllcn0gUmV0dXJucyB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgYXV0b3BsYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0QXV0b3BsYXknLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfWydhdXRvcGxheSddID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldCgnYXV0b3BsYXknLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgbG9vcCBhdHRyaWJ1dGUgb24gdGhlIHZpZGVvIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGxvb3AgYXR0cmlidXRlIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IFJldHVybnMgdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICovXG4gIGxvb3AodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0TG9vcCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc19bJ2xvb3AnXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXQoJ2xvb3AnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgb3Igc2V0IHRoZSBwb3N0ZXIgaW1hZ2Ugc291cmNlIHVybFxuICAgKlxuICAgKiAjIyMjIyBFWEFNUExFOlxuICAgKlxuICAgKiAgICAgLy8gZ2V0dGluZ1xuICAgKiAgICAgdmFyIGN1cnJlbnRQb3N0ZXIgPSBteVBsYXllci5wb3N0ZXIoKTtcbiAgICpcbiAgICogICAgIC8vIHNldHRpbmdcbiAgICogICAgIG15UGxheWVyLnBvc3RlcignaHR0cDovL2V4YW1wbGUuY29tL215SW1hZ2UuanBnJyk7XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZz19IFtzcmNdIFBvc3RlciBpbWFnZSBzb3VyY2UgVVJMXG4gICAqIEByZXR1cm4ge1N0cmluZ30gcG9zdGVyIFVSTCB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgcG9zdGVyKHNyYykge1xuICAgIGlmIChzcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zdGVyXztcbiAgICB9XG5cbiAgICAvLyBUaGUgY29ycmVjdCB3YXkgdG8gcmVtb3ZlIGEgcG9zdGVyIGlzIHRvIHNldCBhcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAvLyBvdGhlciBmYWxzZXkgdmFsdWVzIHdpbGwgdGhyb3cgZXJyb3JzXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHNyYyA9ICcnO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgaW50ZXJuYWwgcG9zdGVyIHZhcmlhYmxlXG4gICAgdGhpcy5wb3N0ZXJfID0gc3JjO1xuXG4gICAgLy8gdXBkYXRlIHRoZSB0ZWNoJ3MgcG9zdGVyXG4gICAgdGhpcy50ZWNoQ2FsbCgnc2V0UG9zdGVyJywgc3JjKTtcblxuICAgIC8vIGFsZXJ0IGNvbXBvbmVudHMgdGhhdCB0aGUgcG9zdGVyIGhhcyBiZWVuIHNldFxuICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9scyBhcmUgc2hvd2luZy5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY29udHJvbHMgU2V0IGNvbnRyb2xzIHRvIHNob3dpbmcgb3Igbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIENvbnRyb2xzIGFyZSBzaG93aW5nXG4gICAqL1xuICBjb250cm9scyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDsgLy8gZm9yY2UgYm9vbGVhblxuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgaWYgKHRoaXMuY29udHJvbHNfICE9PSBib29sKSB7XG4gICAgICAgIHRoaXMuY29udHJvbHNfID0gYm9vbDtcblxuICAgICAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgICAgICB0aGlzLnRlY2hDYWxsKCdzZXRDb250cm9scycsIGJvb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY29udHJvbHNlbmFibGVkJyk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRlY2hDb250cm9sc0xpc3RlbmVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY29udHJvbHNkaXNhYmxlZCcpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmNvbnRyb2xzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgbmF0aXZlIGNvbnRyb2xzIG9uL29mZi4gTmF0aXZlIGNvbnRyb2xzIGFyZSB0aGUgY29udHJvbHMgYnVpbHQgaW50b1xuICAgKiBkZXZpY2VzIChlLmcuIGRlZmF1bHQgaVBob25lIGNvbnRyb2xzKSwgRmxhc2gsIG9yIG90aGVyIHRlY2hzXG4gICAqIChlLmcuIFZpbWVvIENvbnRyb2xzKVxuICAgKlxuICAgKiAqKlRoaXMgc2hvdWxkIG9ubHkgYmUgc2V0IGJ5IHRoZSBjdXJyZW50IHRlY2gsIGJlY2F1c2Ugb25seSB0aGUgdGVjaCBrbm93c1xuICAgKiBpZiBpdCBjYW4gc3VwcG9ydCBuYXRpdmUgY29udHJvbHMqKlxuICAgKlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBib29sICAgIFRydWUgc2lnbmFscyB0aGF0IG5hdGl2ZSBjb250cm9scyBhcmUgb25cbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgIFJldHVybnMgdGhlIHBsYXllclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXNpbmdOYXRpdmVDb250cm9scyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDsgLy8gZm9yY2UgYm9vbGVhblxuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgaWYgKHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18gIT09IGJvb2wpIHtcbiAgICAgICAgdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyA9IGJvb2w7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBuYXRpdmUgZGV2aWNlIGNvbnRyb2xzXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAZXZlbnQgdXNpbmduYXRpdmVjb250cm9sc1xuICAgICAgICAgICAqIEBtZW1iZXJvZiBQbGF5ZXJcbiAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXNpbmduYXRpdmVjb250cm9scycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2luZy1uYXRpdmUtY29udHJvbHMnKTtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIHBsYXllciBpcyB1c2luZyB0aGUgY3VzdG9tIEhUTUwgY29udHJvbHNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBldmVudCB1c2luZ2N1c3RvbWNvbnRyb2xzXG4gICAgICAgICAgICogQG1lbWJlcm9mIFBsYXllclxuICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ2N1c3RvbWNvbnRyb2xzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvciBnZXQgdGhlIGN1cnJlbnQgTWVkaWFFcnJvclxuICAgKiBAcGFyYW0gIHsqfSBlcnIgQSBNZWRpYUVycm9yIG9yIGEgU3RyaW5nL051bWJlciB0byBiZSB0dXJuZWQgaW50byBhIE1lZGlhRXJyb3JcbiAgICogQHJldHVybiB7TWVkaWFFcnJvcnxudWxsfSAgICAgd2hlbiBnZXR0aW5nXG4gICAqIEByZXR1cm4ge1BsYXllcn0gICAgICAgICAgICAgIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcl8gfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JpbmcgdG8gZGVmYXVsdFxuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVycm9yJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBlcnJvciBpbnN0YW5jZVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBNZWRpYUVycm9yKSB7XG4gICAgICB0aGlzLmVycm9yXyA9IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcnJvcl8gPSBuZXcgTWVkaWFFcnJvcihlcnIpO1xuICAgIH1cblxuICAgIC8vIGZpcmUgYW4gZXJyb3IgZXZlbnQgb24gdGhlIHBsYXllclxuICAgIHRoaXMudHJpZ2dlcignZXJyb3InKTtcblxuICAgIC8vIGFkZCB0aGUgdmpzLWVycm9yIGNsYXNzbmFtZSB0byB0aGUgcGxheWVyXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVycm9yJyk7XG5cbiAgICAvLyBsb2cgdGhlIG5hbWUgb2YgdGhlIGVycm9yIHR5cGUgYW5kIGFueSBtZXNzYWdlXG4gICAgLy8gaWU4IGp1c3QgbG9ncyBcIltvYmplY3Qgb2JqZWN0XVwiIGlmIHlvdSBqdXN0IGxvZyB0aGUgZXJyb3Igb2JqZWN0XG4gICAgTGliLmxvZy5lcnJvcihgKENPREU6JHt0aGlzLmVycm9yXy5jb2RlfSAke01lZGlhRXJyb3IuZXJyb3JUeXBlc1t0aGlzLmVycm9yXy5jb2RlXX0pYCwgdGhpcy5lcnJvcl8ubWVzc2FnZSwgdGhpcy5lcnJvcl8pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcImVuZGVkXCIgc3RhdGUuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBsYXllciBpcyBpbiB0aGUgZW5kZWQgc3RhdGUsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGVuZGVkKCkgeyByZXR1cm4gdGhpcy50ZWNoR2V0KCdlbmRlZCcpOyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsYXllciBpcyBpbiB0aGUgXCJzZWVraW5nXCIgc3RhdGUuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBsYXllciBpcyBpbiB0aGUgc2Vla2luZyBzdGF0ZSwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgc2Vla2luZygpIHsgcmV0dXJuIHRoaXMudGVjaEdldCgnc2Vla2luZycpOyB9XG5cbiAgcmVwb3J0VXNlckFjdGl2aXR5KGV2ZW50KSB7XG4gICAgdGhpcy51c2VyQWN0aXZpdHlfID0gdHJ1ZTtcbiAgfVxuXG4gIHVzZXJBY3RpdmUoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJvb2wgPSAhIWJvb2w7XG4gICAgICBpZiAoYm9vbCAhPT0gdGhpcy51c2VyQWN0aXZlXykge1xuICAgICAgICB0aGlzLnVzZXJBY3RpdmVfID0gYm9vbDtcbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgdXNlciB3YXMgaW5hY3RpdmUgYW5kIGlzIG5vdyBhY3RpdmUgd2Ugd2FudCB0byByZXNldCB0aGVcbiAgICAgICAgICAvLyBpbmFjdGl2aXR5IHRpbWVyXG4gICAgICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtdXNlci1pbmFjdGl2ZScpO1xuICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy11c2VyLWFjdGl2ZScpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXNlcmFjdGl2ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlJ3JlIHN3aXRjaGluZyB0aGUgc3RhdGUgdG8gaW5hY3RpdmUgbWFudWFsbHksIHNvIGVyYXNlIGFueSBvdGhlclxuICAgICAgICAgIC8vIGFjdGl2aXR5XG4gICAgICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBDaHJvbWUvU2FmYXJpL0lFIGhhdmUgYnVncyB3aGVyZSB3aGVuIHlvdSBjaGFuZ2UgdGhlIGN1cnNvciBpdCBjYW5cbiAgICAgICAgICAvLyB0cmlnZ2VyIGEgbW91c2Vtb3ZlIGV2ZW50LiBUaGlzIGNhdXNlcyBhbiBpc3N1ZSB3aGVuIHlvdSdyZSBoaWRpbmdcbiAgICAgICAgICAvLyB0aGUgY3Vyc29yIHdoZW4gdGhlIHVzZXIgaXMgaW5hY3RpdmUsIGFuZCBhIG1vdXNlbW92ZSBzaWduYWxzIHVzZXJcbiAgICAgICAgICAvLyBhY3Rpdml0eS4gTWFraW5nIGl0IGltcG9zc2libGUgdG8gZ28gaW50byBpbmFjdGl2ZSBtb2RlLiBTcGVjaWZpY2FsbHlcbiAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaW4gZnVsbHNjcmVlbiB3aGVuIHdlIHJlYWxseSBuZWVkIHRvIGhpZGUgdGhlIGN1cnNvci5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdoZW4gdGhpcyBnZXRzIHJlc29sdmVkIGluIEFMTCBicm93c2VycyBpdCBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDMwNDFcbiAgICAgICAgICBpZih0aGlzLnRlY2gpIHtcbiAgICAgICAgICAgIHRoaXMudGVjaC5vbmUoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtdXNlci1hY3RpdmUnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNlci1pbmFjdGl2ZScpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXNlcmluYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51c2VyQWN0aXZlXztcbiAgfVxuXG4gIGxpc3RlbkZvclVzZXJBY3Rpdml0eSgpIHtcbiAgICBsZXQgbW91c2VJblByb2dyZXNzLCBsYXN0TW92ZVgsIGxhc3RNb3ZlWTtcblxuICAgIGxldCBoYW5kbGVBY3Rpdml0eSA9IExpYi5iaW5kKHRoaXMsIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KTtcblxuICAgIGxldCBoYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAvLyAjMTA2OCAtIFByZXZlbnQgbW91c2Vtb3ZlIHNwYW1taW5nXG4gICAgICAvLyBDaHJvbWUgQnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzY2OTcwXG4gICAgICBpZihlLnNjcmVlblggIT09IGxhc3RNb3ZlWCB8fCBlLnNjcmVlblkgIT09IGxhc3RNb3ZlWSkge1xuICAgICAgICBsYXN0TW92ZVggPSBlLnNjcmVlblg7XG4gICAgICAgIGxhc3RNb3ZlWSA9IGUuc2NyZWVuWTtcbiAgICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIC8vIEZvciBhcyBsb25nIGFzIHRoZSB0aGV5IGFyZSB0b3VjaGluZyB0aGUgZGV2aWNlIG9yIGhhdmUgdGhlaXIgbW91c2UgZG93bixcbiAgICAgIC8vIHdlIGNvbnNpZGVyIHRoZW0gYWN0aXZlIGV2ZW4gaWYgdGhleSdyZSBub3QgbW92aW5nIHRoZWlyIGZpbmdlciBvciBtb3VzZS5cbiAgICAgIC8vIFNvIHdlIHdhbnQgdG8gY29udGludWUgdG8gdXBkYXRlIHRoYXQgdGhleSBhcmUgYWN0aXZlXG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwobW91c2VJblByb2dyZXNzKTtcbiAgICAgIC8vIFNldHRpbmcgdXNlckFjdGl2aXR5PXRydWUgbm93IGFuZCBzZXR0aW5nIHRoZSBpbnRlcnZhbCB0byB0aGUgc2FtZSB0aW1lXG4gICAgICAvLyBhcyB0aGUgYWN0aXZpdHlDaGVjayBpbnRlcnZhbCAoMjUwKSBzaG91bGQgZW5zdXJlIHdlIG5ldmVyIG1pc3MgdGhlXG4gICAgICAvLyBuZXh0IGFjdGl2aXR5Q2hlY2tcbiAgICAgIG1vdXNlSW5Qcm9ncmVzcyA9IHRoaXMuc2V0SW50ZXJ2YWwoaGFuZGxlQWN0aXZpdHksIDI1MCk7XG4gICAgfTtcblxuICAgIGxldCBoYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBTdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgbW91c2UvdG91Y2ggaXMgZG93blxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgfTtcblxuICAgIC8vIEFueSBtb3VzZSBtb3ZlbWVudCB3aWxsIGJlIGNvbnNpZGVyZWQgdXNlciBhY3Rpdml0eVxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCk7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAvLyBTaG91bGRuJ3QgbmVlZCB0byB1c2UgaW5Qcm9ncmVzcyBpbnRlcnZhbCBiZWNhdXNlIG9mIGtleSByZXBlYXRcbiAgICB0aGlzLm9uKCdrZXlkb3duJywgaGFuZGxlQWN0aXZpdHkpO1xuICAgIHRoaXMub24oJ2tleXVwJywgaGFuZGxlQWN0aXZpdHkpO1xuXG4gICAgLy8gUnVuIGFuIGludGVydmFsIGV2ZXJ5IDI1MCBtaWxsaXNlY29uZHMgaW5zdGVhZCBvZiBzdHVmZmluZyBldmVyeXRoaW5nIGludG9cbiAgICAvLyB0aGUgbW91c2Vtb3ZlL3RvdWNobW92ZSBmdW5jdGlvbiBpdHNlbGYsIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uXG4gICAgLy8gYHRoaXMucmVwb3J0VXNlckFjdGl2aXR5YCBzaW1wbHkgc2V0cyB0aGlzLnVzZXJBY3Rpdml0eV8gdG8gdHJ1ZSwgd2hpY2hcbiAgICAvLyB0aGVuIGdldHMgcGlja2VkIHVwIGJ5IHRoaXMgbG9vcFxuICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9sZWFybmluZy1mcm9tLXR3aXR0ZXIvXG4gICAgbGV0IGFjdGl2aXR5Q2hlY2sgPSB0aGlzLnNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGluYWN0aXZpdHlUaW1lb3V0O1xuXG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgbW91c2UvdG91Y2ggYWN0aXZpdHkgaGFzIGhhcHBlbmVkXG4gICAgICBpZiAodGhpcy51c2VyQWN0aXZpdHlfKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBhY3Rpdml0eSB0cmFja2VyXG4gICAgICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHN0YXRlIHdhcyBpbmFjdGl2ZSwgc2V0IHRoZSBzdGF0ZSB0byBhY3RpdmVcbiAgICAgICAgdGhpcy51c2VyQWN0aXZlKHRydWUpO1xuXG4gICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBpbmFjdGl2aXR5IHRpbWVvdXQgdG8gc3RhcnQgdGhlIHRpbWVyIG92ZXJcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoaW5hY3Rpdml0eVRpbWVvdXQpO1xuXG4gICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5vcHRpb25zKClbJ2luYWN0aXZpdHlUaW1lb3V0J107XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgIC8vIEluIDx0aW1lb3V0PiBtaWxsaXNlY29uZHMsIGlmIG5vIG1vcmUgYWN0aXZpdHkgaGFzIG9jY3VycmVkIHRoZVxuICAgICAgICAgIC8vIHVzZXIgd2lsbCBiZSBjb25zaWRlcmVkIGluYWN0aXZlXG4gICAgICAgICAgaW5hY3Rpdml0eVRpbWVvdXQgPSB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIHRoZSBpbmFjdGl2aXR5VGltZW91dCBjYW4gdHJpZ2dlciBqdXN0XG4gICAgICAgICAgICAvLyBiZWZvcmUgdGhlIG5leHQgdXNlciBhY3Rpdml0eSBpcyBwaWNrZWQgdXAgYnkgdGhlIGFjdGl2aXR5Q2hlY2sgbG9vcFxuICAgICAgICAgICAgLy8gY2F1c2luZyBhIGZsaWNrZXJcbiAgICAgICAgICAgIGlmICghdGhpcy51c2VyQWN0aXZpdHlfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDI1MCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUuICBBIHBsYXliYWNrIHJhdGUgb2ZcbiAgICogMS4wIHJlcHJlc2VudHMgbm9ybWFsIHNwZWVkIGFuZCAwLjUgd291bGQgaW5kaWNhdGUgaGFsZi1zcGVlZFxuICAgKiBwbGF5YmFjaywgZm9yIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHJhdGUgICAgTmV3IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgUmV0dXJucyB0aGUgbmV3IHBsYXliYWNrIHJhdGUgd2hlbiBzZXR0aW5nXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUgd2hlbiBnZXR0aW5nXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGVcbiAgICovXG4gIHBsYXliYWNrUmF0ZShyYXRlKSB7XG4gICAgaWYgKHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbCgnc2V0UGxheWJhY2tSYXRlJywgcmF0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZWNoICYmIHRoaXMudGVjaFsnZmVhdHVyZXNQbGF5YmFja1JhdGUnXSkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaEdldCgncGxheWJhY2tSYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxLjA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgYXVkaW8gZmxhZ1xuICAgKlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBib29sICAgIFRydWUgc2lnbmFscyB0aGF0IHRoaXMgaXMgYW4gYXVkaW8gcGxheWVyLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgIFJldHVybnMgdHJ1ZSBpZiBwbGF5ZXIgaXMgYXVkaW8sIGZhbHNlIGlmIG5vdCB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgIFJldHVybnMgdGhlIHBsYXllciBpZiBzZXR0aW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0F1ZGlvKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmlzQXVkaW9fID0gISFib29sO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhdGhpcy5pc0F1ZGlvXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIG5ldHdvcmsgYWN0aXZpdHkgZm9yIHRoZSBlbGVtZW50LCBmcm9tXG4gICAqIHRoZSBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cbiAgICogLSBORVRXT1JLX0VNUFRZIChudW1lcmljIHZhbHVlIDApXG4gICAqICAgVGhlIGVsZW1lbnQgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXNlZC4gQWxsIGF0dHJpYnV0ZXMgYXJlIGluXG4gICAqICAgdGhlaXIgaW5pdGlhbCBzdGF0ZXMuXG4gICAqIC0gTkVUV09SS19JRExFIChudW1lcmljIHZhbHVlIDEpXG4gICAqICAgVGhlIGVsZW1lbnQncyByZXNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtIGlzIGFjdGl2ZSBhbmQgaGFzXG4gICAqICAgc2VsZWN0ZWQgYSByZXNvdXJjZSwgYnV0IGl0IGlzIG5vdCBhY3R1YWxseSB1c2luZyB0aGUgbmV0d29yayBhdFxuICAgKiAgIHRoaXMgdGltZS5cbiAgICogLSBORVRXT1JLX0xPQURJTkcgKG51bWVyaWMgdmFsdWUgMilcbiAgICogICBUaGUgdXNlciBhZ2VudCBpcyBhY3RpdmVseSB0cnlpbmcgdG8gZG93bmxvYWQgZGF0YS5cbiAgICogLSBORVRXT1JLX05PX1NPVVJDRSAobnVtZXJpYyB2YWx1ZSAzKVxuICAgKiAgIFRoZSBlbGVtZW50J3MgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBpcyBhY3RpdmUsIGJ1dCBpdCBoYXNcbiAgICogICBub3QgeWV0IGZvdW5kIGEgcmVzb3VyY2UgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjdXJyZW50IG5ldHdvcmsgYWN0aXZpdHkgc3RhdGVcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjbmV0d29yay1zdGF0ZXNcbiAgICovXG4gIG5ldHdvcmtTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0KCduZXR3b3JrU3RhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBleHByZXNzZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAgICogd2l0aCByZXNwZWN0IHRvIHJlbmRlcmluZyB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiwgZnJvbSB0aGVcbiAgICogY29kZXMgaW4gdGhlIGxpc3QgYmVsb3cuXG4gICAqIC0gSEFWRV9OT1RISU5HIChudW1lcmljIHZhbHVlIDApXG4gICAqICAgTm8gaW5mb3JtYXRpb24gcmVnYXJkaW5nIHRoZSBtZWRpYSByZXNvdXJjZSBpcyBhdmFpbGFibGUuXG4gICAqIC0gSEFWRV9NRVRBREFUQSAobnVtZXJpYyB2YWx1ZSAxKVxuICAgKiAgIEVub3VnaCBvZiB0aGUgcmVzb3VyY2UgaGFzIGJlZW4gb2J0YWluZWQgdGhhdCB0aGUgZHVyYXRpb24gb2YgdGhlXG4gICAqICAgcmVzb3VyY2UgaXMgYXZhaWxhYmxlLlxuICAgKiAtIEhBVkVfQ1VSUkVOVF9EQVRBIChudW1lcmljIHZhbHVlIDIpXG4gICAqICAgRGF0YSBmb3IgdGhlIGltbWVkaWF0ZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZS5cbiAgICogLSBIQVZFX0ZVVFVSRV9EQVRBIChudW1lcmljIHZhbHVlIDMpXG4gICAqICAgRGF0YSBmb3IgdGhlIGltbWVkaWF0ZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZSwgYXNcbiAgICogICB3ZWxsIGFzIGVub3VnaCBkYXRhIGZvciB0aGUgdXNlciBhZ2VudCB0byBhZHZhbmNlIHRoZSBjdXJyZW50XG4gICAqICAgcGxheWJhY2sgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBvZiBwbGF5YmFjay5cbiAgICogLSBIQVZFX0VOT1VHSF9EQVRBIChudW1lcmljIHZhbHVlIDQpXG4gICAqICAgVGhlIHVzZXIgYWdlbnQgZXN0aW1hdGVzIHRoYXQgZW5vdWdoIGRhdGEgaXMgYXZhaWxhYmxlIGZvclxuICAgKiAgIHBsYXliYWNrIHRvIHByb2NlZWQgdW5pbnRlcnJ1cHRlZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgY3VycmVudCBwbGF5YmFjayByZW5kZXJpbmcgc3RhdGVcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXJlYWR5c3RhdGVcbiAgICovXG4gIHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldCgncmVhZHlTdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRleHQgdHJhY2tzIGFyZSB0cmFja3Mgb2YgdGltZWQgdGV4dCBldmVudHMuXG4gICAqIENhcHRpb25zIC0gdGV4dCBkaXNwbGF5ZWQgb3ZlciB0aGUgdmlkZW8gZm9yIHRoZSBoZWFyaW5nIGltcGFpcmVkXG4gICAqIFN1YnRpdGxlcyAtIHRleHQgZGlzcGxheWVkIG92ZXIgdGhlIHZpZGVvIGZvciB0aG9zZSB3aG8gZG9uJ3QgdW5kZXJzdGFuZCBsYW5ndWFnZSBpbiB0aGUgdmlkZW9cbiAgICogQ2hhcHRlcnMgLSB0ZXh0IGRpc3BsYXllZCBpbiBhIG1lbnUgYWxsb3dpbmcgdGhlIHVzZXIgdG8ganVtcCB0byBwYXJ0aWN1bGFyIHBvaW50cyAoY2hhcHRlcnMpIGluIHRoZSB2aWRlb1xuICAgKiBEZXNjcmlwdGlvbnMgKG5vdCBzdXBwb3J0ZWQgeWV0KSAtIGF1ZGlvIGRlc2NyaXB0aW9ucyB0aGF0IGFyZSByZWFkIGJhY2sgdG8gdGhlIHVzZXIgYnkgYSBzY3JlZW4gcmVhZGluZyBkZXZpY2VcbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiBhc3NvY2lhdGVkIHRleHQgdHJhY2tzLiBjYXB0aW9ucywgc3VidGl0bGVzLCBjaGFwdGVycywgZGVzY3JpcHRpb25zXG4gICAqIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS10ZXh0dHJhY2tzXG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgQXJyYXkgb2YgdHJhY2sgb2JqZWN0c1xuICAgKi9cbiAgdGV4dFRyYWNrcygpIHtcbiAgICAvLyBjYW5ub3QgdXNlIHRlY2hHZXQgZGlyZWN0bHkgYmVjYXVzZSBpdCBjaGVja3MgdG8gc2VlIHdoZXRoZXIgdGhlIHRlY2ggaXMgcmVhZHkuXG4gICAgLy8gRmxhc2ggaXMgdW5saWtlbHkgdG8gYmUgcmVhZHkgaW4gdGltZSBidXQgdGV4dFRyYWNrcyBzaG91bGQgc3RpbGwgd29yay5cbiAgICByZXR1cm4gdGhpcy50ZWNoICYmIHRoaXMudGVjaFsndGV4dFRyYWNrcyddKCk7XG4gIH1cblxuICByZW1vdGVUZXh0VHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2ggJiYgdGhpcy50ZWNoWydyZW1vdGVUZXh0VHJhY2tzJ10oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0ZXh0IHRyYWNrXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoZSBXM0Mgc2V0dGluZ3Mgd2UgYWxsb3cgYWRkaW5nIGFkZGl0aW9uYWwgaW5mbyB0aHJvdWdoIG9wdGlvbnMuXG4gICAqIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1hZGR0ZXh0dHJhY2tcbiAgICogQHBhcmFtIHtTdHJpbmd9ICBraW5kICAgICAgICBDYXB0aW9ucywgc3VidGl0bGVzLCBjaGFwdGVycywgZGVzY3JpcHRpb25zLCBvciBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZz19IGxhYmVsICAgICAgIE9wdGlvbmFsIGxhYmVsXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbGFuZ3VhZ2UgICAgT3B0aW9uYWwgbGFuZ3VhZ2VcbiAgICovXG4gIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoICYmIHRoaXMudGVjaFsnYWRkVGV4dFRyYWNrJ10oa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfVxuXG4gIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaCAmJiB0aGlzLnRlY2hbJ2FkZFJlbW90ZVRleHRUcmFjayddKG9wdGlvbnMpO1xuICB9XG5cbiAgcmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKSB7XG4gICAgdGhpcy50ZWNoICYmIHRoaXMudGVjaFsncmVtb3ZlUmVtb3RlVGV4dFRyYWNrJ10odHJhY2spO1xuICB9XG5cbiAgLy8gTWV0aG9kcyB0byBhZGQgc3VwcG9ydCBmb3JcbiAgLy8gaW5pdGlhbFRpbWU6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCdpbml0aWFsVGltZScpOyB9LFxuICAvLyBzdGFydE9mZnNldFRpbWU6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCdzdGFydE9mZnNldFRpbWUnKTsgfSxcbiAgLy8gcGxheWVkOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgncGxheWVkJyk7IH0sXG4gIC8vIHNlZWthYmxlOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgnc2Vla2FibGUnKTsgfSxcbiAgLy8gdmlkZW9UcmFja3M6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCd2aWRlb1RyYWNrcycpOyB9LFxuICAvLyBhdWRpb1RyYWNrczogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ2F1ZGlvVHJhY2tzJyk7IH0sXG4gIC8vIHZpZGVvV2lkdGg6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsKCd2aWRlb1dpZHRoJyk7IH0sXG4gIC8vIHZpZGVvSGVpZ2h0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgndmlkZW9IZWlnaHQnKTsgfSxcbiAgLy8gZGVmYXVsdFBsYXliYWNrUmF0ZTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ2RlZmF1bHRQbGF5YmFja1JhdGUnKTsgfSxcbiAgLy8gbWVkaWFHcm91cDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ21lZGlhR3JvdXAnKTsgfSxcbiAgLy8gY29udHJvbGxlcjogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGwoJ2NvbnRyb2xsZXInKTsgfSxcbiAgLy8gZGVmYXVsdE11dGVkOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZWNoQ2FsbCgnZGVmYXVsdE11dGVkJyk7IH1cblxuICAvLyBUT0RPXG4gIC8vIGN1cnJlbnRTcmNMaXN0OiB0aGUgYXJyYXkgb2Ygc291cmNlcyBpbmNsdWRpbmcgb3RoZXIgZm9ybWF0cyBhbmQgYml0cmF0ZXNcbiAgLy8gcGxheUxpc3Q6IGFycmF5IG9mIHNvdXJjZSBsaXN0cyBpbiBvcmRlciBvZiBwbGF5YmFja1xuXG4gIC8qKlxuICAgKiBUaGUgcGxheWVyJ3MgbGFuZ3VhZ2UgY29kZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGxhbmd1YWdlQ29kZSAgVGhlIGxvY2FsZSBzdHJpbmdcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICBUaGUgbG9jYWxlIHN0cmluZyB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgICAgIHNlbGYsIHdoZW4gc2V0dGluZ1xuICAgKi9cbiAgbGFuZ3VhZ2UobGFuZ3VhZ2VDb2RlKSB7XG4gICAgaWYgKGxhbmd1YWdlQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZV87XG4gICAgfVxuXG4gICAgdGhpcy5sYW5ndWFnZV8gPSBsYW5ndWFnZUNvZGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwbGF5ZXIncyBsYW5ndWFnZSBkaWN0aW9uYXJ5XG4gICAqL1xuICBsYW5ndWFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VzXztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IExpYi5vYmouZGVlcE1lcmdlKHt9LCB0aGlzLm9wdGlvbnMoKSk7XG4gICAgbGV0IHRyYWNrcyA9IG9wdGlvbnMudHJhY2tzO1xuXG4gICAgb3B0aW9ucy50cmFja3MgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIC8vIGRlZXAgbWVyZ2UgdHJhY2tzIGFuZCBudWxsIG91dCBwbGF5ZXIgc28gbm8gY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgdHJhY2sgPSBMaWIub2JqLmRlZXBNZXJnZSh7fSwgdHJhY2spO1xuICAgICAgdHJhY2sucGxheWVyID0gdW5kZWZpbmVkO1xuICAgICAgb3B0aW9ucy50cmFja3NbaV0gPSB0cmFjaztcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIHN0YXRpYyBnZXRUYWdTZXR0aW5ncyh0YWcpIHtcbiAgICBsZXQgYmFzZU9wdGlvbnMgPSB7XG4gICAgICAnc291cmNlcyc6IFtdLFxuICAgICAgJ3RyYWNrcyc6IFtdXG4gICAgfTtcblxuICAgIGNvbnN0IHRhZ09wdGlvbnMgPSBMaWIuZ2V0RWxlbWVudEF0dHJpYnV0ZXModGFnKTtcbiAgICBjb25zdCBkYXRhU2V0dXAgPSB0YWdPcHRpb25zWydkYXRhLXNldHVwJ107XG5cbiAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgIGlmIChkYXRhU2V0dXAgIT09IG51bGwpe1xuICAgICAgLy8gUGFyc2Ugb3B0aW9ucyBKU09OXG4gICAgICAvLyBJZiBlbXB0eSBzdHJpbmcsIG1ha2UgaXQgYSBwYXJzYWJsZSBqc29uIG9iamVjdC5cbiAgICAgIGNvbnN0IFtlcnIsIGRhdGFdID0gc2FmZVBhcnNlVHVwbGUoZGF0YVNldHVwIHx8ICd7fScpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBMaWIubG9nLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgICBMaWIub2JqLm1lcmdlKHRhZ09wdGlvbnMsIGRhdGEpO1xuICAgIH1cblxuICAgIExpYi5vYmoubWVyZ2UoYmFzZU9wdGlvbnMsIHRhZ09wdGlvbnMpO1xuXG4gICAgLy8gR2V0IHRhZyBjaGlsZHJlbiBzZXR0aW5nc1xuICAgIGlmICh0YWcuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRhZy5jaGlsZE5vZGVzO1xuXG4gICAgICBmb3IgKGxldCBpPTAsIGo9Y2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyBDaGFuZ2UgY2FzZSBuZWVkZWQ6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9ub2RlbmFtZS1jYXNlLXNlbnNpdGl2aXR5L1xuICAgICAgICBjb25zdCBjaGlsZE5hbWUgPSBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnc291cmNlJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zWydzb3VyY2VzJ10ucHVzaChMaWIuZ2V0RWxlbWVudEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZE5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBiYXNlT3B0aW9uc1sndHJhY2tzJ10ucHVzaChMaWIuZ2V0RWxlbWVudEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3B0aW9ucztcbiAgfVxuXG59XG5cbi8qKlxuICogR2xvYmFsIHBsYXllciBsaXN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5QbGF5ZXIucGxheWVycyA9IHt9O1xuXG4vKipcbiAqIFBsYXllciBpbnN0YW5jZSBvcHRpb25zLCBzdXJmYWNlZCB1c2luZyBvcHRpb25zXG4gKiBvcHRpb25zID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zX1xuICogTWFrZSBjaGFuZ2VzIGluIG9wdGlvbnMsIG5vdCBoZXJlLlxuICogQWxsIG9wdGlvbnMgc2hvdWxkIHVzZSBzdHJpbmcga2V5cyBzbyB0aGV5IGF2b2lkXG4gKiByZW5hbWluZyBieSBjbG9zdXJlIGNvbXBpbGVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXyA9IE9wdGlvbnM7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBpbml0aWFsIGR1cmF0aW9uIGFuZCBkaW1lbnNpb24gaW5mb3JtYXRpb25cbiAqIEBldmVudCBsb2FkZWRtZXRhZGF0YVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZUxvYWRlZE1ldGFEYXRhO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZG93bmxvYWRlZCBkYXRhIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gKiBAZXZlbnQgbG9hZGVkZGF0YVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZUxvYWRlZERhdGE7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBmaW5pc2hlZCBkb3dubG9hZGluZyB0aGUgc291cmNlIGRhdGFcbiAqIEBldmVudCBsb2FkZWRhbGxkYXRhXG4gKi9cblBsYXllci5wcm90b3R5cGUuaGFuZGxlTG9hZGVkQWxsRGF0YTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGlzIGFjdGl2ZSwgZS5nLiBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgcGxheWVyXG4gKiBAZXZlbnQgdXNlcmFjdGl2ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZVVzZXJBY3RpdmU7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdXNlciBpcyBpbmFjdGl2ZSwgZS5nLiBhIHNob3J0IGRlbGF5IGFmdGVyIHRoZSBsYXN0IG1vdXNlIG1vdmUgb3IgY29udHJvbCBpbnRlcmFjdGlvblxuICogQGV2ZW50IHVzZXJpbmFjdGl2ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZVVzZXJJbmFjdGl2ZTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG4gKlxuICogRHVyaW5nIHBsYXliYWNrIHRoaXMgaXMgZmlyZWQgZXZlcnkgMTUtMjUwIG1pbGxpc2Vjb25kcywgZGVwZW5kaW5nIG9uIHRoZVxuICogcGxheWJhY2sgdGVjaG5vbG9neSBpbiB1c2UuXG4gKiBAZXZlbnQgdGltZXVwZGF0ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRpbWVVcGRhdGU7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdm9sdW1lIGNoYW5nZXNcbiAqIEBldmVudCB2b2x1bWVjaGFuZ2VcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5oYW5kbGVWb2x1bWVDaGFuZ2U7XG5cbi8qKlxuICogRmlyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnNcbiAqIEBldmVudCBlcnJvclxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZUVycm9yO1xuXG5QbGF5ZXIucHJvdG90eXBlLmZsZXhOb3RTdXBwb3J0ZWRfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuXG4gIHJldHVybiAhKCdmbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHxcbiAgICAgICAgICAnd2Via2l0RmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8XG4gICAgICAgICAgJ21vekZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fFxuICAgICAgICAgICdtc0ZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSk7XG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXllcicsIFBsYXllcik7XG5leHBvcnQgZGVmYXVsdCBQbGF5ZXI7XG4iLCJpbXBvcnQgUGxheWVyIGZyb20gJy4vcGxheWVyJztcblxuLyoqXG4gKiB0aGUgbWV0aG9kIGZvciByZWdpc3RlcmluZyBhIHZpZGVvLmpzIHBsdWdpblxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gaW5pdCBUaGUgZnVuY3Rpb24gdGhhdCBpcyBydW4gd2hlbiB0aGUgcGxheWVyIGluaXRzXG4gKi9cbnZhciBwbHVnaW4gPSBmdW5jdGlvbihuYW1lLCBpbml0KXtcbiAgUGxheWVyLnByb3RvdHlwZVtuYW1lXSA9IGluaXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwbHVnaW47XG4iLCJpbXBvcnQgQnV0dG9uIGZyb20gJy4vYnV0dG9uJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYic7XG5cbi8qIFBvc3RlciBJbWFnZVxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qKlxuICogVGhlIGNvbXBvbmVudCB0aGF0IGhhbmRsZXMgc2hvd2luZyB0aGUgcG9zdGVyIGltYWdlLlxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQb3N0ZXJJbWFnZSBleHRlbmRzIEJ1dHRvbiB7XG5cbiAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICBwbGF5ZXIub24oJ3Bvc3RlcmNoYW5nZScsIExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgdGhlIHBvc3RlciBpbWFnZVxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnBsYXllcigpLm9mZigncG9zdGVyY2hhbmdlJywgdGhpcy51cGRhdGUpO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHBvc3RlciBpbWFnZSBlbGVtZW50XG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBjcmVhdGVFbCgpIHtcbiAgICBsZXQgZWwgPSBMaWIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wb3N0ZXInLFxuXG4gICAgICAvLyBEb24ndCB3YW50IHBvc3RlciB0byBiZSB0YWJiYWJsZS5cbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pO1xuXG4gICAgLy8gVG8gZW5zdXJlIHRoZSBwb3N0ZXIgaW1hZ2UgcmVzaXplcyB3aGlsZSBtYWludGFpbmluZyBpdHMgb3JpZ2luYWwgYXNwZWN0XG4gICAgLy8gcmF0aW8sIHVzZSBhIGRpdiB3aXRoIGBiYWNrZ3JvdW5kLXNpemVgIHdoZW4gYXZhaWxhYmxlLiBGb3IgYnJvd3NlcnMgdGhhdFxuICAgIC8vIGRvIG5vdCBzdXBwb3J0IGBiYWNrZ3JvdW5kLXNpemVgIChlLmcuIElFOCksIGZhbGwgYmFjayBvbiB1c2luZyBhIHJlZ3VsYXJcbiAgICAvLyBpbWcgZWxlbWVudC5cbiAgICBpZiAoIUxpYi5CQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrSW1nXyA9IExpYi5jcmVhdGVFbCgnaW1nJyk7XG4gICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmZhbGxiYWNrSW1nXyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHVwZGF0ZXMgdG8gdGhlIHBsYXllcidzIHBvc3RlciBzb3VyY2VcbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBsZXQgdXJsID0gdGhpcy5wbGF5ZXIoKS5wb3N0ZXIoKTtcblxuICAgIHRoaXMuc2V0U3JjKHVybCk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIHBvc3RlciBzb3VyY2Ugd2Ugc2hvdWxkIGRpc3BsYXk6bm9uZSBvbiB0aGlzIGNvbXBvbmVudFxuICAgIC8vIHNvIGl0J3Mgbm90IHN0aWxsIGNsaWNrYWJsZSBvciByaWdodC1jbGlja2FibGVcbiAgICBpZiAodXJsKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zdGVyIHNvdXJjZSBkZXBlbmRpbmcgb24gdGhlIGRpc3BsYXkgbWV0aG9kXG4gICAqL1xuICBzZXRTcmModXJsKSB7XG4gICAgaWYgKHRoaXMuZmFsbGJhY2tJbWdfKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrSW1nXy5zcmMgPSB1cmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBiYWNrZ3JvdW5kSW1hZ2UgPSAnJztcbiAgICAgIC8vIEFueSBmYWxzZXkgdmFsdWVzIHNob3VsZCBzdGF5IGFzIGFuIGVtcHR5IHN0cmluZywgb3RoZXJ3aXNlXG4gICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXh0cmEgZXJyb3JcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlID0gYHVybChcIiR7dXJsfVwiKWA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxfLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGJhY2tncm91bmRJbWFnZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgY2xpY2tzIG9uIHRoZSBwb3N0ZXIgaW1hZ2VcbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgYSBjbGljayB0byB0cmlnZ2VyIHBsYXliYWNrIHdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkXG4gICAgLy8gYnV0IENTUyBzaG91bGQgYmUgaGlkaW5nIHRoZSBwb3N0ZXIgdG8gcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nXG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbn1cblxuQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdQb3N0ZXJJbWFnZScsIFBvc3RlckltYWdlKTtcbmV4cG9ydCBkZWZhdWx0IFBvc3RlckltYWdlO1xuIiwiaW1wb3J0ICogYXMgRXZlbnRzIGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxubGV0IF93aW5kb3dMb2FkZWQgPSBmYWxzZTtcbmxldCB2aWRlb2pzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRnVuY3Rpb25zIGZvciBhdXRvbWF0aWNhbGx5IHNldHRpbmcgdXAgYSBwbGF5ZXJcbiAqIGJhc2VkIG9uIHRoZSBkYXRhLXNldHVwIGF0dHJpYnV0ZSBvZiB0aGUgdmlkZW8gdGFnXG4gKi9cblxuLy8gQXV0b21hdGljYWxseSBzZXQgdXAgYW55IHRhZ3MgdGhhdCBoYXZlIGEgZGF0YS1zZXR1cCBhdHRyaWJ1dGVcbnZhciBhdXRvU2V0dXAgPSBmdW5jdGlvbigpe1xuICAvLyBPbmUgZGF5LCB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBJRTgsIGdvIGJhY2sgdG8gdGhpcywgYnV0IGluIHRoZSBtZWFudGltZS4uLipoYWNrIGhhY2sgaGFjaypcbiAgLy8gdmFyIHZpZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKSk7XG4gIC8vIHZhciBhdWRpb3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKSk7XG4gIC8vIHZhciBtZWRpYUVscyA9IHZpZHMuY29uY2F0KGF1ZGlvcyk7XG5cbiAgLy8gQmVjYXVzZSBJRTggZG9lc24ndCBzdXBwb3J0IGNhbGxpbmcgc2xpY2Ugb24gYSBub2RlIGxpc3QsIHdlIG5lZWQgdG8gbG9vcCB0aHJvdWdoIGVhY2ggbGlzdCBvZiBlbGVtZW50c1xuICAvLyB0byBidWlsZCB1cCBhIG5ldywgY29tYmluZWQgbGlzdCBvZiBlbGVtZW50cy5cbiAgdmFyIHZpZHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKTtcbiAgdmFyIGF1ZGlvcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhdWRpbycpO1xuICB2YXIgbWVkaWFFbHMgPSBbXTtcbiAgaWYgKHZpZHMgJiYgdmlkcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yKGxldCBpPTAsIGU9dmlkcy5sZW5ndGg7IGk8ZTsgaSsrKSB7XG4gICAgICBtZWRpYUVscy5wdXNoKHZpZHNbaV0pO1xuICAgIH1cbiAgfVxuICBpZiAoYXVkaW9zICYmIGF1ZGlvcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yKGxldCBpPTAsIGU9YXVkaW9zLmxlbmd0aDsgaTxlOyBpKyspIHtcbiAgICAgIG1lZGlhRWxzLnB1c2goYXVkaW9zW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBhbnkgbWVkaWEgZWxlbWVudHMgZXhpc3RcbiAgaWYgKG1lZGlhRWxzICYmIG1lZGlhRWxzLmxlbmd0aCA+IDApIHtcblxuICAgIGZvciAobGV0IGk9MCwgZT1tZWRpYUVscy5sZW5ndGg7IGk8ZTsgaSsrKSB7XG4gICAgICBsZXQgbWVkaWFFbCA9IG1lZGlhRWxzW2ldO1xuXG4gICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGV4aXN0cywgaGFzIGdldEF0dHJpYnV0ZSBmdW5jLlxuICAgICAgLy8gSUUgc2VlbXMgdG8gY29uc2lkZXIgdHlwZW9mIGVsLmdldEF0dHJpYnV0ZSA9PSAnb2JqZWN0JyBpbnN0ZWFkIG9mICdmdW5jdGlvbicgbGlrZSBleHBlY3RlZCwgYXQgbGVhc3Qgd2hlbiBsb2FkaW5nIHRoZSBwbGF5ZXIgaW1tZWRpYXRlbHkuXG4gICAgICBpZiAobWVkaWFFbCAmJiBtZWRpYUVsLmdldEF0dHJpYnV0ZSkge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBsYXllciBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNldCB1cC5cbiAgICAgICAgaWYgKG1lZGlhRWxbJ3BsYXllciddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXQgb3B0aW9ucyA9IG1lZGlhRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNldHVwJyk7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgICAgICAgIC8vIFdlIG9ubHkgYXV0by1zZXR1cCBpZiB0aGV5J3ZlIGFkZGVkIHRoZSBkYXRhLXNldHVwIGF0dHIuXG4gICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdmlkZW8uanMgaW5zdGFuY2UuXG4gICAgICAgICAgICBsZXQgcGxheWVyID0gdmlkZW9qcyhtZWRpYUVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgZ2V0QXR0cmlidXRlIGlzbid0IGRlZmluZWQsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIERPTS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1dG9TZXR1cFRpbWVvdXQoMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAvLyBObyB2aWRlb3Mgd2VyZSBmb3VuZCwgc28ga2VlcCBsb29waW5nIHVubGVzcyBwYWdlIGlzIGZpbmlzaGVkIGxvYWRpbmcuXG4gIH0gZWxzZSBpZiAoIV93aW5kb3dMb2FkZWQpIHtcbiAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICB9XG59O1xuXG4vLyBQYXVzZSB0byBsZXQgdGhlIERPTSBrZWVwIHByb2Nlc3NpbmdcbnZhciBhdXRvU2V0dXBUaW1lb3V0ID0gZnVuY3Rpb24od2FpdCwgdmpzKXtcbiAgdmlkZW9qcyA9IHZqcztcbiAgc2V0VGltZW91dChhdXRvU2V0dXAsIHdhaXQpO1xufTtcblxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgX3dpbmRvd0xvYWRlZCA9IHRydWU7XG59IGVsc2Uge1xuICBFdmVudHMub25lKHdpbmRvdywgJ2xvYWQnLCBmdW5jdGlvbigpe1xuICAgIF93aW5kb3dMb2FkZWQgPSB0cnVlO1xuICB9KTtcbn1cblxudmFyIGhhc0xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX3dpbmRvd0xvYWRlZDtcbn07XG5cbmV4cG9ydCB7IGF1dG9TZXR1cCwgYXV0b1NldHVwVGltZW91dCwgaGFzTG9hZGVkIH07XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcblxuLyoqXG4gKiBTZWVrQmFyIEJlaGF2aW9yIGluY2x1ZGVzIHBsYXkgcHJvZ3Jlc3MgYmFyLCBhbmQgc2VlayBoYW5kbGVcbiAqIE5lZWRlZCBzbyBpdCBjYW4gZGV0ZXJtaW5lIHNlZWsgcG9zaXRpb24gYmFzZWQgb24gaGFuZGxlIHBvc2l0aW9uL3NpemVcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTbGlkZXJIYW5kbGUgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBjcmVhdGVFbCh0eXBlLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgLy8gQWRkIHRoZSBzbGlkZXIgZWxlbWVudCBjbGFzcyB0byBhbGwgc3ViIGNsYXNzZXNcbiAgICBwcm9wcy5jbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgKyAnIHZqcy1zbGlkZXItaGFuZGxlJztcbiAgICBwcm9wcyA9IExpYi5vYmoubWVyZ2Uoe1xuICAgICAgaW5uZXJIVE1MOiBgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JHt0aGlzLmRlZmF1bHRWYWx1ZSB8fCAwfTwvc3Bhbj5gXG4gICAgfSwgcHJvcHMpO1xuXG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCBwcm9wcyk7XG4gIH1cblxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NsaWRlckhhbmRsZScsIFNsaWRlckhhbmRsZSk7XG5leHBvcnQgZGVmYXVsdCBTbGlkZXJIYW5kbGU7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuXG4vKiBTbGlkZXJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIFRoZSBiYXNlIGZ1bmN0aW9uYWxpdHkgZm9yIHNsaWRlcnMgbGlrZSB0aGUgdm9sdW1lIGJhciBhbmQgc2VlayBiYXJcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU2xpZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2V0IHByb3BlcnR5IG5hbWVzIHRvIGJhciBhbmQgaGFuZGxlIHRvIG1hdGNoIHdpdGggdGhlIGNoaWxkIFNsaWRlciBjbGFzcyBpcyBsb29raW5nIGZvclxuICAgIHRoaXMuYmFyID0gdGhpcy5nZXRDaGlsZCh0aGlzLm9wdGlvbnNfWydiYXJOYW1lJ10pO1xuICAgIHRoaXMuaGFuZGxlID0gdGhpcy5nZXRDaGlsZCh0aGlzLm9wdGlvbnNfWydoYW5kbGVOYW1lJ10pO1xuXG4gICAgLy8gU2V0IGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjbGFzcyBvbiB0aGUgc2xpZGVyIGRlcGVuZGluZyBvbiB0aGUgc2xpZGVyIHR5cGVcbiAgICB0aGlzLnZlcnRpY2FsKCEhdGhpcy5vcHRpb25zKClbJ3ZlcnRpY2FsJ10pO1xuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyKTtcbiAgICB0aGlzLm9uKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2spO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICdjb250cm9sc3Zpc2libGUnLCB0aGlzLnVwZGF0ZSk7XG4gICAgdGhpcy5vbihwbGF5ZXIsIHRoaXMucGxheWVyRXZlbnQsIHRoaXMudXBkYXRlKTtcbiAgfVxuXG4gIGNyZWF0ZUVsKHR5cGUsIHByb3BzPXt9KSB7XG4gICAgLy8gQWRkIHRoZSBzbGlkZXIgZWxlbWVudCBjbGFzcyB0byBhbGwgc3ViIGNsYXNzZXNcbiAgICBwcm9wcy5jbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgKyAnIHZqcy1zbGlkZXInO1xuICAgIHByb3BzID0gTGliLm9iai5tZXJnZSh7XG4gICAgICAncm9sZSc6ICdzbGlkZXInLFxuICAgICAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAgICAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAgICAgJ2FyaWEtdmFsdWVtYXgnOiAxMDAsXG4gICAgICB0YWJJbmRleDogMFxuICAgIH0sIHByb3BzKTtcblxuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCh0eXBlLCBwcm9wcyk7XG4gIH1cblxuICBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIExpYi5ibG9ja1RleHRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGluZycpO1xuXG4gICAgdGhpcy5vbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuXG4gICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUoZXZlbnQpO1xuICB9XG5cbiAgLy8gVG8gYmUgb3ZlcnJpZGRlbiBieSBhIHN1YmNsYXNzXG4gIGhhbmRsZU1vdXNlTW92ZSgpIHt9XG5cbiAgaGFuZGxlTW91c2VVcCgpIHtcbiAgICBMaWIudW5ibG9ja1RleHRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2xpZGluZycpO1xuXG4gICAgdGhpcy5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgLy8gSW4gVm9sdW1lQmFyIGluaXQgd2UgaGF2ZSBhIHNldFRpbWVvdXQgZm9yIHVwZGF0ZSB0aGF0IHBvcHMgYW5kIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIGV4ZWN1dGlvbiBzdGFjay4gVGhlIHBsYXllciBpcyBkZXN0cm95ZWQgYmVmb3JlIHRoZW4gdXBkYXRlIHdpbGwgY2F1c2UgYW4gZXJyb3JcbiAgICBpZiAoIXRoaXMuZWxfKSByZXR1cm47XG5cbiAgICAvLyBJZiBzY3J1YmJpbmcsIHdlIGNvdWxkIHVzZSBhIGNhY2hlZCB2YWx1ZSB0byBtYWtlIHRoZSBoYW5kbGUga2VlcCB1cCB3aXRoIHRoZSB1c2VyJ3MgbW91c2UuXG4gICAgLy8gT24gSFRNTDUgYnJvd3NlcnMgc2NydWJiaW5nIGlzIHJlYWxseSBzbW9vdGgsIGJ1dCBzb21lIGZsYXNoIHBsYXllcnMgYXJlIHNsb3csIHNvIHdlIG1pZ2h0IHdhbnQgdG8gdXRpbGl6ZSB0aGlzIGxhdGVyLlxuICAgIC8vIHZhciBwcm9ncmVzcyA9ICAodGhpcy5wbGF5ZXJfLnNjcnViYmluZykgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICBsZXQgcHJvZ3Jlc3MgPSB0aGlzLmdldFBlcmNlbnQoKTtcbiAgICBsZXQgYmFyID0gdGhpcy5iYXI7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGJhci4uLlxuICAgIGlmICghYmFyKSByZXR1cm47XG5cbiAgICAvLyBQcm90ZWN0IGFnYWluc3Qgbm8gZHVyYXRpb24gYW5kIG90aGVyIGRpdmlzaW9uIGlzc3Vlc1xuICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3MgIT09ICdudW1iZXInIHx8XG4gICAgICAgIHByb2dyZXNzICE9PSBwcm9ncmVzcyB8fFxuICAgICAgICBwcm9ncmVzcyA8IDAgfHxcbiAgICAgICAgcHJvZ3Jlc3MgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSAwO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgaGFuZGxlLCB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSBoYW5kbGUgaW4gb3VyIGNhbGN1bGF0aW9uIGZvciBwcm9ncmVzcyBiYXJcbiAgICAvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgZmFsbCBzaG9ydCBvZiBvciBleHRlbmQgcGFzdCB0aGUgaGFuZGxlLlxuICAgIGxldCBiYXJQcm9ncmVzcyA9IHRoaXMudXBkYXRlSGFuZGxlUG9zaXRpb24ocHJvZ3Jlc3MpO1xuXG4gICAgLy8gQ29udmVydCB0byBhIHBlcmNlbnRhZ2UgZm9yIHNldHRpbmdcbiAgICBsZXQgcGVyY2VudGFnZSA9IExpYi5yb3VuZChiYXJQcm9ncmVzcyAqIDEwMCwgMikgKyAnJSc7XG5cbiAgICAvLyBTZXQgdGhlIG5ldyBiYXIgd2lkdGggb3IgaGVpZ2h0XG4gICAgaWYgKHRoaXMudmVydGljYWwoKSkge1xuICAgICAgYmFyLmVsKCkuc3R5bGUuaGVpZ2h0ID0gcGVyY2VudGFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyLmVsKCkuc3R5bGUud2lkdGggPSBwZXJjZW50YWdlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIFVwZGF0ZSB0aGUgaGFuZGxlIHBvc2l0aW9uLlxuICAqL1xuICB1cGRhdGVIYW5kbGVQb3NpdGlvbihwcm9ncmVzcykge1xuICAgIGxldCBoYW5kbGUgPSB0aGlzLmhhbmRsZTtcbiAgICBpZiAoIWhhbmRsZSkgcmV0dXJuO1xuXG4gICAgbGV0IHZlcnRpY2FsID0gdGhpcy52ZXJ0aWNhbCgpO1xuICAgIGxldCBib3ggPSB0aGlzLmVsXztcblxuICAgIGxldCBib3hTaXplLCBoYW5kbGVTaXplO1xuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgYm94U2l6ZSA9IGJveC5vZmZzZXRIZWlnaHQ7XG4gICAgICBoYW5kbGVTaXplID0gaGFuZGxlLmVsKCkub2Zmc2V0SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3hTaXplID0gYm94Lm9mZnNldFdpZHRoO1xuICAgICAgaGFuZGxlU2l6ZSA9IGhhbmRsZS5lbCgpLm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIC8vIFRoZSB3aWR0aCBvZiB0aGUgaGFuZGxlIGluIHBlcmNlbnQgb2YgdGhlIGNvbnRhaW5pbmcgYm94XG4gICAgLy8gSW4gSUUsIHdpZHRocyBtYXkgbm90IGJlIHJlYWR5IHlldCBjYXVzaW5nIE5hTlxuICAgIGxldCBoYW5kbGVQZXJjZW50ID0gKGhhbmRsZVNpemUpID8gaGFuZGxlU2l6ZSAvIGJveFNpemUgOiAwO1xuXG4gICAgLy8gR2V0IHRoZSBhZGp1c3RlZCBzaXplIG9mIHRoZSBib3gsIGNvbnNpZGVyaW5nIHRoYXQgdGhlIGhhbmRsZSdzIGNlbnRlciBuZXZlciB0b3VjaGVzIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUuXG4gICAgLy8gVGhlcmUgaXMgYSBtYXJnaW4gb2YgaGFsZiB0aGUgaGFuZGxlJ3Mgd2lkdGggb24gYm90aCBzaWRlcy5cbiAgICBsZXQgYm94QWRqdXN0ZWRQZXJjZW50ID0gMSAtIGhhbmRsZVBlcmNlbnQ7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHByb2dyZXNzIHRoYXQgd2UnbGwgdXNlIHRvIHNldCB3aWR0aHMgdG8gdGhlIG5ldyBhZGp1c3RlZCBib3ggd2lkdGhcbiAgICBsZXQgYWRqdXN0ZWRQcm9ncmVzcyA9IHByb2dyZXNzICogYm94QWRqdXN0ZWRQZXJjZW50O1xuXG4gICAgLy8gVGhlIGJhciBkb2VzIHJlYWNoIHRoZSBsZWZ0IHNpZGUsIHNvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhpcyBpbiB0aGUgYmFyJ3Mgd2lkdGhcbiAgICBsZXQgYmFyUHJvZ3Jlc3MgPSBhZGp1c3RlZFByb2dyZXNzICsgKGhhbmRsZVBlcmNlbnQgLyAyKTtcblxuICAgIGxldCBwZXJjZW50YWdlID0gTGliLnJvdW5kKGFkanVzdGVkUHJvZ3Jlc3MgKiAxMDAsIDIpICsgJyUnO1xuXG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBoYW5kbGUuZWwoKS5zdHlsZS5ib3R0b20gPSBwZXJjZW50YWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGUuZWwoKS5zdHlsZS5sZWZ0ID0gcGVyY2VudGFnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFyUHJvZ3Jlc3M7XG4gIH1cblxuICBjYWxjdWxhdGVEaXN0YW5jZShldmVudCl7XG4gICAgbGV0IGVsID0gdGhpcy5lbF87XG4gICAgbGV0IGJveCA9IExpYi5maW5kUG9zaXRpb24oZWwpO1xuICAgIGxldCBib3hXID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgbGV0IGJveEggPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IGhhbmRsZSA9IHRoaXMuaGFuZGxlO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucygpWyd2ZXJ0aWNhbCddKSB7XG4gICAgICBsZXQgYm94WSA9IGJveC50b3A7XG5cbiAgICAgIGxldCBwYWdlWTtcbiAgICAgIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICBwYWdlWSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFnZVkgPSBldmVudC5wYWdlWTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICB2YXIgaGFuZGxlSCA9IGhhbmRsZS5lbCgpLm9mZnNldEhlaWdodDtcbiAgICAgICAgLy8gQWRqdXN0ZWQgWCBhbmQgV2lkdGgsIHNvIGhhbmRsZSBkb2Vzbid0IGdvIG91dHNpZGUgdGhlIGJhclxuICAgICAgICBib3hZID0gYm94WSArIChoYW5kbGVIIC8gMik7XG4gICAgICAgIGJveEggPSBib3hIIC0gaGFuZGxlSDtcbiAgICAgIH1cblxuICAgICAgLy8gUGVyY2VudCB0aGF0IHRoZSBjbGljayBpcyB0aHJvdWdoIHRoZSBhZGp1c3RlZCBhcmVhXG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKChib3hZIC0gcGFnZVkpICsgYm94SCkgLyBib3hIKSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGJveFggPSBib3gubGVmdDtcblxuICAgICAgbGV0IHBhZ2VYO1xuICAgICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIHBhZ2VYID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgIHZhciBoYW5kbGVXID0gaGFuZGxlLmVsKCkub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgLy8gQWRqdXN0ZWQgWCBhbmQgV2lkdGgsIHNvIGhhbmRsZSBkb2Vzbid0IGdvIG91dHNpZGUgdGhlIGJhclxuICAgICAgICBib3hYID0gYm94WCArIChoYW5kbGVXIC8gMik7XG4gICAgICAgIGJveFcgPSBib3hXIC0gaGFuZGxlVztcbiAgICAgIH1cblxuICAgICAgLy8gUGVyY2VudCB0aGF0IHRoZSBjbGljayBpcyB0aHJvdWdoIHRoZSBhZGp1c3RlZCBhcmVhXG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHBhZ2VYIC0gYm94WCkgLyBib3hXKSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9jdXMoKSB7XG4gICAgdGhpcy5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleVByZXNzKTtcbiAgfVxuXG4gIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzNyB8fCBldmVudC53aGljaCA9PT0gNDApIHsgLy8gTGVmdCBhbmQgRG93biBBcnJvd3NcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBCYWNrKCk7XG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gMzggfHwgZXZlbnQud2hpY2ggPT09IDM5KSB7IC8vIFVwIGFuZCBSaWdodCBBcnJvd3NcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBGb3J3YXJkKCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQmx1cigpIHtcbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleVByZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW5lciBmb3IgY2xpY2sgZXZlbnRzIG9uIHNsaWRlciwgdXNlZCB0byBwcmV2ZW50IGNsaWNrc1xuICAgKiAgIGZyb20gYnViYmxpbmcgdXAgdG8gcGFyZW50IGVsZW1lbnRzIGxpa2UgYnV0dG9uIG1lbnVzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKi9cbiAgaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgdmVydGljYWwoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsXyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnRpY2FsXyA9ICEhYm9vbDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci12ZXJ0aWNhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWhvcml6b250YWwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU2xpZGVyJywgU2xpZGVyKTtcbmV4cG9ydCBkZWZhdWx0IFNsaWRlcjtcbiIsImZ1bmN0aW9uIEZsYXNoUnRtcERlY29yYXRvcihGbGFzaCkge1xuICBGbGFzaC5zdHJlYW1pbmdGb3JtYXRzID0ge1xuICAgICdydG1wL21wNCc6ICdNUDQnLFxuICAgICdydG1wL2Zsdic6ICdGTFYnXG4gIH07XG5cbiAgRmxhc2guc3RyZWFtRnJvbVBhcnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24gKyAnJicgKyBzdHJlYW07XG4gIH07XG5cbiAgRmxhc2guc3RyZWFtVG9QYXJ0cyA9IGZ1bmN0aW9uKHNyYykge1xuICAgIGxldCBwYXJ0cyA9IHtcbiAgICAgIGNvbm5lY3Rpb246ICcnLFxuICAgICAgc3RyZWFtOiAnJ1xuICAgIH07XG5cbiAgICBpZiAoIXNyYykgcmV0dXJuIHBhcnRzO1xuXG4gICAgLy8gTG9vayBmb3IgdGhlIG5vcm1hbCBVUkwgc2VwYXJhdG9yIHdlIGV4cGVjdCwgJyYnLlxuICAgIC8vIElmIGZvdW5kLCB3ZSBzcGxpdCB0aGUgVVJMIGludG8gdHdvIHBpZWNlcyBhcm91bmQgdGhlXG4gICAgLy8gZmlyc3QgJyYnLlxuICAgIGxldCBjb25uRW5kID0gc3JjLmluZGV4T2YoJyYnKTtcbiAgICBsZXQgc3RyZWFtQmVnaW47XG4gICAgaWYgKGNvbm5FbmQgIT09IC0xKSB7XG4gICAgICBzdHJlYW1CZWdpbiA9IGNvbm5FbmQgKyAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm90IGEgJyYnLCB3ZSB1c2UgdGhlIGxhc3QgJy8nIGFzIHRoZSBkZWxpbWl0ZXIuXG4gICAgICBjb25uRW5kID0gc3RyZWFtQmVnaW4gPSBzcmMubGFzdEluZGV4T2YoJy8nKSArIDE7XG4gICAgICBpZiAoY29ubkVuZCA9PT0gMCkge1xuICAgICAgICAvLyByZWFsbHksIHRoZXJlJ3Mgbm90IGEgJy8nP1xuICAgICAgICBjb25uRW5kID0gc3RyZWFtQmVnaW4gPSBzcmMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJ0cy5jb25uZWN0aW9uID0gc3JjLnN1YnN0cmluZygwLCBjb25uRW5kKTtcbiAgICBwYXJ0cy5zdHJlYW0gPSBzcmMuc3Vic3RyaW5nKHN0cmVhbUJlZ2luLCBzcmMubGVuZ3RoKTtcblxuICAgIHJldHVybiBwYXJ0cztcbiAgfTtcblxuICBGbGFzaC5pc1N0cmVhbWluZ1R5cGUgPSBmdW5jdGlvbihzcmNUeXBlKSB7XG4gICAgcmV0dXJuIHNyY1R5cGUgaW4gRmxhc2guc3RyZWFtaW5nRm9ybWF0cztcbiAgfTtcblxuICAvLyBSVE1QIGhhcyBmb3VyIHZhcmlhdGlvbnMsIGFueSBzdHJpbmcgc3RhcnRpbmdcbiAgLy8gd2l0aCBvbmUgb2YgdGhlc2UgcHJvdG9jb2xzIHNob3VsZCBiZSB2YWxpZFxuICBGbGFzaC5SVE1QX1JFID0gL15ydG1wW3NldF0/OlxcL1xcLy9pO1xuXG4gIEZsYXNoLmlzU3RyZWFtaW5nU3JjID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgcmV0dXJuIEZsYXNoLlJUTVBfUkUudGVzdChzcmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHNvdXJjZSBoYW5kbGVyIGZvciBSVE1QIHVybHNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIEZsYXNoLnJ0bXBTb3VyY2VIYW5kbGVyID0ge307XG5cbiAgLyoqXG4gICAqIENoZWNrIEZsYXNoIGNhbiBoYW5kbGUgdGhlIHNvdXJjZSBuYXRpdmVseVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZSAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICBGbGFzaC5ydG1wU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIGlmIChGbGFzaC5pc1N0cmVhbWluZ1R5cGUoc291cmNlLnR5cGUpIHx8IEZsYXNoLmlzU3RyZWFtaW5nU3JjKHNvdXJjZS5zcmMpKSB7XG4gICAgICByZXR1cm4gJ21heWJlJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhc3MgdGhlIHNvdXJjZSB0byB0aGUgZmxhc2ggb2JqZWN0XG4gICAqIEFkYXB0aXZlIHNvdXJjZSBoYW5kbGVycyB3aWxsIGhhdmUgbW9yZSBjb21wbGljYXRlZCB3b3JrZmxvd3MgYmVmb3JlIHBhc3NpbmdcbiAgICogdmlkZW8gZGF0YSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZSAgICBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0gIHtGbGFzaH0gdGVjaCAgIFRoZSBpbnN0YW5jZSBvZiB0aGUgRmxhc2ggdGVjaFxuICAgKi9cbiAgRmxhc2gucnRtcFNvdXJjZUhhbmRsZXIuaGFuZGxlU291cmNlID0gZnVuY3Rpb24oc291cmNlLCB0ZWNoKXtcbiAgICBsZXQgc3JjUGFydHMgPSBGbGFzaC5zdHJlYW1Ub1BhcnRzKHNvdXJjZS5zcmMpO1xuXG4gICAgdGVjaFsnc2V0UnRtcENvbm5lY3Rpb24nXShzcmNQYXJ0cy5jb25uZWN0aW9uKTtcbiAgICB0ZWNoWydzZXRSdG1wU3RyZWFtJ10oc3JjUGFydHMuc3RyZWFtKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG4gIEZsYXNoLnJlZ2lzdGVyU291cmNlSGFuZGxlcihGbGFzaC5ydG1wU291cmNlSGFuZGxlcik7XG5cbiAgcmV0dXJuIEZsYXNoO1xufVxuXG5leHBvcnQgZGVmYXVsdCBGbGFzaFJ0bXBEZWNvcmF0b3I7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVmlkZW9KUy1TV0YgLSBDdXN0b20gRmxhc2ggUGxheWVyIHdpdGggSFRNTDUtaXNoIEFQSVxuICogaHR0cHM6Ly9naXRodWIuY29tL3plbmNvZGVyL3ZpZGVvLWpzLXN3ZlxuICogTm90IHVzaW5nIHNldHVwVHJpZ2dlcnMuIFVzaW5nIGdsb2JhbCBvbkV2ZW50IGZ1bmMgdG8gZGlzdHJpYnV0ZSBldmVudHNcbiAqL1xuXG5pbXBvcnQgVGVjaCBmcm9tICcuL3RlY2gnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgRmxhc2hSdG1wRGVjb3JhdG9yIGZyb20gJy4vZmxhc2gtcnRtcCc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG5sZXQgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcbi8qKlxuICogRmxhc2ggTWVkaWEgQ29udHJvbGxlciAtIFdyYXBwZXIgZm9yIGZhbGxiYWNrIFNXRiBBUElcbiAqXG4gKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSByZWFkeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEZsYXNoIGV4dGVuZHMgVGVjaCB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVhZHkpe1xuICAgIHN1cGVyKG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIGxldCB7IHNvdXJjZSwgcGFyZW50RWwgfSA9IG9wdGlvbnM7XG5cbiAgICAvLyBHZW5lcmF0ZSBJRCBmb3Igc3dmIG9iamVjdFxuICAgIGxldCBvYmpJZCA9IG9wdGlvbnMucGxheWVySWQrJ19mbGFzaF9hcGknO1xuXG4gICAgLy8gTWVyZ2UgZGVmYXVsdCBmbGFzaHZhcnMgd2l0aCBvbmVzIHBhc3NlZCBpbiB0byBpbml0XG4gICAgbGV0IGZsYXNoVmFycyA9IExpYi5vYmoubWVyZ2Uoe1xuXG4gICAgICAvLyBTV0YgQ2FsbGJhY2sgRnVuY3Rpb25zXG4gICAgICAncmVhZHlGdW5jdGlvbic6ICd2aWRlb2pzLkZsYXNoLm9uUmVhZHknLFxuICAgICAgJ2V2ZW50UHJveHlGdW5jdGlvbic6ICd2aWRlb2pzLkZsYXNoLm9uRXZlbnQnLFxuICAgICAgJ2Vycm9yRXZlbnRQcm94eUZ1bmN0aW9uJzogJ3ZpZGVvanMuRmxhc2gub25FcnJvcicsXG5cbiAgICAgIC8vIFBsYXllciBTZXR0aW5nc1xuICAgICAgJ2F1dG9wbGF5Jzogb3B0aW9ucy5hdXRvcGxheSxcbiAgICAgICdwcmVsb2FkJzogb3B0aW9ucy5wcmVsb2FkLFxuICAgICAgJ2xvb3AnOiBvcHRpb25zLmxvb3AsXG4gICAgICAnbXV0ZWQnOiBvcHRpb25zLm11dGVkXG5cbiAgICB9LCBvcHRpb25zLmZsYXNoVmFycyk7XG5cbiAgICAvLyBNZXJnZSBkZWZhdWx0IHBhcmFtZXMgd2l0aCBvbmVzIHBhc3NlZCBpblxuICAgIGxldCBwYXJhbXMgPSBMaWIub2JqLm1lcmdlKHtcbiAgICAgICd3bW9kZSc6ICdvcGFxdWUnLCAvLyBPcGFxdWUgaXMgbmVlZGVkIHRvIG92ZXJsYXkgY29udHJvbHMsIGJ1dCBjYW4gYWZmZWN0IHBsYXliYWNrIHBlcmZvcm1hbmNlXG4gICAgICAnYmdjb2xvcic6ICcjMDAwMDAwJyAvLyBVc2luZyBiZ2NvbG9yIHByZXZlbnRzIGEgd2hpdGUgZmxhc2ggd2hlbiB0aGUgb2JqZWN0IGlzIGxvYWRpbmdcbiAgICB9LCBvcHRpb25zLnBhcmFtcyk7XG5cbiAgICAvLyBNZXJnZSBkZWZhdWx0IGF0dHJpYnV0ZXMgd2l0aCBvbmVzIHBhc3NlZCBpblxuICAgIGxldCBhdHRyaWJ1dGVzID0gTGliLm9iai5tZXJnZSh7XG4gICAgICAnaWQnOiBvYmpJZCxcbiAgICAgICduYW1lJzogb2JqSWQsIC8vIEJvdGggSUQgYW5kIE5hbWUgbmVlZGVkIG9yIHN3ZiB0byBpZGVudGlmeSBpdHNlbGZcbiAgICAgICdjbGFzcyc6ICd2anMtdGVjaCdcbiAgICB9LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gSWYgc291cmNlIHdhcyBzdXBwbGllZCBwYXNzIGFzIGEgZmxhc2ggdmFyLlxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhdmluZyBpc3N1ZXMgd2l0aCBGbGFzaCByZWxvYWRpbmcgb24gY2VydGFpbiBwYWdlIGFjdGlvbnMgKGhpZGUvcmVzaXplL2Z1bGxzY3JlZW4pIGluIGNlcnRhaW4gYnJvd3NlcnNcbiAgICAvLyBUaGlzIGFsbG93cyByZXNldHRpbmcgdGhlIHBsYXloZWFkIHdoZW4gd2UgY2F0Y2ggdGhlIHJlbG9hZFxuICAgIGlmIChvcHRpb25zLnN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUob3B0aW9ucy5zdGFydFRpbWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgd2luZG93LnZpZGVvanMgPSB3aW5kb3cudmlkZW9qcyB8fCB7fTtcbiAgICB3aW5kb3cudmlkZW9qcy5GbGFzaCA9IHdpbmRvdy52aWRlb2pzLkZsYXNoIHx8IHt9O1xuICAgIHdpbmRvdy52aWRlb2pzLkZsYXNoLm9uUmVhZHkgPSBGbGFzaC5vblJlYWR5O1xuICAgIHdpbmRvdy52aWRlb2pzLkZsYXNoLm9uRXZlbnQgPSBGbGFzaC5vbkV2ZW50O1xuICAgIHdpbmRvdy52aWRlb2pzLkZsYXNoLm9uRXJyb3IgPSBGbGFzaC5vbkVycm9yO1xuXG4gICAgdGhpcy5lbF8gPSBGbGFzaC5lbWJlZChvcHRpb25zLnN3ZiwgZmxhc2hWYXJzLCBwYXJhbXMsIGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMuZWxfLnRlY2ggPSB0aGlzO1xuICB9XG5cbiAgcGxheSgpIHtcbiAgICB0aGlzLmVsXy52anNfcGxheSgpO1xuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5lbF8udmpzX3BhdXNlKCk7XG4gIH1cblxuICBzcmMoc3JjKSB7XG4gICAgaWYgKHNyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3JjKCk7XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyBzcmMgdGhyb3VnaCBgc3JjYCBub3QgYHNldFNyY2Agd2lsbCBiZSBkZXByZWNhdGVkXG4gICAgcmV0dXJuIHRoaXMuc2V0U3JjKHNyYyk7XG4gIH1cblxuICBzZXRTcmMoc3JjKSB7XG4gICAgLy8gTWFrZSBzdXJlIHNvdXJjZSBVUkwgaXMgYWJzb2x1dGUuXG4gICAgc3JjID0gTGliLmdldEFic29sdXRlVVJMKHNyYyk7XG4gICAgdGhpcy5lbF8udmpzX3NyYyhzcmMpO1xuXG4gICAgLy8gQ3VycmVudGx5IHRoZSBTV0YgZG9lc24ndCBhdXRvcGxheSBpZiB5b3UgbG9hZCBhIHNvdXJjZSBsYXRlci5cbiAgICAvLyBlLmcuIExvYWQgcGxheWVyIHcvIG5vIHNvdXJjZSwgd2FpdCAycywgc2V0IHNyYy5cbiAgICBpZiAodGhpcy5hdXRvcGxheSgpKSB7XG4gICAgICB2YXIgdGVjaCA9IHRoaXM7XG4gICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24oKXsgdGVjaC5wbGF5KCk7IH0sIDApO1xuICAgIH1cbiAgfVxuXG4gIHNldEN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICB0aGlzLmxhc3RTZWVrVGFyZ2V0XyA9IHRpbWU7XG4gICAgdGhpcy5lbF8udmpzX3NldFByb3BlcnR5KCdjdXJyZW50VGltZScsIHRpbWUpO1xuICAgIHN1cGVyLnNldEN1cnJlbnRUaW1lKCk7XG4gIH1cblxuICBjdXJyZW50VGltZSh0aW1lKSB7XG4gICAgLy8gd2hlbiBzZWVraW5nIG1ha2UgdGhlIHJlcG9ydGVkIHRpbWUga2VlcCB1cCB3aXRoIHRoZSByZXF1ZXN0ZWQgdGltZVxuICAgIC8vIGJ5IHJlYWRpbmcgdGhlIHRpbWUgd2UncmUgc2Vla2luZyB0b1xuICAgIGlmICh0aGlzLnNlZWtpbmcoKSkge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdFNlZWtUYXJnZXRfIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVsXy52anNfZ2V0UHJvcGVydHkoJ2N1cnJlbnRUaW1lJyk7XG4gIH1cblxuICBjdXJyZW50U3JjKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3VyY2VfKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlXy5zcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVsXy52anNfZ2V0UHJvcGVydHkoJ2N1cnJlbnRTcmMnKTtcbiAgICB9XG4gIH1cblxuICBsb2FkKCkge1xuICAgIHRoaXMuZWxfLnZqc19sb2FkKCk7XG4gIH1cblxuICBwb3N0ZXIoKSB7XG4gICAgdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdwb3N0ZXInKTtcbiAgfVxuXG4gIC8vIHBvc3RlciBpbWFnZXMgYXJlIG5vdCBoYW5kbGVkIGJ5IHRoZSBGbGFzaCB0ZWNoIHNvIG1ha2UgdGhpcyBhIG5vLW9wXG4gIHNldFBvc3RlcigpIHt9XG5cbiAgYnVmZmVyZWQoKSB7XG4gICAgcmV0dXJuIExpYi5jcmVhdGVUaW1lUmFuZ2UoMCwgdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdidWZmZXJlZCcpKTtcbiAgfVxuXG4gIHN1cHBvcnRzRnVsbFNjcmVlbigpIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIEZsYXNoIGRvZXMgbm90IGFsbG93IGZ1bGxzY3JlZW4gdGhyb3VnaCBqYXZhc2NyaXB0XG4gIH1cblxuICBlbnRlckZ1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cblxuXG4vLyBDcmVhdGUgc2V0dGVycyBhbmQgZ2V0dGVycyBmb3IgYXR0cmlidXRlc1xuY29uc3QgX2FwaSA9IEZsYXNoLnByb3RvdHlwZTtcbmNvbnN0IF9yZWFkV3JpdGUgPSAncnRtcENvbm5lY3Rpb24scnRtcFN0cmVhbSxwcmVsb2FkLGRlZmF1bHRQbGF5YmFja1JhdGUscGxheWJhY2tSYXRlLGF1dG9wbGF5LGxvb3AsbWVkaWFHcm91cCxjb250cm9sbGVyLGNvbnRyb2xzLHZvbHVtZSxtdXRlZCxkZWZhdWx0TXV0ZWQnLnNwbGl0KCcsJyk7XG5jb25zdCBfcmVhZE9ubHkgPSAnZXJyb3IsbmV0d29ya1N0YXRlLHJlYWR5U3RhdGUsc2Vla2luZyxpbml0aWFsVGltZSxkdXJhdGlvbixzdGFydE9mZnNldFRpbWUscGF1c2VkLHBsYXllZCxzZWVrYWJsZSxlbmRlZCx2aWRlb1RyYWNrcyxhdWRpb1RyYWNrcyx2aWRlb1dpZHRoLHZpZGVvSGVpZ2h0Jy5zcGxpdCgnLCcpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU2V0dGVyKGF0dHIpe1xuICB2YXIgYXR0clVwcGVyID0gYXR0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGF0dHIuc2xpY2UoMSk7XG4gIF9hcGlbJ3NldCcrYXR0clVwcGVyXSA9IGZ1bmN0aW9uKHZhbCl7IHJldHVybiB0aGlzLmVsXy52anNfc2V0UHJvcGVydHkoYXR0ciwgdmFsKTsgfTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVHZXR0ZXIoYXR0cikge1xuICBfYXBpW2F0dHJdID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZWxfLnZqc19nZXRQcm9wZXJ0eShhdHRyKTsgfTtcbn1cblxuLy8gQ3JlYXRlIGdldHRlciBhbmQgc2V0dGVycyBmb3IgYWxsIHJlYWQvd3JpdGUgYXR0cmlidXRlc1xuZm9yIChsZXQgaSA9IDA7IGkgPCBfcmVhZFdyaXRlLmxlbmd0aDsgaSsrKSB7XG4gIF9jcmVhdGVHZXR0ZXIoX3JlYWRXcml0ZVtpXSk7XG4gIF9jcmVhdGVTZXR0ZXIoX3JlYWRXcml0ZVtpXSk7XG59XG5cbi8vIENyZWF0ZSBnZXR0ZXJzIGZvciByZWFkLW9ubHkgYXR0cmlidXRlc1xuZm9yIChsZXQgaSA9IDA7IGkgPCBfcmVhZE9ubHkubGVuZ3RoOyBpKyspIHtcbiAgX2NyZWF0ZUdldHRlcihfcmVhZE9ubHlbaV0pO1xufVxuXG4vKiBGbGFzaCBTdXBwb3J0IFRlc3RpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuRmxhc2guaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gRmxhc2gudmVyc2lvbigpWzBdID49IDEwO1xuICAvLyByZXR1cm4gc3dmb2JqZWN0Lmhhc0ZsYXNoUGxheWVyVmVyc2lvbignMTAnKTtcbn07XG5cbi8vIEFkZCBTb3VyY2UgSGFuZGxlciBwYXR0ZXJuIGZ1bmN0aW9ucyB0byB0aGlzIHRlY2hcblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzKEZsYXNoKTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBuYXRpdmUgc291cmNlIGhhbmRsZXIuXG4gKiBUaGlzIHNpbXBseSBwYXNzZXMgdGhlIHNvdXJjZSB0byB0aGUgdmlkZW8gZWxlbWVudC4gTm90aGluZyBmYW5jeS5cbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0ZsYXNofSB0ZWNoICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEZsYXNoIHRlY2hcbiAqL1xuRmxhc2gubmF0aXZlU291cmNlSGFuZGxlciA9IHt9O1xuXG4vKipcbiAqIENoZWNrIEZsYXNoIGNhbiBoYW5kbGUgdGhlIHNvdXJjZSBuYXRpdmVseVxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAqL1xuRmxhc2gubmF0aXZlU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2Upe1xuICB2YXIgdHlwZTtcblxuICBmdW5jdGlvbiBndWVzc01pbWVUeXBlKHNyYykge1xuICAgIHZhciBleHQgPSBMaWIuZ2V0RmlsZUV4dGVuc2lvbihzcmMpO1xuICAgIGlmIChleHQpIHtcbiAgICAgIHJldHVybiBgdmlkZW8vJHtleHR9YDtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFzb3VyY2UudHlwZSkge1xuICAgIHR5cGUgPSBndWVzc01pbWVUeXBlKHNvdXJjZS5zcmMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmlwIGNvZGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgdHlwZSBiZWNhdXNlIHdlIGRvbid0IGdldCB0aGF0IHNwZWNpZmljXG4gICAgdHlwZSA9IHNvdXJjZS50eXBlLnJlcGxhY2UoLzsuKi8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgaWYgKHR5cGUgaW4gRmxhc2guZm9ybWF0cykge1xuICAgIHJldHVybiAnbWF5YmUnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBQYXNzIHRoZSBzb3VyY2UgdG8gdGhlIGZsYXNoIG9iamVjdFxuICogQWRhcHRpdmUgc291cmNlIGhhbmRsZXJzIHdpbGwgaGF2ZSBtb3JlIGNvbXBsaWNhdGVkIHdvcmtmbG93cyBiZWZvcmUgcGFzc2luZ1xuICogdmlkZW8gZGF0YSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0ZsYXNofSB0ZWNoICAgVGhlIGluc3RhbmNlIG9mIHRoZSBGbGFzaCB0ZWNoXG4gKi9cbkZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIuaGFuZGxlU291cmNlID0gZnVuY3Rpb24oc291cmNlLCB0ZWNoKXtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBzb3VyY2UgaGFuZGxlciB3aGVuIGRpc3Bvc2luZyB0aGUgcGxheWVyIG9yIHN3aXRjaGluZyBzb3VyY2VzLi5cbiAqIChubyBjbGVhbnVwIGlzIG5lZWRlZCB3aGVuIHN1cHBvcnRpbmcgdGhlIGZvcm1hdCBuYXRpdmVseSlcbiAqL1xuRmxhc2gubmF0aXZlU291cmNlSGFuZGxlci5kaXNwb3NlID0gZnVuY3Rpb24oKXt9O1xuXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG5GbGFzaC5yZWdpc3RlclNvdXJjZUhhbmRsZXIoRmxhc2gubmF0aXZlU291cmNlSGFuZGxlcik7XG5cbkZsYXNoLmZvcm1hdHMgPSB7XG4gICd2aWRlby9mbHYnOiAnRkxWJyxcbiAgJ3ZpZGVvL3gtZmx2JzogJ0ZMVicsXG4gICd2aWRlby9tcDQnOiAnTVA0JyxcbiAgJ3ZpZGVvL200dic6ICdNUDQnXG59O1xuXG5GbGFzaC5vblJlYWR5ID0gZnVuY3Rpb24oY3VyclN3Zil7XG4gIGxldCBlbCA9IExpYi5lbChjdXJyU3dmKTtcbiAgbGV0IHRlY2ggPSBlbCAmJiBlbC50ZWNoO1xuXG4gIC8vIGlmIHRoZXJlIGlzIG5vIGVsIHRoZW4gdGhlIHRlY2ggaGFzIGJlZW4gZGlzcG9zZWRcbiAgLy8gYW5kIHRoZSB0ZWNoIGVsZW1lbnQgd2FzIHJlbW92ZWQgZnJvbSB0aGUgcGxheWVyIGRpdlxuICBpZiAodGVjaCAmJiB0ZWNoLmVsKCkpIHtcbiAgICAvLyBjaGVjayB0aGF0IHRoZSBmbGFzaCBvYmplY3QgaXMgcmVhbGx5IHJlYWR5XG4gICAgRmxhc2guY2hlY2tSZWFkeSh0ZWNoKTtcbiAgfVxufTtcblxuLy8gVGhlIFNXRiBpc24ndCBhbHdheXMgcmVhZHkgd2hlbiBpdCBzYXlzIGl0IGlzLiBTb21ldGltZXMgdGhlIEFQSSBmdW5jdGlvbnMgc3RpbGwgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgb2JqZWN0LlxuLy8gSWYgaXQncyBub3QgcmVhZHksIHdlIHNldCBhIHRpbWVvdXQgdG8gY2hlY2sgYWdhaW4gc2hvcnRseS5cbkZsYXNoLmNoZWNrUmVhZHkgPSBmdW5jdGlvbih0ZWNoKXtcbiAgLy8gc3RvcCB3b3JyeWluZyBpZiB0aGUgdGVjaCBoYXMgYmVlbiBkaXNwb3NlZFxuICBpZiAoIXRlY2guZWwoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIEFQSSBwcm9wZXJ0eSBleGlzdHNcbiAgaWYgKHRlY2guZWwoKS52anNfZ2V0UHJvcGVydHkpIHtcbiAgICAvLyB0ZWxsIHRlY2ggaXQncyByZWFkeVxuICAgIHRlY2gudHJpZ2dlclJlYWR5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2FpdCBsb25nZXJcbiAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIEZsYXNoWydjaGVja1JlYWR5J10odGVjaCk7XG4gICAgfSwgNTApO1xuICB9XG59O1xuXG4vLyBUcmlnZ2VyIGV2ZW50cyBmcm9tIHRoZSBzd2Ygb24gdGhlIHBsYXllclxuRmxhc2gub25FdmVudCA9IGZ1bmN0aW9uKHN3ZklELCBldmVudE5hbWUpe1xuICBsZXQgdGVjaCA9IExpYi5lbChzd2ZJRCkudGVjaDtcblxuICAvLyBTcGVjaWFsIGNhc2UgZm9yIG91ciBtZXRhZGF0YXVwZGF0ZSBldmVudCB3aGljaCBpcyBzdXJmYWNlZCBmcm9tIG91ciBcbiAgLy8gdmVyc2lvbiBvZiB0aGUgVmlkZW8gSlMgU1dGLiAgV2UgbmVlZCB0byBzdXJmYWNlIHRoZSBhcmd1bWVudHMgZnJvbSB0aGVcbiAgLy8gRmxhc2ggZXZlbnQgdG8gbGlzdGVuZXJzIG9uIHRoZSBjbGllbnQgc2lkZS4gXG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ21ldGFkYXRhdXBkYXRlJykge1xuICAgIHZhciBtZXNnID0gJyc7XG4gICAgXG4gICAgaWYgKGFyZ3VtZW50cyAmJiBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0ubGVuZ3RoKSB7XG4gICAgICBtZXNnID0gYXJndW1lbnRzWzJdWzBdO1xuICAgIH1cblxuICAgIHRlY2gudHJpZ2dlcih7dHlwZTogZXZlbnROYW1lLCBkYXRhOiBtZXNnfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGVjaC50cmlnZ2VyKGV2ZW50TmFtZSk7XG4gIH1cbn07XG5cbi8vIExvZyBlcnJvcnMgZnJvbSB0aGUgc3dmXG5GbGFzaC5vbkVycm9yID0gZnVuY3Rpb24oc3dmSUQsIGVycil7XG4gIGNvbnN0IHRlY2ggPSBMaWIuZWwoc3dmSUQpLnRlY2g7XG4gIGNvbnN0IG1zZyA9ICdGTEFTSDogJytlcnI7XG5cbiAgaWYgKGVyciA9PT0gJ3NyY25vdGZvdW5kJykge1xuICAgIHRlY2gudHJpZ2dlcignZXJyb3InLCB7IGNvZGU6IDQsIG1lc3NhZ2U6IG1zZyB9KTtcblxuICAvLyBlcnJvcnMgd2UgaGF2ZW4ndCBjYXRlZ29yaXplZCBpbnRvIHRoZSBtZWRpYSBlcnJvcnNcbiAgfSBlbHNlIHtcbiAgICB0ZWNoLnRyaWdnZXIoJ2Vycm9yJywgbXNnKTtcbiAgfVxufTtcblxuLy8gRmxhc2ggVmVyc2lvbiBDaGVja1xuRmxhc2gudmVyc2lvbiA9IGZ1bmN0aW9uKCl7XG4gIGxldCB2ZXJzaW9uID0gJzAsMCwwJztcblxuICAvLyBJRVxuICB0cnkge1xuICAgIHZlcnNpb24gPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJykuR2V0VmFyaWFibGUoJyR2ZXJzaW9uJykucmVwbGFjZSgvXFxEKy9nLCAnLCcpLm1hdGNoKC9eLD8oLispLD8kLylbMV07XG5cbiAgLy8gb3RoZXIgYnJvd3NlcnNcbiAgfSBjYXRjaChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChuYXZpZ2F0b3IubWltZVR5cGVzWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddLmVuYWJsZWRQbHVnaW4pe1xuICAgICAgICB2ZXJzaW9uID0gKG5hdmlnYXRvci5wbHVnaW5zWydTaG9ja3dhdmUgRmxhc2ggMi4wJ10gfHwgbmF2aWdhdG9yLnBsdWdpbnNbJ1Nob2Nrd2F2ZSBGbGFzaCddKS5kZXNjcmlwdGlvbi5yZXBsYWNlKC9cXEQrL2csICcsJykubWF0Y2goL14sPyguKyksPyQvKVsxXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge31cbiAgfVxuICByZXR1cm4gdmVyc2lvbi5zcGxpdCgnLCcpO1xufTtcblxuLy8gRmxhc2ggZW1iZWRkaW5nIG1ldGhvZC4gT25seSB1c2VkIGluIG5vbi1pZnJhbWUgbW9kZVxuRmxhc2guZW1iZWQgPSBmdW5jdGlvbihzd2YsIGZsYXNoVmFycywgcGFyYW1zLCBhdHRyaWJ1dGVzKXtcbiAgY29uc3QgY29kZSA9IEZsYXNoLmdldEVtYmVkQ29kZShzd2YsIGZsYXNoVmFycywgcGFyYW1zLCBhdHRyaWJ1dGVzKTtcblxuICAvLyBHZXQgZWxlbWVudCBieSBlbWJlZGRpbmcgY29kZSBhbmQgcmV0cmlldmluZyBjcmVhdGVkIGVsZW1lbnRcbiAgY29uc3Qgb2JqID0gTGliLmNyZWF0ZUVsKCdkaXYnLCB7IGlubmVySFRNTDogY29kZSB9KS5jaGlsZE5vZGVzWzBdO1xuXG4gIHJldHVybiBvYmo7XG59O1xuXG5GbGFzaC5nZXRFbWJlZENvZGUgPSBmdW5jdGlvbihzd2YsIGZsYXNoVmFycywgcGFyYW1zLCBhdHRyaWJ1dGVzKXtcbiAgY29uc3Qgb2JqVGFnID0gJzxvYmplY3QgdHlwZT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCIgJztcbiAgbGV0IGZsYXNoVmFyc1N0cmluZyA9ICcnO1xuICBsZXQgcGFyYW1zU3RyaW5nID0gJyc7XG4gIGxldCBhdHRyc1N0cmluZyA9ICcnO1xuXG4gIC8vIENvbnZlcnQgZmxhc2ggdmFycyB0byBzdHJpbmdcbiAgaWYgKGZsYXNoVmFycykge1xuICAgIExpYi5vYmouZWFjaChmbGFzaFZhcnMsIGZ1bmN0aW9uKGtleSwgdmFsKXtcbiAgICAgIGZsYXNoVmFyc1N0cmluZyArPSBgJHtrZXl9PSR7dmFsfSZhbXA7YDtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFkZCBzd2YsIGZsYXNoVmFycywgYW5kIG90aGVyIGRlZmF1bHQgcGFyYW1zXG4gIHBhcmFtcyA9IExpYi5vYmoubWVyZ2Uoe1xuICAgICdtb3ZpZSc6IHN3ZixcbiAgICAnZmxhc2h2YXJzJzogZmxhc2hWYXJzU3RyaW5nLFxuICAgICdhbGxvd1NjcmlwdEFjY2Vzcyc6ICdhbHdheXMnLCAvLyBSZXF1aXJlZCB0byB0YWxrIHRvIHN3ZlxuICAgICdhbGxvd05ldHdvcmtpbmcnOiAnYWxsJyAvLyBBbGwgc2hvdWxkIGJlIGRlZmF1bHQsIGJ1dCBoYXZpbmcgc2VjdXJpdHkgaXNzdWVzLlxuICB9LCBwYXJhbXMpO1xuXG4gIC8vIENyZWF0ZSBwYXJhbSB0YWdzIHN0cmluZ1xuICBMaWIub2JqLmVhY2gocGFyYW1zLCBmdW5jdGlvbihrZXksIHZhbCl7XG4gICAgcGFyYW1zU3RyaW5nICs9IGA8cGFyYW0gbmFtZT1cIiR7a2V5fVwiIHZhbHVlPVwiJHt2YWx9XCIgLz5gO1xuICB9KTtcblxuICBhdHRyaWJ1dGVzID0gTGliLm9iai5tZXJnZSh7XG4gICAgLy8gQWRkIHN3ZiB0byBhdHRyaWJ1dGVzIChuZWVkIGJvdGggZm9yIElFIGFuZCBPdGhlcnMgdG8gd29yaylcbiAgICAnZGF0YSc6IHN3ZixcblxuICAgIC8vIERlZmF1bHQgdG8gMTAwJSB3aWR0aC9oZWlnaHRcbiAgICAnd2lkdGgnOiAnMTAwJScsXG4gICAgJ2hlaWdodCc6ICcxMDAlJ1xuXG4gIH0sIGF0dHJpYnV0ZXMpO1xuXG4gIC8vIENyZWF0ZSBBdHRyaWJ1dGVzIHN0cmluZ1xuICBMaWIub2JqLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oa2V5LCB2YWwpe1xuICAgIGF0dHJzU3RyaW5nICs9IGAke2tleX09XCIke3ZhbH1cIiBgO1xuICB9KTtcblxuICByZXR1cm4gYCR7b2JqVGFnfSR7YXR0cnNTdHJpbmd9PiR7cGFyYW1zU3RyaW5nfTwvb2JqZWN0PmA7XG59O1xuXG4vLyBSdW4gRmxhc2ggdGhyb3VnaCB0aGUgUlRNUCBkZWNvcmF0b3JcbkZsYXNoUnRtcERlY29yYXRvcihGbGFzaCk7XG5cblRlY2gucmVnaXN0ZXJDb21wb25lbnQoJ0ZsYXNoJywgRmxhc2gpO1xuZXhwb3J0IGRlZmF1bHQgRmxhc2g7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSFRNTDUgTWVkaWEgQ29udHJvbGxlciAtIFdyYXBwZXIgZm9yIEhUTUw1IE1lZGlhIEFQSVxuICovXG5cbmltcG9ydCBUZWNoIGZyb20gJy4vdGVjaC5qcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliJztcbmltcG9ydCAqIGFzIFZqc1V0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLyoqXG4gKiBIVE1MNSBNZWRpYSBDb250cm9sbGVyIC0gV3JhcHBlciBmb3IgSFRNTDUgTWVkaWEgQVBJXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gcmVhZHlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBIdG1sNSBleHRlbmRzIFRlY2gge1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihvcHRpb25zLCByZWFkeSk7XG5cbiAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcblxuICAgIC8vIFNldCB0aGUgc291cmNlIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgIC8vIDEpIENoZWNrIGlmIHRoZSBzb3VyY2UgaXMgbmV3IChpZiBub3QsIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgc28gcGxheWJhY2sgaXNuJ3QgaW50ZXJydXB0ZWQpXG4gICAgLy8gMikgQ2hlY2sgdG8gc2VlIGlmIHRoZSBuZXR3b3JrIHN0YXRlIG9mIHRoZSB0YWcgd2FzIGZhaWxlZCBhdCBpbml0LCBhbmQgaWYgc28sIHJlc2V0IHRoZSBzb3VyY2VcbiAgICAvLyBhbnl3YXkgc28gdGhlIGVycm9yIGdldHMgZmlyZWQuXG4gICAgaWYgKHNvdXJjZSAmJiAodGhpcy5lbF8uY3VycmVudFNyYyAhPT0gc291cmNlLnNyYyB8fCAob3B0aW9ucy50YWcgJiYgb3B0aW9ucy50YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPT09IDMpKSkge1xuICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbF8uaGFzQ2hpbGROb2RlcygpKSB7XG5cbiAgICAgIGxldCBub2RlcyA9IHRoaXMuZWxfLmNoaWxkTm9kZXM7XG4gICAgICBsZXQgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgICBsZXQgcmVtb3ZlTm9kZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKG5vZGVzTGVuZ3RoLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tub2Rlc0xlbmd0aF07XG4gICAgICAgIGxldCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAndHJhY2snKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgICAgICAgLy8gRW1wdHkgdmlkZW8gdGFnIHRyYWNrcyBzbyB0aGUgYnVpbHQtaW4gcGxheWVyIGRvZXNuJ3QgdXNlIHRoZW0gYWxzby5cbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IG5vdCBiZSBmYXN0IGVub3VnaCB0byBzdG9wIEhUTUw1IGJyb3dzZXJzIGZyb20gcmVhZGluZyB0aGUgdGFnc1xuICAgICAgICAgICAgLy8gc28gd2UnbGwgbmVlZCB0byB0dXJuIG9mZiBhbnkgZGVmYXVsdCB0cmFja3MgaWYgd2UncmUgbWFudWFsbHkgZG9pbmdcbiAgICAgICAgICAgIC8vIGNhcHRpb25zIGFuZCBzdWJ0aXRsZXMuIHZpZGVvRWxlbWVudC50ZXh0VHJhY2tzXG4gICAgICAgICAgICByZW1vdmVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5hZGRUcmFja18obm9kZS50cmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGk9MDsgaTxyZW1vdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmVsXy5yZW1vdmVDaGlsZChyZW1vdmVOb2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB0aGlzLm9uKCdsb2Fkc3RhcnQnLCBMaWIuYmluZCh0aGlzLCB0aGlzLmhpZGVDYXB0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHVzZWRcbiAgICAvLyBPdXIgZ29hbCBzaG91bGQgYmUgdG8gZ2V0IHRoZSBjdXN0b20gY29udHJvbHMgb24gbW9iaWxlIHNvbGlkIGV2ZXJ5d2hlcmVcbiAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoaXMgYWxsIHRvZ2V0aGVyLiBSaWdodCBub3cgdGhpcyB3aWxsIGJsb2NrIGN1c3RvbVxuICAgIC8vIGNvbnRyb2xzIG9uIHRvdWNoIGVuYWJsZWQgbGFwdG9wcyBsaWtlIHRoZSBDaHJvbWUgUGl4ZWxcbiAgICBpZiAoTGliLlRPVUNIX0VOQUJMRUQgJiYgb3B0aW9ucy5uYXRpdmVDb250cm9sc0ZvclRvdWNoID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3VzZW5hdGl2ZWNvbnRyb2xzJyk7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgfVxuXG5cbiAgZGlzcG9zZSgpIHtcbiAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KHRoaXMuZWxfKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICBjcmVhdGVFbCgpIHtcbiAgICBsZXQgZWwgPSB0aGlzLm9wdGlvbnNfLnRhZztcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBtb3ZpbmcgdGhlIGVsZW1lbnQgaW50byB0aGUgYm94LlxuICAgIC8vIE9uIHRoZSBpUGhvbmUgdmlkZW8gd2lsbCBicmVhayBpZiB5b3UgbW92ZSB0aGUgZWxlbWVudCxcbiAgICAvLyBTbyB3ZSBoYXZlIHRvIGNyZWF0ZSBhIGJyYW5kIG5ldyBlbGVtZW50LlxuICAgIGlmICghZWwgfHwgdGhpc1snbW92aW5nTWVkaWFFbGVtZW50SW5ET00nXSA9PT0gZmFsc2UpIHtcblxuICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIHRhZyBpcyBzdGlsbCB0aGVyZSwgY2xvbmUgYW5kIHJlbW92ZSBpdC5cbiAgICAgIGlmIChlbCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIEh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQoZWwpO1xuICAgICAgICBlbCA9IGNsb25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSBMaWIuY3JlYXRlRWwoJ3ZpZGVvJyk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgdXNlZFxuICAgICAgICBsZXQgdGFnQXR0cmlidXRlcyA9IHRoaXMub3B0aW9uc18udGFnICYmIExpYi5nZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLm9wdGlvbnNfLnRhZyk7XG4gICAgICAgIGxldCBhdHRyaWJ1dGVzID0gVmpzVXRpbC5tZXJnZU9wdGlvbnMoe30sIHRhZ0F0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoIUxpYi5UT1VDSF9FTkFCTEVEIHx8IHRoaXMub3B0aW9uc18ubmF0aXZlQ29udHJvbHNGb3JUb3VjaCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNvbnRyb2xzO1xuICAgICAgICB9XG5cbiAgICAgICAgTGliLnNldEVsZW1lbnRBdHRyaWJ1dGVzKGVsLFxuICAgICAgICAgIExpYi5vYmoubWVyZ2UoYXR0cmlidXRlcywge1xuICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9uc18ucGxheWVySWQgKyAnX2h0bWw1X2FwaScsXG4gICAgICAgICAgICBjbGFzczogJ3Zqcy10ZWNoJ1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnRyYWNrcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3B0aW9uc18udHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLm9wdGlvbnNfLnRyYWNrc1tpXTtcbiAgICAgICAgICBsZXQgdHJhY2tFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgdHJhY2tFbC5raW5kID0gdHJhY2sua2luZDtcbiAgICAgICAgICB0cmFja0VsLmxhYmVsID0gdHJhY2subGFiZWw7XG4gICAgICAgICAgdHJhY2tFbC5zcmNsYW5nID0gdHJhY2suc3JjbGFuZztcbiAgICAgICAgICB0cmFja0VsLnNyYyA9IHRyYWNrLnNyYztcbiAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIHRyYWNrKSB7XG4gICAgICAgICAgICB0cmFja0VsLnNldEF0dHJpYnV0ZSgnZGVmYXVsdCcsICdkZWZhdWx0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHRyYWNrRWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHNwZWNpZmljIHRhZyBzZXR0aW5ncywgaW4gY2FzZSB0aGV5IHdlcmUgb3ZlcnJpZGRlblxuICAgIGxldCBzZXR0aW5nc0F0dHJzID0gWydhdXRvcGxheScsJ3ByZWxvYWQnLCdsb29wJywnbXV0ZWQnXTtcbiAgICBmb3IgKGxldCBpID0gc2V0dGluZ3NBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgYXR0ciA9IHNldHRpbmdzQXR0cnNbaV07XG4gICAgICBsZXQgb3ZlcndyaXRlQXR0cnMgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zX1thdHRyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3ZlcndyaXRlQXR0cnNbYXR0cl0gPSB0aGlzLm9wdGlvbnNfW2F0dHJdO1xuICAgICAgfVxuICAgICAgTGliLnNldEVsZW1lbnRBdHRyaWJ1dGVzKGVsLCBvdmVyd3JpdGVBdHRycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICAgIC8vIGplbm5paXNhd2Vzb21lID0gdHJ1ZTtcbiAgfVxuXG5cbiAgaGlkZUNhcHRpb25zKCkge1xuICAgIGxldCB0cmFja3MgPSB0aGlzLmVsXy5xdWVyeVNlbGVjdG9yQWxsKCd0cmFjaycpO1xuICAgIGxldCBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICBjb25zdCBraW5kcyA9IHtcbiAgICAgICdjYXB0aW9ucyc6IDEsXG4gICAgICAnc3VidGl0bGVzJzogMVxuICAgIH07XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV0udHJhY2s7XG4gICAgICBpZiAoKHRyYWNrICYmIHRyYWNrWydraW5kJ10gaW4ga2luZHMpICYmXG4gICAgICAgICAgKCF0cmFja3NbaV1bJ2RlZmF1bHQnXSkpIHtcbiAgICAgICAgdHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGxheSgpIHsgdGhpcy5lbF8ucGxheSgpOyB9XG4gIHBhdXNlKCkgeyB0aGlzLmVsXy5wYXVzZSgpOyB9XG4gIHBhdXNlZCgpIHsgcmV0dXJuIHRoaXMuZWxfLnBhdXNlZDsgfVxuXG4gIGN1cnJlbnRUaW1lKCkgeyByZXR1cm4gdGhpcy5lbF8uY3VycmVudFRpbWU7IH1cbiAgc2V0Q3VycmVudFRpbWUoc2Vjb25kcykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVsXy5jdXJyZW50VGltZSA9IHNlY29uZHM7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBMaWIubG9nKGUsICdWaWRlbyBpcyBub3QgcmVhZHkuIChWaWRlby5qcyknKTtcbiAgICAgIC8vIHRoaXMud2FybmluZyhWaWRlb0pTLndhcm5pbmdzLnZpZGVvTm90UmVhZHkpO1xuICAgIH1cbiAgfVxuXG4gIGR1cmF0aW9uKCkgeyByZXR1cm4gdGhpcy5lbF8uZHVyYXRpb24gfHwgMDsgfVxuXG4gIGJ1ZmZlcmVkKCkgeyByZXR1cm4gdGhpcy5lbF8uYnVmZmVyZWQ7IH1cblxuICB2b2x1bWUoKSB7IHJldHVybiB0aGlzLmVsXy52b2x1bWU7IH1cbiAgc2V0Vm9sdW1lKHBlcmNlbnRBc0RlY2ltYWwpIHsgdGhpcy5lbF8udm9sdW1lID0gcGVyY2VudEFzRGVjaW1hbDsgfVxuXG4gIG11dGVkKCkgeyByZXR1cm4gdGhpcy5lbF8ubXV0ZWQ7IH1cbiAgc2V0TXV0ZWQobXV0ZWQpIHsgdGhpcy5lbF8ubXV0ZWQgPSBtdXRlZDsgfVxuXG4gIHdpZHRoKCkgeyByZXR1cm4gdGhpcy5lbF8ub2Zmc2V0V2lkdGg7IH1cbiAgaGVpZ2h0KCkgeyAgcmV0dXJuIHRoaXMuZWxfLm9mZnNldEhlaWdodDsgfVxuXG4gIHN1cHBvcnRzRnVsbFNjcmVlbigpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWxfLndlYmtpdEVudGVyRnVsbFNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAvLyBTZWVtcyB0byBiZSBicm9rZW4gaW4gQ2hyb21pdW0vQ2hyb21lICYmIFNhZmFyaSBpbiBMZW9wYXJkXG4gICAgICBpZiAoL0FuZHJvaWQvLnRlc3QoTGliLlVTRVJfQUdFTlQpIHx8ICEvQ2hyb21lfE1hYyBPUyBYIDEwLjUvLnRlc3QoTGliLlVTRVJfQUdFTlQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBlbnRlckZ1bGxTY3JlZW4oKSB7XG4gICAgdmFyIHZpZGVvID0gdGhpcy5lbF87XG5cbiAgICBpZiAoJ3dlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuJyBpbiB2aWRlbykge1xuICAgICAgdGhpcy5vbmUoJ3dlYmtpdGJlZ2luZnVsbHNjcmVlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9uZSgnd2Via2l0ZW5kZnVsbHNjcmVlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh2aWRlby5wYXVzZWQgJiYgdmlkZW8ubmV0d29ya1N0YXRlIDw9IHZpZGVvLkhBVkVfTUVUQURBVEEpIHtcbiAgICAgIC8vIGF0dGVtcHQgdG8gcHJpbWUgdGhlIHZpZGVvIGVsZW1lbnQgZm9yIHByb2dyYW1tYXRpYyBhY2Nlc3NcbiAgICAgIC8vIHRoaXMgaXNuJ3QgbmVjZXNzYXJ5IG9uIHRoZSBkZXNrdG9wIGJ1dCBzaG91bGRuJ3QgaHVydFxuICAgICAgdGhpcy5lbF8ucGxheSgpO1xuXG4gICAgICAvLyBwbGF5aW5nIGFuZCBwYXVzaW5nIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHRvIGZ1bGxzY3JlZW5cbiAgICAgIC8vIGNhbiBnZXQgaU9TIH42LjEgZGV2aWNlcyBpbnRvIGEgcGxheS9wYXVzZSBsb29wXG4gICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgdmlkZW8ucGF1c2UoKTtcbiAgICAgICAgdmlkZW8ud2Via2l0RW50ZXJGdWxsU2NyZWVuKCk7XG4gICAgICB9LCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW8ud2Via2l0RW50ZXJGdWxsU2NyZWVuKCk7XG4gICAgfVxuICB9XG5cbiAgZXhpdEZ1bGxTY3JlZW4oKSB7XG4gICAgdGhpcy5lbF8ud2Via2l0RXhpdEZ1bGxTY3JlZW4oKTtcbiAgfVxuXG4gIHNyYyhzcmMpIHtcbiAgICBpZiAoc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsXy5zcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHRpbmcgc3JjIHRocm91Z2ggYHNyY2AgaW5zdGVhZCBvZiBgc2V0U3JjYCB3aWxsIGJlIGRlcHJlY2F0ZWRcbiAgICAgIHRoaXMuc2V0U3JjKHNyYyk7XG4gICAgfVxuICB9XG5cbiAgc2V0U3JjKHNyYykgeyB0aGlzLmVsXy5zcmMgPSBzcmM7IH1cblxuICBsb2FkKCl7IHRoaXMuZWxfLmxvYWQoKTsgfVxuXG4gIGN1cnJlbnRTcmMoKSB7IHJldHVybiB0aGlzLmVsXy5jdXJyZW50U3JjOyB9XG5cbiAgcG9zdGVyKCkgeyByZXR1cm4gdGhpcy5lbF8ucG9zdGVyOyB9XG4gIHNldFBvc3Rlcih2YWwpIHsgdGhpcy5lbF8ucG9zdGVyID0gdmFsOyB9XG5cbiAgcHJlbG9hZCgpIHsgcmV0dXJuIHRoaXMuZWxfLnByZWxvYWQ7IH1cbiAgc2V0UHJlbG9hZCh2YWwpIHsgdGhpcy5lbF8ucHJlbG9hZCA9IHZhbDsgfVxuXG4gIGF1dG9wbGF5KCkgeyByZXR1cm4gdGhpcy5lbF8uYXV0b3BsYXk7IH1cbiAgc2V0QXV0b3BsYXkodmFsKSB7IHRoaXMuZWxfLmF1dG9wbGF5ID0gdmFsOyB9XG5cbiAgY29udHJvbHMoKSB7IHJldHVybiB0aGlzLmVsXy5jb250cm9sczsgfVxuICBzZXRDb250cm9scyh2YWwpIHsgdGhpcy5lbF8uY29udHJvbHMgPSAhIXZhbDsgfVxuXG4gIGxvb3AoKSB7IHJldHVybiB0aGlzLmVsXy5sb29wOyB9XG4gIHNldExvb3AodmFsKSB7IHRoaXMuZWxfLmxvb3AgPSB2YWw7IH1cblxuICBlcnJvcigpIHsgcmV0dXJuIHRoaXMuZWxfLmVycm9yOyB9XG4gIHNlZWtpbmcoKSB7IHJldHVybiB0aGlzLmVsXy5zZWVraW5nOyB9XG4gIGVuZGVkKCkgeyByZXR1cm4gdGhpcy5lbF8uZW5kZWQ7IH1cbiAgZGVmYXVsdE11dGVkKCkgeyByZXR1cm4gdGhpcy5lbF8uZGVmYXVsdE11dGVkOyB9XG5cbiAgcGxheWJhY2tSYXRlKCkgeyByZXR1cm4gdGhpcy5lbF8ucGxheWJhY2tSYXRlOyB9XG4gIHNldFBsYXliYWNrUmF0ZSh2YWwpIHsgdGhpcy5lbF8ucGxheWJhY2tSYXRlID0gdmFsOyB9XG5cbiAgbmV0d29ya1N0YXRlKCkgeyByZXR1cm4gdGhpcy5lbF8ubmV0d29ya1N0YXRlOyB9XG4gIHJlYWR5U3RhdGUoKSB7IHJldHVybiB0aGlzLmVsXy5yZWFkeVN0YXRlOyB9XG5cbiAgdGV4dFRyYWNrcygpIHtcbiAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICByZXR1cm4gc3VwZXIudGV4dFRyYWNrcygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsXy50ZXh0VHJhY2tzO1xuICB9XG4gIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICByZXR1cm4gc3VwZXIuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWxfLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9XG5cbiAgYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnM9e30pIHtcbiAgICBpZiAoIXRoaXNbJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICByZXR1cm4gc3VwZXIuYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XG5cbiAgICBpZiAob3B0aW9uc1sna2luZCddKSB7XG4gICAgICB0cmFja1sna2luZCddID0gb3B0aW9uc1sna2luZCddO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snbGFiZWwnXSkge1xuICAgICAgdHJhY2tbJ2xhYmVsJ10gPSBvcHRpb25zWydsYWJlbCddO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snbGFuZ3VhZ2UnXSB8fCBvcHRpb25zWydzcmNsYW5nJ10pIHtcbiAgICAgIHRyYWNrWydzcmNsYW5nJ10gPSBvcHRpb25zWydsYW5ndWFnZSddIHx8IG9wdGlvbnNbJ3NyY2xhbmcnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ2RlZmF1bHQnXSkge1xuICAgICAgdHJhY2tbJ2RlZmF1bHQnXSA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ2lkJ10pIHtcbiAgICAgIHRyYWNrWydpZCddID0gb3B0aW9uc1snaWQnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ3NyYyddKSB7XG4gICAgICB0cmFja1snc3JjJ10gPSBvcHRpb25zWydzcmMnXTtcbiAgICB9XG5cbiAgICB0aGlzLmVsKCkuYXBwZW5kQ2hpbGQodHJhY2spO1xuXG4gICAgaWYgKHRyYWNrLnRyYWNrWydraW5kJ10gPT09ICdtZXRhZGF0YScpIHtcbiAgICAgIHRyYWNrWyd0cmFjayddWydtb2RlJ10gPSAnaGlkZGVuJztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2tbJ3RyYWNrJ11bJ21vZGUnXSA9ICdkaXNhYmxlZCc7XG4gICAgfVxuXG4gICAgdHJhY2tbJ29ubG9hZCddID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHQgPSB0cmFja1sndHJhY2snXTtcbiAgICAgIGlmICh0cmFjay5yZWFkeVN0YXRlID49IDIpIHtcbiAgICAgICAgaWYgKHR0WydraW5kJ10gPT09ICdtZXRhZGF0YScgJiYgdHRbJ21vZGUnXSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICB0dFsnbW9kZSddID0gJ2hpZGRlbic7XG4gICAgICAgIH0gZWxzZSBpZiAodHRbJ2tpbmQnXSAhPT0gJ21ldGFkYXRhJyAmJiB0dFsnbW9kZSddICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgdHRbJ21vZGUnXSA9ICdkaXNhYmxlZCc7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tbJ29ubG9hZCddID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2tfKHRyYWNrLnRyYWNrKTtcblxuICAgIHJldHVybiB0cmFjaztcbiAgfVxuXG4gIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIGlmICghdGhpc1snZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10pIHtcbiAgICAgIHJldHVybiBzdXBlci5yZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgIH1cblxuICAgIHZhciB0cmFja3MsIGk7XG5cbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5yZW1vdmVUcmFja18odHJhY2spO1xuXG4gICAgdHJhY2tzID0gdGhpcy5lbCgpWydxdWVyeVNlbGVjdG9yQWxsJ10oJ3RyYWNrJyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tzW2ldID09PSB0cmFjayB8fCB0cmFja3NbaV1bJ3RyYWNrJ10gPT09IHRyYWNrKSB7XG4gICAgICAgIHRyYWNrc1tpXVsncGFyZW50Tm9kZSddWydyZW1vdmVDaGlsZCddKHRyYWNrc1tpXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cblxuLyogSFRNTDUgU3VwcG9ydCBUZXN0aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBIVE1MNSB2aWRlbyBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpe1xuICAvLyBJRTkgd2l0aCBubyBNZWRpYSBQbGF5ZXIgaXMgYSBMSUFSISAoIzk4NClcbiAgdHJ5IHtcbiAgICBMaWIuVEVTVF9WSURbJ3ZvbHVtZSddID0gMC41O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhTGliLlRFU1RfVklELmNhblBsYXlUeXBlO1xufTtcblxuLy8gQWRkIFNvdXJjZSBIYW5kbGVyIHBhdHRlcm4gZnVuY3Rpb25zIHRvIHRoaXMgdGVjaFxuVGVjaC53aXRoU291cmNlSGFuZGxlcnMoSHRtbDUpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG5hdGl2ZSBzb3VyY2UgaGFuZGxlci5cbiAqIFRoaXMgc2ltcGx5IHBhc3NlcyB0aGUgc291cmNlIHRvIHRoZSB2aWRlbyBlbGVtZW50LiBOb3RoaW5nIGZhbmN5LlxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgICBUaGUgc291cmNlIG9iamVjdFxuICogQHBhcmFtICB7SHRtbDV9IHRlY2ggIFRoZSBpbnN0YW5jZSBvZiB0aGUgSFRNTDUgdGVjaFxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyID0ge307XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZpZGVvIGVsZW1lbnQgY2FuIGhhbmRsZSB0aGUgc291cmNlIG5hdGl2ZWx5XG4gKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZSAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhbkhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSl7XG4gIHZhciBtYXRjaCwgZXh0O1xuXG4gIGZ1bmN0aW9uIGNhblBsYXlUeXBlKHR5cGUpe1xuICAgIC8vIElFOSBvbiBXaW5kb3dzIDcgd2l0aG91dCBNZWRpYVBsYXllciB0aHJvd3MgYW4gZXJyb3IgaGVyZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy81MTlcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIExpYi5URVNUX1ZJRC5jYW5QbGF5VHlwZSh0eXBlKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICAvLyBJZiBhIHR5cGUgd2FzIHByb3ZpZGVkIHdlIHNob3VsZCByZWx5IG9uIHRoYXRcbiAgaWYgKHNvdXJjZS50eXBlKSB7XG4gICAgcmV0dXJuIGNhblBsYXlUeXBlKHNvdXJjZS50eXBlKTtcbiAgfSBlbHNlIGlmIChzb3VyY2Uuc3JjKSB7XG4gICAgLy8gSWYgbm8gdHlwZSwgZmFsbCBiYWNrIHRvIGNoZWNraW5nICd2aWRlby9bRVhURU5TSU9OXSdcbiAgICBleHQgPSBMaWIuZ2V0RmlsZUV4dGVuc2lvbihzb3VyY2Uuc3JjKTtcblxuICAgIHJldHVybiBjYW5QbGF5VHlwZShgdmlkZW8vJHtleHR9YCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIFBhc3MgdGhlIHNvdXJjZSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICogQWRhcHRpdmUgc291cmNlIGhhbmRsZXJzIHdpbGwgaGF2ZSBtb3JlIGNvbXBsaWNhdGVkIHdvcmtmbG93cyBiZWZvcmUgcGFzc2luZ1xuICogdmlkZW8gZGF0YSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0h0bWw1fSB0ZWNoICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIdG1sNSB0ZWNoXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuaGFuZGxlU291cmNlID0gZnVuY3Rpb24oc291cmNlLCB0ZWNoKXtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBzb3VyY2UgaGFuZGxlciB3aGVuIGRpc3Bvc2luZyB0aGUgcGxheWVyIG9yIHN3aXRjaGluZyBzb3VyY2VzLi5cbiAqIChubyBjbGVhbnVwIGlzIG5lZWRlZCB3aGVuIHN1cHBvcnRpbmcgdGhlIGZvcm1hdCBuYXRpdmVseSlcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5kaXNwb3NlID0gZnVuY3Rpb24oKXt9O1xuXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG5IdG1sNS5yZWdpc3RlclNvdXJjZUhhbmRsZXIoSHRtbDUubmF0aXZlU291cmNlSGFuZGxlcik7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZvbHVtZSBjYW4gYmUgY2hhbmdlZCBpbiB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICogVm9sdW1lIGNhbm5vdCBiZSBjaGFuZ2VkIGluIGEgbG90IG9mIG1vYmlsZSBkZXZpY2VzLlxuICogU3BlY2lmaWNhbGx5LCBpdCBjYW4ndCBiZSBjaGFuZ2VkIGZyb20gMSBvbiBpT1MuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5IdG1sNS5jYW5Db250cm9sVm9sdW1lID0gZnVuY3Rpb24oKXtcbiAgdmFyIHZvbHVtZSA9ICBMaWIuVEVTVF9WSUQudm9sdW1lO1xuICBMaWIuVEVTVF9WSUQudm9sdW1lID0gKHZvbHVtZSAvIDIpICsgMC4xO1xuICByZXR1cm4gdm9sdW1lICE9PSBMaWIuVEVTVF9WSUQudm9sdW1lO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBwbGF5YmFja1JhdGUgaXMgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwbGF5YmFja1JhdGUgPSAgTGliLlRFU1RfVklELnBsYXliYWNrUmF0ZTtcbiAgTGliLlRFU1RfVklELnBsYXliYWNrUmF0ZSA9IChwbGF5YmFja1JhdGUgLyAyKSArIDAuMTtcbiAgcmV0dXJuIHBsYXliYWNrUmF0ZSAhPT0gTGliLlRFU1RfVklELnBsYXliYWNrUmF0ZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSB0ZXh0IHRyYWNrcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VwcG9ydHNUZXh0VHJhY2tzO1xuXG4gIC8vIEZpZ3VyZSBvdXQgbmF0aXZlIHRleHQgdHJhY2sgc3VwcG9ydFxuICAvLyBJZiBtb2RlIGlzIGEgbnVtYmVyLCB3ZSBjYW5ub3QgY2hhbmdlIGl0IGJlY2F1c2UgaXQnbGwgZGlzYXBwZWFyIGZyb20gdmlldy5cbiAgLy8gQnJvd3NlcnMgd2l0aCBudW1lcmljIG1vZGVzIGluY2x1ZGUgSUUxMCBhbmQgb2xkZXIgKDw9MjAxMykgc2Ftc3VuZyBhbmRyb2lkIG1vZGVscy5cbiAgLy8gRmlyZWZveCBpc24ndCBwbGF5aW5nIG5pY2UgZWl0aGVyIHdpdGggbW9kaWZ5aW5nIHRoZSBtb2RlXG4gIC8vIFRPRE86IEludmVzdGlnYXRlIGZpcmVmb3g6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8xODYyXG4gIHN1cHBvcnRzVGV4dFRyYWNrcyA9ICEhTGliLlRFU1RfVklELnRleHRUcmFja3M7XG4gIGlmIChzdXBwb3J0c1RleHRUcmFja3MgJiYgTGliLlRFU1RfVklELnRleHRUcmFja3MubGVuZ3RoID4gMCkge1xuICAgIHN1cHBvcnRzVGV4dFRyYWNrcyA9IHR5cGVvZiBMaWIuVEVTVF9WSUQudGV4dFRyYWNrc1swXVsnbW9kZSddICE9PSAnbnVtYmVyJztcbiAgfVxuICBpZiAoc3VwcG9ydHNUZXh0VHJhY2tzICYmIExpYi5JU19GSVJFRk9YKSB7XG4gICAgc3VwcG9ydHNUZXh0VHJhY2tzID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3VwcG9ydHNUZXh0VHJhY2tzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRlY2gncyB2b2x1bWUgY29udHJvbCBzdXBwb3J0IHN0YXR1c1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnZmVhdHVyZXNWb2x1bWVDb250cm9sJ10gPSBIdG1sNS5jYW5Db250cm9sVm9sdW1lKCk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZWNoJ3MgcGxheWJhY2tSYXRlIHN1cHBvcnQgc3RhdHVzXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUucHJvdG90eXBlWydmZWF0dXJlc1BsYXliYWNrUmF0ZSddID0gSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSgpO1xuXG4vKipcbiAqIFNldCB0aGUgdGVjaCdzIHN0YXR1cyBvbiBtb3ZpbmcgdGhlIHZpZGVvIGVsZW1lbnQuXG4gKiBJbiBpT1MsIGlmIHlvdSBtb3ZlIGEgdmlkZW8gZWxlbWVudCBpbiB0aGUgRE9NLCBpdCBicmVha3MgdmlkZW8gcGxheWJhY2suXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUucHJvdG90eXBlWydtb3ZpbmdNZWRpYUVsZW1lbnRJbkRPTSddID0gIUxpYi5JU19JT1M7XG5cbi8qKlxuICogU2V0IHRoZSB0aGUgdGVjaCdzIGZ1bGxzY3JlZW4gcmVzaXplIHN1cHBvcnQgc3RhdHVzLlxuICogSFRNTCB2aWRlbyBpcyBhYmxlIHRvIGF1dG9tYXRpY2FsbHkgcmVzaXplIHdoZW4gZ29pbmcgdG8gZnVsbHNjcmVlbi5cbiAqIChObyBsb25nZXIgYXBwZWFycyB0byBiZSB1c2VkLiBDYW4gcHJvYmFibHkgYmUgcmVtb3ZlZC4pXG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnZmVhdHVyZXNGdWxsc2NyZWVuUmVzaXplJ10gPSB0cnVlO1xuXG4vKipcbiAqIFNldCB0aGUgdGVjaCdzIHByb2dyZXNzIGV2ZW50IHN1cHBvcnQgc3RhdHVzXG4gKiAodGhpcyBkaXNhYmxlcyB0aGUgbWFudWFsIHByb2dyZXNzIGV2ZW50cyBvZiB0aGUgVGVjaClcbiAqL1xuSHRtbDUucHJvdG90eXBlWydmZWF0dXJlc1Byb2dyZXNzRXZlbnRzJ10gPSB0cnVlO1xuXG4vKipcbiAqIFNldHMgdGhlIHRlY2gncyBzdGF0dXMgb24gbmF0aXZlIHRleHQgdHJhY2sgc3VwcG9ydFxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10gPSBIdG1sNS5zdXBwb3J0c05hdGl2ZVRleHRUcmFja3MoKTtcblxuLy8gSFRNTDUgRmVhdHVyZSBkZXRlY3Rpb24gYW5kIERldmljZSBGaXhlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbmxldCBjYW5QbGF5VHlwZTtcbmNvbnN0IG1wZWd1cmxSRSA9IC9eYXBwbGljYXRpb25cXC8oPzp4LXx2bmRcXC5hcHBsZVxcLiltcGVndXJsL2k7XG5jb25zdCBtcDRSRSA9IC9edmlkZW9cXC9tcDQvaTtcblxuSHRtbDUucGF0Y2hDYW5QbGF5VHlwZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBBbmRyb2lkIDQuMCBhbmQgYWJvdmUgY2FuIHBsYXkgSExTIHRvIHNvbWUgZXh0ZW50IGJ1dCBpdCByZXBvcnRzIGJlaW5nIHVuYWJsZSB0byBkbyBzb1xuICBpZiAoTGliLkFORFJPSURfVkVSU0lPTiA+PSA0LjApIHtcbiAgICBpZiAoIWNhblBsYXlUeXBlKSB7XG4gICAgICBjYW5QbGF5VHlwZSA9IExpYi5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGU7XG4gICAgfVxuXG4gICAgTGliLlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICYmIG1wZWd1cmxSRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIEFuZHJvaWQgMi4yIGFuZCBsZXNzIGNhblBsYXlUeXBlIG1ldGhvZCB3aGljaCBpcyBicm9rZW5cbiAgaWYgKExpYi5JU19PTERfQU5EUk9JRCkge1xuICAgIGlmICghY2FuUGxheVR5cGUpIHtcbiAgICAgIGNhblBsYXlUeXBlID0gTGliLlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcbiAgICB9XG5cbiAgICBMaWIuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24odHlwZSl7XG4gICAgICBpZiAodHlwZSAmJiBtcDRSRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XG4gICAgfTtcbiAgfVxufTtcblxuSHRtbDUudW5wYXRjaENhblBsYXlUeXBlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByID0gTGliLlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcbiAgTGliLlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGNhblBsYXlUeXBlO1xuICBjYW5QbGF5VHlwZSA9IG51bGw7XG4gIHJldHVybiByO1xufTtcblxuLy8gYnkgZGVmYXVsdCwgcGF0Y2ggdGhlIHZpZGVvIGVsZW1lbnRcbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUoKTtcblxuSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uKGVsKXtcbiAgaWYgKCFlbCkgeyByZXR1cm47IH1cblxuICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBjaGlsZCB0cmFjayBvciBzb3VyY2Ugbm9kZXMgdG8gcHJldmVudCB0aGVpciBsb2FkaW5nXG4gIHdoaWxlKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBzcmMgcmVmZXJlbmNlLiBub3Qgc2V0dGluZyBgc3JjPScnYCBiZWNhdXNlIHRoYXQgY2F1c2VzIGEgd2FybmluZ1xuICAvLyBpbiBmaXJlZm94XG4gIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG5cbiAgLy8gZm9yY2UgdGhlIG1lZGlhIGVsZW1lbnQgdG8gdXBkYXRlIGl0cyBsb2FkaW5nIHN0YXRlIGJ5IGNhbGxpbmcgbG9hZCgpXG4gIC8vIGhvd2V2ZXIgSUUgb24gV2luZG93cyA3TiBoYXMgYSBidWcgdGhhdCB0aHJvd3MgYW4gZXJyb3Igc28gbmVlZCBhIHRyeS9jYXRjaCAoIzc5MylcbiAgaWYgKHR5cGVvZiBlbC5sb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gd3JhcHBpbmcgaW4gYW4gaWlmZSBzbyBpdCdzIG5vdCBkZW9wdGltaXplZCAoIzEwNjAjZGlzY3Vzc2lvbl9yMTAzMjQ0NzMpXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwubG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdIdG1sNScsIEh0bWw1KTtcbmV4cG9ydCBkZWZhdWx0IEh0bWw1O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG4vKipcbiAqIFRoZSBNZWRpYSBMb2FkZXIgaXMgdGhlIGNvbXBvbmVudCB0aGF0IGRlY2lkZXMgd2hpY2ggcGxheWJhY2sgdGVjaG5vbG9neSB0byBsb2FkXG4gKiB3aGVuIHRoZSBwbGF5ZXIgaXMgaW5pdGlhbGl6ZWQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIE1lZGlhTG9hZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBzb3VyY2VzIHdoZW4gdGhlIHBsYXllciBpcyBpbml0aWFsaXplZCxcbiAgICAvLyBsb2FkIHRoZSBmaXJzdCBzdXBwb3J0ZWQgcGxheWJhY2sgdGVjaG5vbG9neS5cbiAgICBpZiAoIXBsYXllci5vcHRpb25zX1snc291cmNlcyddIHx8IHBsYXllci5vcHRpb25zX1snc291cmNlcyddLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChsZXQgaT0wLCBqPXBsYXllci5vcHRpb25zX1sndGVjaE9yZGVyJ107IGk8ai5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdGVjaE5hbWUgPSBMaWIuY2FwaXRhbGl6ZShqW2ldKTtcbiAgICAgICAgbGV0IHRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KHRlY2hOYW1lKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRlY2ggJiYgdGVjaC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgcGxheWVyLmxvYWRUZWNoKHRlY2hOYW1lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAvLyBMb29wIHRocm91Z2ggcGxheWJhY2sgdGVjaG5vbG9naWVzIChIVE1MNSwgRmxhc2gpIGFuZCBjaGVjayBmb3Igc3VwcG9ydC5cbiAgICAgIC8vIC8vIFRoZW4gbG9hZCB0aGUgYmVzdCBzb3VyY2UuXG4gICAgICAvLyAvLyBBIGZldyBhc3N1bXB0aW9ucyBoZXJlOlxuICAgICAgLy8gLy8gICBBbGwgcGxheWJhY2sgdGVjaG5vbG9naWVzIHJlc3BlY3QgcHJlbG9hZCBmYWxzZS5cbiAgICAgIHBsYXllci5zcmMocGxheWVyLm9wdGlvbnNfWydzb3VyY2VzJ10pO1xuICAgIH1cbiAgfVxufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lZGlhTG9hZGVyJywgTWVkaWFMb2FkZXIpO1xuZXhwb3J0IGRlZmF1bHQgTWVkaWFMb2FkZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWVkaWEgVGVjaG5vbG9neSBDb250cm9sbGVyIC0gQmFzZSBjbGFzcyBmb3IgbWVkaWEgcGxheWJhY2tcbiAqIHRlY2hub2xvZ3kgY29udHJvbGxlcnMgbGlrZSBGbGFzaCBhbmQgSFRNTDVcbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgVGV4dFRyYWNrIGZyb20gJy4uL3RyYWNrcy90ZXh0LXRyYWNrJztcbmltcG9ydCBUZXh0VHJhY2tMaXN0IGZyb20gJy4uL3RyYWNrcy90ZXh0LXRyYWNrLWxpc3QnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbWVkaWEgKEhUTUw1IFZpZGVvLCBGbGFzaCkgY29udHJvbGxlcnNcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyICBDZW50cmFsIHBsYXllciBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVGVjaCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz17fSwgcmVhZHk9ZnVuY3Rpb24oKXt9KXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSB0ZWNoIHRvIHJlcG9ydCB1c2VyIGFjdGl2aXR5IGF1dG9tYXRpY2FsbHkuXG4gICAgLy8gVGhpcyBpcyBkb25lIG1hbnVhbGx5IGluIGFkZENvbnRyb2xzTGlzdGVuZXJzXG4gICAgb3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ID0gZmFsc2U7XG4gICAgc3VwZXIobnVsbCwgb3B0aW9ucywgcmVhZHkpO1xuXG4gICAgdGhpcy50ZXh0VHJhY2tzXyA9IG9wdGlvbnMudGV4dFRyYWNrcztcblxuICAgIC8vIE1hbnVhbGx5IHRyYWNrIHByb2dyZXNzIGluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyL2ZsYXNoIHBsYXllciBkb2Vzbid0IHJlcG9ydCBpdC5cbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNQcm9ncmVzc0V2ZW50cykge1xuICAgICAgdGhpcy5tYW51YWxQcm9ncmVzc09uKCk7XG4gICAgfVxuXG4gICAgLy8gTWFudWFsbHkgdHJhY2sgdGltZXVwZGF0ZXMgaW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIvZmxhc2ggcGxheWVyIGRvZXNuJ3QgcmVwb3J0IGl0LlxuICAgIGlmICghdGhpcy5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMpIHtcbiAgICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXNPbigpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdENvbnRyb2xzTGlzdGVuZXJzKCk7XG5cbiAgICBpZiAob3B0aW9ucy5uYXRpdmVDYXB0aW9ucyA9PT0gZmFsc2UgfHwgb3B0aW9ucy5uYXRpdmVUZXh0VHJhY2tzID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB0aGlzLmVtdWxhdGVUZXh0VHJhY2tzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0VGV4dFRyYWNrTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGNsaWNrIGFuZCB0b3VjaCBsaXN0ZW5lcnMgZm9yIHRoZSBwbGF5YmFjayBlbGVtZW50XG4gICAqIE9uIGRlc2t0b3BzLCBhIGNsaWNrIG9uIHRoZSB2aWRlbyBpdHNlbGYgd2lsbCB0b2dnbGUgcGxheWJhY2ssXG4gICAqIG9uIGEgbW9iaWxlIGRldmljZSBhIGNsaWNrIG9uIHRoZSB2aWRlbyB0b2dnbGVzIGNvbnRyb2xzLlxuICAgKiAodG9nZ2xpbmcgY29udHJvbHMgaXMgZG9uZSBieSB0b2dnbGluZyB0aGUgdXNlciBzdGF0ZSBiZXR3ZWVuIGFjdGl2ZSBhbmRcbiAgICogaW5hY3RpdmUpXG4gICAqXG4gICAqIEEgdGFwIGNhbiBzaWduYWwgdGhhdCBhIHVzZXIgaGFzIGJlY29tZSBhY3RpdmUsIG9yIGhhcyBiZWNvbWUgaW5hY3RpdmVcbiAgICogZS5nLiBhIHF1aWNrIHRhcCBvbiBhbiBpUGhvbmUgbW92aWUgc2hvdWxkIHJldmVhbCB0aGUgY29udHJvbHMuIEFub3RoZXJcbiAgICogcXVpY2sgdGFwIHNob3VsZCBoaWRlIHRoZW0gYWdhaW4gKHNpZ25hbGluZyB0aGUgdXNlciBpcyBpbiBhbiBpbmFjdGl2ZVxuICAgKiB2aWV3aW5nIHN0YXRlKVxuICAgKlxuICAgKiBJbiBhZGRpdGlvbiB0byB0aGlzLCB3ZSBzdGlsbCB3YW50IHRoZSB1c2VyIHRvIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmUgYWZ0ZXJcbiAgICogYSBmZXcgc2Vjb25kcyBvZiBpbmFjdGl2aXR5LlxuICAgKlxuICAgKiBOb3RlOiB0aGUgb25seSBwYXJ0IG9mIGlPUyBpbnRlcmFjdGlvbiB3ZSBjYW4ndCBtaW1pYyB3aXRoIHRoaXMgc2V0dXBcbiAgICogaXMgYSB0b3VjaCBhbmQgaG9sZCBvbiB0aGUgdmlkZW8gZWxlbWVudCBjb3VudGluZyBhcyBhY3Rpdml0eSBpbiBvcmRlciB0b1xuICAgKiBrZWVwIHRoZSBjb250cm9scyBzaG93aW5nLCBidXQgdGhhdCBzaG91bGRuJ3QgYmUgYW4gaXNzdWUuIEEgdG91Y2ggYW5kIGhvbGQgb25cbiAgICogYW55IGNvbnRyb2xzIHdpbGwgc3RpbGwga2VlcCB0aGUgdXNlciBhY3RpdmVcbiAgICovXG4gIGluaXRDb250cm9sc0xpc3RlbmVycygpIHtcbiAgICAvLyBpZiB3ZSdyZSBsb2FkaW5nIHRoZSBwbGF5YmFjayBvYmplY3QgYWZ0ZXIgaXQgaGFzIHN0YXJ0ZWQgbG9hZGluZyBvciBwbGF5aW5nIHRoZVxuICAgIC8vIHZpZGVvIChvZnRlbiB3aXRoIGF1dG9wbGF5IG9uKSB0aGVuIHRoZSBsb2Fkc3RhcnQgZXZlbnQgaGFzIGFscmVhZHkgZmlyZWQgYW5kIHdlXG4gICAgLy8gbmVlZCB0byBmaXJlIGl0IG1hbnVhbGx5IGJlY2F1c2UgbWFueSB0aGluZ3MgcmVseSBvbiBpdC5cbiAgICAvLyBMb25nIHRlcm0gd2UgbWlnaHQgY29uc2lkZXIgaG93IHdlIHdvdWxkIGRvIHRoaXMgZm9yIG90aGVyIGV2ZW50cyBsaWtlICdjYW5wbGF5J1xuICAgIC8vIHRoYXQgbWF5IGFsc28gaGF2ZSBmaXJlZC5cbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAodGhpcy5uZXR3b3JrU3RhdGUgJiYgdGhpcy5uZXR3b3JrU3RhdGUoKSA+IDApIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qIEZhbGxiYWNrcyBmb3IgdW5zdXBwb3J0ZWQgZXZlbnQgdHlwZXNcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgLy8gTWFudWFsbHkgdHJpZ2dlciBwcm9ncmVzcyBldmVudHMgYmFzZWQgb24gY2hhbmdlcyB0byB0aGUgYnVmZmVyZWQgYW1vdW50XG4gIC8vIE1hbnkgZmxhc2ggcGxheWVycyBhbmQgb2xkZXIgSFRNTDUgYnJvd3NlcnMgZG9uJ3Qgc2VuZCBwcm9ncmVzcyBvciBwcm9ncmVzcy1saWtlIGV2ZW50c1xuICBtYW51YWxQcm9ncmVzc09uKCkge1xuICAgIHRoaXMub24oJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy5vbkR1cmF0aW9uQ2hhbmdlKTtcblxuICAgIHRoaXMubWFudWFsUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgLy8gVHJpZ2dlciBwcm9ncmVzcyB3YXRjaGluZyB3aGVuIGEgc291cmNlIGJlZ2lucyBsb2FkaW5nXG4gICAgdGhpcy50cmFja1Byb2dyZXNzKCk7XG4gIH1cblxuICBtYW51YWxQcm9ncmVzc09mZigpIHtcbiAgICB0aGlzLm1hbnVhbFByb2dyZXNzID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuXG4gICAgdGhpcy5vZmYoJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy5vbkR1cmF0aW9uQ2hhbmdlKTtcbiAgfVxuXG4gIHRyYWNrUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5wcm9ncmVzc0ludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChMaWIuYmluZCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciB1bmxlc3MgYnVmZmVyZWQgYW1vdW50IGlzIGdyZWF0ZXIgdGhhbiBsYXN0IHRpbWVcblxuICAgICAgbGV0IGJ1ZmZlcmVkUGVyY2VudCA9IHRoaXMuYnVmZmVyZWRQZXJjZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkUGVyY2VudF8gIT09IGJ1ZmZlcmVkUGVyY2VudCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVmZmVyZWRQZXJjZW50XyA9IGJ1ZmZlcmVkUGVyY2VudDtcblxuICAgICAgaWYgKGJ1ZmZlcmVkUGVyY2VudCA9PT0gMSkge1xuICAgICAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG4gICAgICB9XG4gICAgfSksIDUwMCk7XG4gIH1cblxuICBvbkR1cmF0aW9uQ2hhbmdlKCkge1xuICAgIHRoaXMuZHVyYXRpb25fID0gdGhpcy5kdXJhdGlvbigpO1xuICB9XG5cbiAgYnVmZmVyZWRQZXJjZW50KCkge1xuICAgIGxldCBidWZmZXJlZER1cmF0aW9uID0gMCxcbiAgICAgICAgc3RhcnQsIGVuZDtcblxuICAgIGlmICghdGhpcy5kdXJhdGlvbl8pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGxldCBidWZmZXJlZCA9IHRoaXMuYnVmZmVyZWQoKTtcblxuICAgIGlmICghYnVmZmVyZWQgfHwgIWJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgYnVmZmVyZWQgPSBMaWIuY3JlYXRlVGltZVJhbmdlKDAsMCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaT0wOyBpPGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKXtcbiAgICAgIHN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICBlbmQgICA9IGJ1ZmZlcmVkLmVuZChpKTtcblxuICAgICAgLy8gYnVmZmVyZWQgZW5kIGNhbiBiZSBiaWdnZXIgdGhhbiBkdXJhdGlvbiBieSBhIHZlcnkgc21hbGwgZnJhY3Rpb25cbiAgICAgIGlmIChlbmQgPiB0aGlzLmR1cmF0aW9uXykge1xuICAgICAgICBlbmQgPSB0aGlzLmR1cmF0aW9uXztcbiAgICAgIH1cblxuICAgICAgYnVmZmVyZWREdXJhdGlvbiArPSBlbmQgLSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyZWREdXJhdGlvbiAvIHRoaXMuZHVyYXRpb25fO1xuICB9XG5cbiAgc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCk7XG4gIH1cblxuICAvKiEgVGltZSBUcmFja2luZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBtYW51YWxUaW1lVXBkYXRlc09uKCkge1xuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgdGhpcy5vbigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vbigncGF1c2UnLCB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKTtcbiAgICAvLyB0aW1ldXBkYXRlIGlzIGFsc28gY2FsbGVkIGJ5IC5jdXJyZW50VGltZSB3aGVuZXZlciBjdXJyZW50IHRpbWUgaXMgc2V0XG5cbiAgICAvLyBXYXRjaCBmb3IgbmF0aXZlIHRpbWV1cGRhdGUgZXZlbnQgb25seVxuICAgIHZhciBvblRpbWVVcGRhdGUgPSBmdW5jdGlvbihlKXtcbiAgICAgIGlmIChlLm1hbnVhbGx5VHJpZ2dlcmVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMub2ZmKCd0aW1ldXBkYXRlJywgb25UaW1lVXBkYXRlKTtcblxuICAgICAgLy8gVXBkYXRlIGtub3duIHByb2dyZXNzIHN1cHBvcnQgZm9yIHRoaXMgcGxheWJhY2sgdGVjaG5vbG9neVxuICAgICAgdGhpcy5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMgPSB0cnVlO1xuICAgICAgLy8gVHVybiBvZmYgbWFudWFsIHByb2dyZXNzIHRyYWNraW5nXG4gICAgICB0aGlzLm1hbnVhbFRpbWVVcGRhdGVzT2ZmKCk7XG4gICAgfTtcblxuICAgIHRoaXMub24oJ3RpbWV1cGRhdGUnLCBvblRpbWVVcGRhdGUpO1xuICB9XG5cbiAgbWFudWFsVGltZVVwZGF0ZXNPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB0aGlzLm9mZigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vZmYoJ3BhdXNlJywgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSk7XG4gIH1cblxuICB0cmFja0N1cnJlbnRUaW1lKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwpIHsgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpOyB9XG4gICAgdGhpcy5jdXJyZW50VGltZUludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbigpe1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICAgIH0sIDI1MCk7IC8vIDQyID0gMjQgZnBzIC8vIDI1MCBpcyB3aGF0IFdlYmtpdCB1c2VzIC8vIEZGIHVzZXMgMTVcbiAgfVxuXG4gIC8vIFR1cm4gb2ZmIHBsYXkgcHJvZ3Jlc3MgdHJhY2tpbmcgKHdoZW4gcGF1c2VkIG9yIGRyYWdnaW5nKVxuICBzdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpIHtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwodGhpcy5jdXJyZW50VGltZUludGVydmFsKTtcblxuICAgIC8vICMxMDAyIC0gaWYgdGhlIHZpZGVvIGVuZHMgcmlnaHQgYmVmb3JlIHRoZSBuZXh0IHRpbWV1cGRhdGUgd291bGQgaGFwcGVuLFxuICAgIC8vIHRoZSBwcm9ncmVzcyBiYXIgd29uJ3QgbWFrZSBpdCBhbGwgdGhlIHdheSB0byB0aGUgZW5kXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAvLyBUdXJuIG9mZiBhbnkgbWFudWFsIHByb2dyZXNzIG9yIHRpbWV1cGRhdGUgdHJhY2tpbmdcbiAgICBpZiAodGhpcy5tYW51YWxQcm9ncmVzcykgeyB0aGlzLm1hbnVhbFByb2dyZXNzT2ZmKCk7IH1cblxuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7IHRoaXMubWFudWFsVGltZVVwZGF0ZXNPZmYoKTsgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgc2V0Q3VycmVudFRpbWUoKSB7XG4gICAgLy8gaW1wcm92ZSB0aGUgYWNjdXJhY3kgb2YgbWFudWFsIHRpbWV1cGRhdGVzXG4gICAgaWYgKHRoaXMubWFudWFsVGltZVVwZGF0ZXMpIHsgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pOyB9XG4gIH1cblxuICBpbml0VGV4dFRyYWNrTGlzdGVuZXJzKCkge1xuICAgIGxldCB0ZXh0VHJhY2tMaXN0Q2hhbmdlcyA9IExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCd0ZXh0dHJhY2tjaGFuZ2UnKTtcbiAgICB9KTtcblxuICAgIGxldCB0cmFja3MgPSB0aGlzLnRleHRUcmFja3MoKTtcblxuICAgIGlmICghdHJhY2tzKSByZXR1cm47XG5cbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0ZXh0VHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrTGlzdENoYW5nZXMpO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdGV4dFRyYWNrTGlzdENoYW5nZXMpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrTGlzdENoYW5nZXMpO1xuICAgIH0pKTtcbiAgfVxuXG4gIGVtdWxhdGVUZXh0VHJhY2tzKCkge1xuICAgIGlmICghd2luZG93WydXZWJWVFQnXSAmJiB0aGlzLmVsKCkucGFyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQuc3JjID0gdGhpcy5vcHRpb25zX1sndnR0LmpzJ10gfHwgJy4uL25vZGVfbW9kdWxlcy92dHQuanMvZGlzdC92dHQuanMnO1xuICAgICAgdGhpcy5lbCgpLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgIHdpbmRvd1snV2ViVlRUJ10gPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCB0cmFja3MgPSB0aGlzLnRleHRUcmFja3MoKTtcbiAgICBpZiAoIXRyYWNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB0ZXh0VHJhY2tzQ2hhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHVwZGF0ZURpc3BsYXkgPSBMaWIuYmluZCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0ZXh0dHJhY2tjaGFuZ2UnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3RleHR0cmFja2NoYW5nZScpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRyYWNrID0gdGhpc1tpXTtcbiAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICAgIGlmICh0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCB1cGRhdGVEaXNwbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZSBkZWZhdWx0IG1ldGhvZHMgZm9yIHRleHQgdHJhY2tzLlxuICAgKlxuICAgKiBIdG1sNSB0ZWNoIG92ZXJyaWRlcyB0aGVzZS5cbiAgICovXG5cbiAgdGV4dFRyYWNrcygpIHtcbiAgICB0aGlzLnRleHRUcmFja3NfID0gdGhpcy50ZXh0VHJhY2tzXyB8fCBuZXcgVGV4dFRyYWNrTGlzdCgpO1xuICAgIHJldHVybiB0aGlzLnRleHRUcmFja3NfO1xuICB9XG5cbiAgcmVtb3RlVGV4dFRyYWNrcygpIHtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3NfID0gdGhpcy5yZW1vdGVUZXh0VHJhY2tzXyB8fCBuZXcgVGV4dFRyYWNrTGlzdCgpO1xuICAgIHJldHVybiB0aGlzLnJlbW90ZVRleHRUcmFja3NfO1xuICB9XG5cbiAgYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGlmICgha2luZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0VHJhY2sga2luZCBpcyByZXF1aXJlZCBidXQgd2FzIG5vdCBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVUcmFja0hlbHBlcih0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9XG5cbiAgYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpIHtcbiAgICBsZXQgdHJhY2sgPSBjcmVhdGVUcmFja0hlbHBlcih0aGlzLCBvcHRpb25zLmtpbmQsIG9wdGlvbnMubGFiZWwsIG9wdGlvbnMubGFuZ3VhZ2UsIG9wdGlvbnMpO1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLmFkZFRyYWNrXyh0cmFjayk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNrOiB0cmFja1xuICAgIH07XG4gIH1cblxuICByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcbiAgICB0aGlzLnRleHRUcmFja3MoKS5yZW1vdmVUcmFja18odHJhY2spO1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLnJlbW92ZVRyYWNrXyh0cmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZSBhIGRlZmF1bHQgc2V0UG9zdGVyIG1ldGhvZCBmb3IgdGVjaHNcbiAgICpcbiAgICogUG9zdGVyIHN1cHBvcnQgZm9yIHRlY2hzIHNob3VsZCBiZSBvcHRpb25hbCwgc28gd2UgZG9uJ3Qgd2FudCB0ZWNocyB0b1xuICAgKiBicmVhayBpZiB0aGV5IGRvbid0IGhhdmUgYSB3YXkgdG8gc2V0IGEgcG9zdGVyLlxuICAgKi9cbiAgc2V0UG9zdGVyKCkge31cblxufVxuXG4vKipcbiAqIExpc3Qgb2YgYXNzb2NpYXRlZCB0ZXh0IHRyYWNrc1xuICogQHR5cGUge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuVGVjaC5wcm90b3R5cGUudGV4dFRyYWNrc187XG5cbnZhciBjcmVhdGVUcmFja0hlbHBlciA9IGZ1bmN0aW9uKHNlbGYsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSwgb3B0aW9ucz17fSkge1xuICBsZXQgdHJhY2tzID0gc2VsZi50ZXh0VHJhY2tzKCk7XG5cbiAgb3B0aW9ucy5raW5kID0ga2luZDtcblxuICBpZiAobGFiZWwpIHtcbiAgICBvcHRpb25zLmxhYmVsID0gbGFiZWw7XG4gIH1cbiAgaWYgKGxhbmd1YWdlKSB7XG4gICAgb3B0aW9ucy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICB9XG4gIG9wdGlvbnMudGVjaCA9IHNlbGY7XG5cbiAgbGV0IHRyYWNrID0gbmV3IFRleHRUcmFjayhvcHRpb25zKTtcbiAgdHJhY2tzLmFkZFRyYWNrXyh0cmFjayk7XG5cbiAgcmV0dXJuIHRyYWNrO1xufTtcblxuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNWb2x1bWVDb250cm9sID0gdHJ1ZTtcblxuLy8gUmVzaXppbmcgcGx1Z2lucyB1c2luZyByZXF1ZXN0IGZ1bGxzY3JlZW4gcmVsb2FkcyB0aGUgcGx1Z2luXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc0Z1bGxzY3JlZW5SZXNpemUgPSBmYWxzZTtcblRlY2gucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gZmFsc2U7XG5cbi8vIE9wdGlvbmFsIGV2ZW50cyB0aGF0IHdlIGNhbiBtYW51YWxseSBtaW1pYyB3aXRoIHRpbWVyc1xuLy8gY3VycmVudGx5IG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gZmFsc2U7XG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMgPSBmYWxzZTtcblxuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gZmFsc2U7XG5cbi8qKlxuICogQSBmdW5jdGlvbmFsIG1peGluIGZvciB0ZWNocyB0aGF0IHdhbnQgdG8gdXNlIHRoZSBTb3VyY2UgSGFuZGxlciBwYXR0ZXJuLlxuICpcbiAqICMjIyMjIEVYQU1QTEU6XG4gKlxuICogICBUZWNoLndpdGhTb3VyY2VIYW5kbGVycy5jYWxsKE15VGVjaCk7XG4gKlxuICovXG5UZWNoLndpdGhTb3VyY2VIYW5kbGVycyA9IGZ1bmN0aW9uKF9UZWNoKXtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgc291cmNlIGhhbmRsZXJcbiAgICogU291cmNlIGhhbmRsZXJzIGFyZSBzY3JpcHRzIGZvciBoYW5kbGluZyBzcGVjaWZpYyBmb3JtYXRzLlxuICAgKiBUaGUgc291cmNlIGhhbmRsZXIgcGF0dGVybiBpcyB1c2VkIGZvciBhZGFwdGl2ZSBmb3JtYXRzIChITFMsIERBU0gpIHRoYXRcbiAgICogbWFudWFsbHkgbG9hZCB2aWRlbyBkYXRhIGFuZCBmZWVkIGl0IGludG8gYSBTb3VyY2UgQnVmZmVyIChNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucylcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGhhbmRsZXIgIFRoZSBzb3VyY2UgaGFuZGxlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgZmlyc3QgICAgUmVnaXN0ZXIgaXQgYmVmb3JlIGFueSBleGlzdGluZyBoYW5kbGVyc1xuICAgKi9cbiAgIF9UZWNoLnJlZ2lzdGVyU291cmNlSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIsIGluZGV4KXtcbiAgICBsZXQgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycztcblxuICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgIGluZGV4ID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgIH1cblxuICAgIGhhbmRsZXJzLnNwbGljZShpbmRleCwgMCwgaGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlXG4gICAqIFRPRE86IEFuc3dlciBxdWVzdGlvbjogc2hvdWxkICdwcm9iYWJseScgYmUgcHJpb3JpdGl6ZWQgb3ZlciAnbWF5YmUnXG4gICAqIEBwYXJhbSAge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgIFRoZSBmaXJzdCBzb3VyY2UgaGFuZGxlciB0aGF0IHN1cHBvcnRzIHRoZSBzb3VyY2VcbiAgICogQHJldHVybnMge251bGx9ICAgICAgICAgTnVsbCBpZiBubyBzb3VyY2UgaGFuZGxlciBpcyBmb3VuZFxuICAgKi9cbiAgIF9UZWNoLnNlbGVjdFNvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIGxldCBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIGxldCBjYW47XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5IYW5kbGVTb3VyY2Uoc291cmNlKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcnNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZVxuICAqIEBwYXJhbSAge09iamVjdH0gc3JjT2JqICBUaGUgc291cmNlIG9iamVjdFxuICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAqL1xuICBfVGVjaC5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24oc3JjT2JqKXtcbiAgICBsZXQgc2ggPSBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyKHNyY09iaik7XG5cbiAgICBpZiAoc2gpIHtcbiAgICAgIHJldHVybiBzaC5jYW5IYW5kbGVTb3VyY2Uoc3JjT2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSBzb3VyY2UgdXNpbmcgYSBzb3VyY2Ugb2JqZWN0XG4gICAqIGFuZCBzb3VyY2UgaGFuZGxlcnMuXG4gICAqIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgdW5sZXNzIGEgc291cmNlIGhhbmRsZXIgd2FzIGZvdW5kLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlICBBIHNvdXJjZSBvYmplY3Qgd2l0aCBzcmMgYW5kIHR5cGUga2V5c1xuICAgKiBAcmV0dXJuIHtUZWNofSBzZWxmXG4gICAqL1xuICAgX1RlY2gucHJvdG90eXBlLnNldFNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSl7XG4gICAgbGV0IHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzb3VyY2UpO1xuXG4gICAgaWYgKCFzaCkge1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIGEgbmF0aXZlIHNvdXJjZSBoYW5kZXIgd2hlbiB1bnN1cHBvcnRlZCBzb3VyY2VzIGFyZVxuICAgICAgLy8gZGVsaWJlcmF0ZWx5IHNldFxuICAgICAgaWYgKF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgc2ggPSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTGliLmxvZy5lcnJvcignTm8gc291cmNlIGhhbmRlciBmb3VuZCBmb3IgdGhlIGN1cnJlbnQgc291cmNlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpc3Bvc2UgYW55IGV4aXN0aW5nIHNvdXJjZSBoYW5kbGVyXG4gICAgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcigpO1xuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG5cbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gc291cmNlO1xuICAgIHRoaXMuc291cmNlSGFuZGxlcl8gPSBzaC5oYW5kbGVTb3VyY2Uoc291cmNlLCB0aGlzKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgYW55IGV4aXN0aW5nIHNvdXJjZSBoYW5kbGVyXG4gICAqL1xuICAgX1RlY2gucHJvdG90eXBlLmRpc3Bvc2VTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXyAmJiB0aGlzLnNvdXJjZUhhbmRsZXJfLmRpc3Bvc2UpIHtcbiAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcblxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZWNoJywgVGVjaCk7XG4vLyBPbGQgbmFtZSBmb3IgVGVjaFxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZWRpYVRlY2hDb250cm9sbGVyJywgVGVjaCk7XG5leHBvcnQgZGVmYXVsdCBUZWNoO1xuIiwiaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLypcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2tjdWVsaXN0XG4gKlxuICogaW50ZXJmYWNlIFRleHRUcmFja0N1ZUxpc3Qge1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBsZW5ndGg7XG4gKiAgIGdldHRlciBUZXh0VHJhY2tDdWUgKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICogICBUZXh0VHJhY2tDdWU/IGdldEN1ZUJ5SWQoRE9NU3RyaW5nIGlkKTtcbiAqIH07XG4gKi9cblxubGV0IFRleHRUcmFja0N1ZUxpc3QgPSBmdW5jdGlvbihjdWVzKSB7XG4gIGxldCBsaXN0ID0gdGhpcztcblxuICBpZiAoTGliLklTX0lFOCkge1xuICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgIGZvciAobGV0IHByb3AgaW4gVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgIGxpc3RbcHJvcF0gPSBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICB9XG4gIH1cblxuICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5zZXRDdWVzXy5jYWxsKGxpc3QsIGN1ZXMpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGhfO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKExpYi5JU19JRTgpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxufTtcblxuVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuc2V0Q3Vlc18gPSBmdW5jdGlvbihjdWVzKSB7XG4gIGxldCBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICBsZXQgaSA9IDA7XG4gIGxldCBsID0gY3Vlcy5sZW5ndGg7XG5cbiAgdGhpcy5jdWVzXyA9IGN1ZXM7XG4gIHRoaXMubGVuZ3RoXyA9IGN1ZXMubGVuZ3RoO1xuXG4gIGxldCBkZWZpbmVQcm9wID0gZnVuY3Rpb24oaSkge1xuICAgIGlmICghKCcnK2kgaW4gdGhpcykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnJyArIGksIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jdWVzX1tpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChvbGRMZW5ndGggPCBsKSB7XG4gICAgaSA9IG9sZExlbmd0aDtcblxuICAgIGZvcig7IGkgPCBsOyBpKyspIHtcbiAgICAgIGRlZmluZVByb3AuY2FsbCh0aGlzLCBpKTtcbiAgICB9XG4gIH1cbn07XG5cblRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLmdldEN1ZUJ5SWQgPSBmdW5jdGlvbihpZCkge1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCBjdWUgPSB0aGlzW2ldO1xuICAgIGlmIChjdWUuaWQgPT09IGlkKSB7XG4gICAgICByZXN1bHQgPSBjdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVGV4dFRyYWNrQ3VlTGlzdDtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBNZW51IGZyb20gJy4uL21lbnUvbWVudS5qcyc7XG5pbXBvcnQgTWVudUl0ZW0gZnJvbSAnLi4vbWVudS9tZW51LWl0ZW0uanMnO1xuaW1wb3J0IE1lbnVCdXR0b24gZnJvbSAnLi4vbWVudS9tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliLmpzJztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxuY29uc3QgZGFya0dyYXkgPSAnIzIyMic7XG5jb25zdCBsaWdodEdyYXkgPSAnI2NjYyc7XG5jb25zdCBmb250TWFwID0ge1xuICBtb25vc3BhY2U6ICAgICAgICAgICAgICdtb25vc3BhY2UnLFxuICBzYW5zU2VyaWY6ICAgICAgICAgICAgICdzYW5zLXNlcmlmJyxcbiAgc2VyaWY6ICAgICAgICAgICAgICAgICAnc2VyaWYnLFxuICBtb25vc3BhY2VTYW5zU2VyaWY6ICAgICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlJyxcbiAgbW9ub3NwYWNlU2VyaWY6ICAgICAgICAnXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2UnLFxuICBwcm9wb3J0aW9uYWxTYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcbiAgcHJvcG9ydGlvbmFsU2VyaWY6ICAgICAnc2VyaWYnLFxuICBjYXN1YWw6ICAgICAgICAgICAgICAgICdcIkNvbWljIFNhbnMgTVNcIiwgSW1wYWN0LCBmYW50YXN5JyxcbiAgc2NyaXB0OiAgICAgICAgICAgICAgICAnXCJNb25vdHlwZSBDb3JzaXZhXCIsIGN1cnNpdmUnLFxuICBzbWFsbGNhcHM6ICAgICAgICAgICAgICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlLCBzYW5zLXNlcmlmJ1xufTtcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIHRleHQgdHJhY2sgY3Vlc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUZXh0VHJhY2tEaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KXtcbiAgICBzdXBlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIHBsYXllci5vbignbG9hZHN0YXJ0JywgTGliLmJpbmQodGhpcywgdGhpcy50b2dnbGVEaXNwbGF5KSk7XG4gICAgcGxheWVyLm9uKCd0ZXh0dHJhY2tjaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCB0aGlzLnRvZ2dsZURpc3BsYXkpKTtcblxuICAgIC8vIFRoaXMgdXNlZCB0byBiZSBjYWxsZWQgZHVyaW5nIHBsYXllciBpbml0LCBidXQgd2FzIGNhdXNpbmcgYW4gZXJyb3JcbiAgICAvLyBpZiBhIHRyYWNrIHNob3VsZCBzaG93IGJ5IGRlZmF1bHQgYW5kIHRoZSBkaXNwbGF5IGhhZG4ndCBsb2FkZWQgeWV0LlxuICAgIC8vIFNob3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0byBhbiBleHRlcm5hbCB0cmFjayBsb2FkZXIgd2hlbiB3ZSBzdXBwb3J0XG4gICAgLy8gdHJhY2tzIHRoYXQgZG9uJ3QgbmVlZCBhIGRpc3BsYXkuXG4gICAgcGxheWVyLnJlYWR5KExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHBsYXllci50ZWNoICYmIHBsYXllci50ZWNoWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwbGF5ZXIub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcblxuICAgICAgbGV0IHRyYWNrcyA9IHBsYXllci5vcHRpb25zX1sndHJhY2tzJ10gfHwgW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgIHRoaXMucGxheWVyXy5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIHRvZ2dsZURpc3BsYXkoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy50ZWNoICYmIHRoaXMucGxheWVyXy50ZWNoWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRleHQtdHJhY2stZGlzcGxheSdcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFyRGlzcGxheSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvd1snV2ViVlRUJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvd1snV2ViVlRUJ11bJ3Byb2Nlc3NDdWVzJ10od2luZG93LCBbXSwgdGhpcy5lbF8pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICB0aGlzLmNsZWFyRGlzcGxheSgpO1xuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpPTA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgIGlmICh0cmFja1snbW9kZSddID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JUcmFjayh0cmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRm9yVHJhY2sodHJhY2spIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvd1snV2ViVlRUJ10gIT09ICdmdW5jdGlvbicgfHwgIXRyYWNrWydhY3RpdmVDdWVzJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgb3ZlcnJpZGVzID0gdGhpcy5wbGF5ZXJfWyd0ZXh0VHJhY2tTZXR0aW5ncyddLmdldFZhbHVlcygpO1xuXG4gICAgbGV0IGN1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrWydhY3RpdmVDdWVzJ10ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1ZXMucHVzaCh0cmFja1snYWN0aXZlQ3VlcyddW2ldKTtcbiAgICB9XG5cbiAgICB3aW5kb3dbJ1dlYlZUVCddWydwcm9jZXNzQ3VlcyddKHdpbmRvdywgdHJhY2tbJ2FjdGl2ZUN1ZXMnXSwgdGhpcy5lbF8pO1xuXG4gICAgbGV0IGkgPSBjdWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBsZXQgY3VlRGl2ID0gY3Vlc1tpXS5kaXNwbGF5U3RhdGU7XG4gICAgICBpZiAob3ZlcnJpZGVzLmNvbG9yKSB7XG4gICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmNvbG9yID0gb3ZlcnJpZGVzLmNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkge1xuICAgICAgICB0cnlVcGRhdGVTdHlsZShjdWVEaXYuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgJ2NvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0Q29sb3Iob3ZlcnJpZGVzLmNvbG9yIHx8ICcjZmZmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzLnRleHRPcGFjaXR5KSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5iYWNrZ3JvdW5kT3BhY2l0eSkge1xuICAgICAgICB0cnlVcGRhdGVTdHlsZShjdWVEaXYuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmRDb2xvcicsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3IgfHwgJyMwMDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMuYmFja2dyb3VuZE9wYWNpdHkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMud2luZG93Q29sb3IpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcy53aW5kb3dPcGFjaXR5KSB7XG4gICAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy53aW5kb3dDb2xvciwgb3ZlcnJpZGVzLndpbmRvd09wYWNpdHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWVEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLndpbmRvd0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSkge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2Ryb3BzaGFkb3cnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9IGAycHggMnB4IDNweCAke2RhcmtHcmF5fSwgMnB4IDJweCA0cHggJHtkYXJrR3JheX0sIDJweCAycHggNXB4ICR7ZGFya0dyYXl9YDtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAncmFpc2VkJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSBgMXB4IDFweCAke2RhcmtHcmF5fSwgMnB4IDJweCAke2RhcmtHcmF5fSwgM3B4IDNweCAke2RhcmtHcmF5fWA7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2RlcHJlc3NlZCcpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gYDFweCAxcHggJHtsaWdodEdyYXl9LCAwIDFweCAke2xpZ2h0R3JheX0sIC0xcHggLTFweCAke2RhcmtHcmF5fSwgMCAtMXB4ICR7ZGFya0dyYXl9YDtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAndW5pZm9ybScpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gYDAgMCA0cHggJHtkYXJrR3JheX0sIDAgMCA0cHggJHtkYXJrR3JheX0sIDAgMCA0cHggJHtkYXJrR3JheX0sIDAgMCA0cHggJHtkYXJrR3JheX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmZvbnRQZXJjZW50ICYmIG92ZXJyaWRlcy5mb250UGVyY2VudCAhPT0gMSkge1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHdpbmRvdy5wYXJzZUZsb2F0KGN1ZURpdi5zdHlsZS5mb250U2l6ZSk7XG4gICAgICAgIGN1ZURpdi5zdHlsZS5mb250U2l6ZSA9IChmb250U2l6ZSAqIG92ZXJyaWRlcy5mb250UGVyY2VudCkgKyAncHgnO1xuICAgICAgICBjdWVEaXYuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUuYm90dG9tID0gJzJweCc7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgJiYgb3ZlcnJpZGVzLmZvbnRGYW1pbHkgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgPT09ICdzbWFsbC1jYXBzJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRWYXJpYW50ID0gJ3NtYWxsLWNhcHMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250TWFwW292ZXJyaWRlcy5mb250RmFtaWx5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbi8vIEFkZCBjdWUgSFRNTCB0byBkaXNwbGF5XG5mdW5jdGlvbiBjb25zdHJ1Y3RDb2xvcihjb2xvciwgb3BhY2l0eSkge1xuICByZXR1cm4gJ3JnYmEoJyArXG4gICAgLy8gY29sb3IgbG9va3MgbGlrZSBcIiNmMGVcIlxuICAgIHBhcnNlSW50KGNvbG9yWzFdICsgY29sb3JbMV0sIDE2KSArICcsJyArXG4gICAgcGFyc2VJbnQoY29sb3JbMl0gKyBjb2xvclsyXSwgMTYpICsgJywnICtcbiAgICBwYXJzZUludChjb2xvclszXSArIGNvbG9yWzNdLCAxNikgKyAnLCcgK1xuICAgIG9wYWNpdHkgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHRyeVVwZGF0ZVN0eWxlKGVsLCBzdHlsZSwgcnVsZSkge1xuICAvLyBzb21lIHN0eWxlIGNoYW5nZXMgd2lsbCB0aHJvdyBhbiBlcnJvciwgcGFydGljdWxhcmx5IGluIElFOC4gVGhvc2Ugc2hvdWxkIGJlIG5vb3BzLlxuICB0cnkge1xuICAgIGVsLnN0eWxlW3N0eWxlXSA9IHJ1bGU7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrRGlzcGxheScsIFRleHRUcmFja0Rpc3BsYXkpO1xuZXhwb3J0IGRlZmF1bHQgVGV4dFRyYWNrRGlzcGxheTtcbiIsIi8qXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbW9kZVxuICpcbiAqIGVudW0gVGV4dFRyYWNrTW9kZSB7IFwiZGlzYWJsZWRcIiwgIFwiaGlkZGVuXCIsICBcInNob3dpbmdcIiB9O1xuICovXG52YXIgVGV4dFRyYWNrTW9kZSA9IHtcbiAgJ2Rpc2FibGVkJzogJ2Rpc2FibGVkJyxcbiAgJ2hpZGRlbic6ICdoaWRkZW4nLFxuICAnc2hvd2luZyc6ICdzaG93aW5nJ1xufTtcblxuLypcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2traW5kXG4gKlxuICogZW51bSBUZXh0VHJhY2tLaW5kIHsgXCJzdWJ0aXRsZXNcIiwgIFwiY2FwdGlvbnNcIiwgIFwiZGVzY3JpcHRpb25zXCIsICBcImNoYXB0ZXJzXCIsICBcIm1ldGFkYXRhXCIgfTtcbiAqL1xudmFyIFRleHRUcmFja0tpbmQgPSB7XG4gICdzdWJ0aXRsZXMnOiAnc3VidGl0bGVzJyxcbiAgJ2NhcHRpb25zJzogJ2NhcHRpb25zJyxcbiAgJ2Rlc2NyaXB0aW9ucyc6ICdkZXNjcmlwdGlvbnMnLFxuICAnY2hhcHRlcnMnOiAnY2hhcHRlcnMnLFxuICAnbWV0YWRhdGEnOiAnbWV0YWRhdGEnXG59O1xuXG5leHBvcnQgeyBUZXh0VHJhY2tNb2RlLCBUZXh0VHJhY2tLaW5kIH07XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcblxuLypcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2tsaXN0XG4gKlxuICogaW50ZXJmYWNlIFRleHRUcmFja0xpc3QgOiBFdmVudFRhcmdldCB7XG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSB1bnNpZ25lZCBsb25nIGxlbmd0aDtcbiAqICAgZ2V0dGVyIFRleHRUcmFjayAodW5zaWduZWQgbG9uZyBpbmRleCk7XG4gKiAgIFRleHRUcmFjaz8gZ2V0VHJhY2tCeUlkKERPTVN0cmluZyBpZCk7XG4gKlxuICogICBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIG9uY2hhbmdlO1xuICogICBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIG9uYWRkdHJhY2s7XG4gKiAgIGF0dHJpYnV0ZSBFdmVudEhhbmRsZXIgb25yZW1vdmV0cmFjaztcbiAqIH07XG4gKi9cbmxldCBUZXh0VHJhY2tMaXN0ID0gZnVuY3Rpb24odHJhY2tzKSB7XG4gIGxldCBsaXN0ID0gdGhpcztcblxuICBpZiAoTGliLklTX0lFOCkge1xuICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgIGZvciAobGV0IHByb3AgaW4gVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgIGxpc3RbcHJvcF0gPSBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICB9XG4gIH1cblxuICB0cmFja3MgPSB0cmFja3MgfHwgW107XG4gIGxpc3QudHJhY2tzXyA9IFtdO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja3NfLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdC5hZGRUcmFja18odHJhY2tzW2ldKTtcbiAgfVxuXG4gIGlmIChMaWIuSVNfSUU4KSB7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbn07XG5cblRleHRUcmFja0xpc3QucHJvdG90eXBlID0gTGliLm9iai5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5UZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRUcmFja0xpc3Q7XG5cbi8qXG4gKiBjaGFuZ2UgLSBPbmUgb3IgbW9yZSB0cmFja3MgaW4gdGhlIHRyYWNrIGxpc3QgaGF2ZSBiZWVuIGVuYWJsZWQgb3IgZGlzYWJsZWQuXG4gKiBhZGR0cmFjayAtIEEgdHJhY2sgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHRyYWNrIGxpc3QuXG4gKiByZW1vdmV0cmFjayAtIEEgdHJhY2sgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSB0cmFjayBsaXN0LlxuKi9cblRleHRUcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICAnY2hhbmdlJzogJ2NoYW5nZScsXG4gICdhZGR0cmFjayc6ICdhZGR0cmFjaycsXG4gICdyZW1vdmV0cmFjayc6ICdyZW1vdmV0cmFjaydcbn07XG5cbi8vIGVtdWxhdGUgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBzdXBwb3J0IHRvIGFsbG93IGZvciBmZWF0dXJlIGRldGVjdGlvblxuZm9yIChsZXQgZXZlbnQgaW4gVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18pIHtcbiAgVGV4dFRyYWNrTGlzdC5wcm90b3R5cGVbJ29uJyArIGV2ZW50XSA9IG51bGw7XG59XG5cblRleHRUcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrXyA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIGxldCBpbmRleCA9IHRoaXMudHJhY2tzXy5sZW5ndGg7XG4gIGlmICghKCcnK2luZGV4IGluIHRoaXMpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGluZGV4LCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja3NfW2luZGV4XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ21vZGVjaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICB9KSk7XG4gIHRoaXMudHJhY2tzXy5wdXNoKHRyYWNrKTtcblxuICB0aGlzLnRyaWdnZXIoe1xuICAgIHR5cGU6ICdhZGR0cmFjaycsXG4gICAgdHJhY2s6IHRyYWNrXG4gIH0pO1xufTtcblxuVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUucmVtb3ZlVHJhY2tfID0gZnVuY3Rpb24ocnRyYWNrKSB7XG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBsZXQgdHJhY2s7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRyYWNrID0gdGhpc1tpXTtcbiAgICBpZiAodHJhY2sgPT09IHJ0cmFjaykge1xuICAgICAgdGhpcy50cmFja3NfLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudHJpZ2dlcih7XG4gICAgdHlwZTogJ3JlbW92ZXRyYWNrJyxcbiAgICB0cmFjazogdHJhY2tcbiAgfSk7XG59O1xuXG5UZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5nZXRUcmFja0J5SWQgPSBmdW5jdGlvbihpZCkge1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IHRyYWNrID0gdGhpc1tpXTtcbiAgICBpZiAodHJhY2suaWQgPT09IGlkKSB7XG4gICAgICByZXN1bHQgPSB0cmFjaztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0VHJhY2tMaXN0O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0ICogYXMgTGliIGZyb20gJy4uL2xpYic7XG5pbXBvcnQgKiBhcyBFdmVudHMgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBzYWZlUGFyc2VUdXBsZSBmcm9tICdzYWZlLWpzb24tcGFyc2UvdHVwbGUnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcblxuY2xhc3MgVGV4dFRyYWNrU2V0dGluZ3MgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucykge1xuICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5oaWRlKCk7XG5cbiAgICBFdmVudHMub24odGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtZG9uZS1idXR0b24nKSwgJ2NsaWNrJywgTGliLmJpbmQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNhdmVTZXR0aW5ncygpO1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSkpO1xuXG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWRlZmF1bHQtYnV0dG9uJyksICdjbGljaycsIExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtZmctY29sb3IgPiBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWJnLWNvbG9yID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLndpbmRvdy1jb2xvciA+IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1iZy1vcGFjaXR5ID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy13aW5kb3ctb3BhY2l0eSA+IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtZWRnZS1zdHlsZSBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWZvbnQtZmFtaWx5IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtZm9udC1wZXJjZW50IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAyO1xuICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSkpO1xuXG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWZnLWNvbG9yID4gc2VsZWN0JyksICdjaGFuZ2UnLCBMaWIuYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtYmctY29sb3IgPiBzZWxlY3QnKSwgJ2NoYW5nZScsIExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLndpbmRvdy1jb2xvciA+IHNlbGVjdCcpLCAnY2hhbmdlJywgTGliLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLXRleHQtb3BhY2l0eSA+IHNlbGVjdCcpLCAnY2hhbmdlJywgTGliLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnKSwgJ2NoYW5nZScsIExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy13aW5kb3ctb3BhY2l0eSA+IHNlbGVjdCcpLCAnY2hhbmdlJywgTGliLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWZvbnQtcGVyY2VudCBzZWxlY3QnKSwgJ2NoYW5nZScsIExpYi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy1lZGdlLXN0eWxlIHNlbGVjdCcpLCAnY2hhbmdlJywgTGliLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLWZvbnQtZmFtaWx5IHNlbGVjdCcpLCAnY2hhbmdlJywgTGliLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG5cbiAgICBpZiAocGxheWVyLm9wdGlvbnMoKVsncGVyc2lzdFRleHRUcmFja1NldHRpbmdzJ10pIHtcbiAgICAgIHRoaXMucmVzdG9yZVNldHRpbmdzKCk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY2FwdGlvbi1zZXR0aW5ncyB2anMtbW9kYWwtb3ZlcmxheScsXG4gICAgICBpbm5lckhUTUw6IGNhcHRpb25PcHRpb25zTWVudVRlbXBsYXRlKClcbiAgICB9KTtcbiAgfVxuXG4gIGdldFZhbHVlcygpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWwoKTtcblxuICAgIGNvbnN0IHRleHRFZGdlID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWVkZ2Utc3R5bGUgc2VsZWN0JykpO1xuICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZm9udC1mYW1pbHkgc2VsZWN0JykpO1xuICAgIGNvbnN0IGZnQ29sb3IgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZmctY29sb3IgPiBzZWxlY3QnKSk7XG4gICAgY29uc3QgdGV4dE9wYWNpdHkgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JykpO1xuICAgIGNvbnN0IGJnQ29sb3IgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtYmctY29sb3IgPiBzZWxlY3QnKSk7XG4gICAgY29uc3QgYmdPcGFjaXR5ID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbC5xdWVyeVNlbGVjdG9yKCcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnKSk7XG4gICAgY29uc3Qgd2luZG93Q29sb3IgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKGVsLnF1ZXJ5U2VsZWN0b3IoJy53aW5kb3ctY29sb3IgPiBzZWxlY3QnKSk7XG4gICAgY29uc3Qgd2luZG93T3BhY2l0eSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwucXVlcnlTZWxlY3RvcignLnZqcy13aW5kb3ctb3BhY2l0eSA+IHNlbGVjdCcpKTtcbiAgICBjb25zdCBmb250UGVyY2VudCA9IHdpbmRvd1sncGFyc2VGbG9hdCddKGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwucXVlcnlTZWxlY3RvcignLnZqcy1mb250LXBlcmNlbnQgPiBzZWxlY3QnKSkpO1xuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICdiYWNrZ3JvdW5kT3BhY2l0eSc6IGJnT3BhY2l0eSxcbiAgICAgICd0ZXh0T3BhY2l0eSc6IHRleHRPcGFjaXR5LFxuICAgICAgJ3dpbmRvd09wYWNpdHknOiB3aW5kb3dPcGFjaXR5LFxuICAgICAgJ2VkZ2VTdHlsZSc6IHRleHRFZGdlLFxuICAgICAgJ2ZvbnRGYW1pbHknOiBmb250RmFtaWx5LFxuICAgICAgJ2NvbG9yJzogZmdDb2xvcixcbiAgICAgICdiYWNrZ3JvdW5kQ29sb3InOiBiZ0NvbG9yLFxuICAgICAgJ3dpbmRvd0NvbG9yJzogd2luZG93Q29sb3IsXG4gICAgICAnZm9udFBlcmNlbnQnOiBmb250UGVyY2VudFxuICAgIH07XG4gICAgZm9yIChsZXQgbmFtZSBpbiByZXN1bHQpIHtcbiAgICAgIGlmIChyZXN1bHRbbmFtZV0gPT09ICcnIHx8IHJlc3VsdFtuYW1lXSA9PT0gJ25vbmUnIHx8IChuYW1lID09PSAnZm9udFBlcmNlbnQnICYmIHJlc3VsdFtuYW1lXSA9PT0gMS4wMCkpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdFtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHNldFZhbHVlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWwoKTtcblxuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZWRnZS1zdHlsZSBzZWxlY3QnKSwgdmFsdWVzLmVkZ2VTdHlsZSk7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24oZWwucXVlcnlTZWxlY3RvcignLnZqcy1mb250LWZhbWlseSBzZWxlY3QnKSwgdmFsdWVzLmZvbnRGYW1pbHkpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtZmctY29sb3IgPiBzZWxlY3QnKSwgdmFsdWVzLmNvbG9yKTtcbiAgICBzZXRTZWxlY3RlZE9wdGlvbihlbC5xdWVyeVNlbGVjdG9yKCcudmpzLXRleHQtb3BhY2l0eSA+IHNlbGVjdCcpLCB2YWx1ZXMudGV4dE9wYWNpdHkpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtYmctY29sb3IgPiBzZWxlY3QnKSwgdmFsdWVzLmJhY2tncm91bmRDb2xvcik7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24oZWwucXVlcnlTZWxlY3RvcignLnZqcy1iZy1vcGFjaXR5ID4gc2VsZWN0JyksIHZhbHVlcy5iYWNrZ3JvdW5kT3BhY2l0eSk7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24oZWwucXVlcnlTZWxlY3RvcignLndpbmRvdy1jb2xvciA+IHNlbGVjdCcpLCB2YWx1ZXMud2luZG93Q29sb3IpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKGVsLnF1ZXJ5U2VsZWN0b3IoJy52anMtd2luZG93LW9wYWNpdHkgPiBzZWxlY3QnKSwgdmFsdWVzLndpbmRvd09wYWNpdHkpO1xuXG4gICAgbGV0IGZvbnRQZXJjZW50ID0gdmFsdWVzLmZvbnRQZXJjZW50O1xuXG4gICAgaWYgKGZvbnRQZXJjZW50KSB7XG4gICAgICBmb250UGVyY2VudCA9IGZvbnRQZXJjZW50LnRvRml4ZWQoMik7XG4gICAgfVxuXG4gICAgc2V0U2VsZWN0ZWRPcHRpb24oZWwucXVlcnlTZWxlY3RvcignLnZqcy1mb250LXBlcmNlbnQgPiBzZWxlY3QnKSwgZm9udFBlcmNlbnQpO1xuICB9XG5cbiAgcmVzdG9yZVNldHRpbmdzKCkge1xuICAgIGxldCBbZXJyLCB2YWx1ZXNdID0gc2FmZVBhcnNlVHVwbGUod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCd2anMtdGV4dC10cmFjay1zZXR0aW5ncycpKTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIExpYi5sb2cuZXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICB0aGlzLnNldFZhbHVlcyh2YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIHNhdmVTZXR0aW5ncygpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyXy5vcHRpb25zKClbJ3BlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghTGliLmlzRW1wdHkodmFsdWVzKSkge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJywgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgbGV0IHR0RGlzcGxheSA9IHRoaXMucGxheWVyXy5nZXRDaGlsZCgndGV4dFRyYWNrRGlzcGxheScpO1xuICAgIGlmICh0dERpc3BsYXkpIHtcbiAgICAgIHR0RGlzcGxheS51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuICB9XG5cbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tTZXR0aW5ncycsIFRleHRUcmFja1NldHRpbmdzKTtcblxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0YXJnZXQpIHtcbiAgbGV0IHNlbGVjdGVkT3B0aW9uO1xuICAvLyBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgc2VsZWN0ZWRPcHRpb25zLCBzbywgZmFsbGJhY2sgdG8gb3B0aW9uc1xuICBpZiAodGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykge1xuICAgIHNlbGVjdGVkT3B0aW9uID0gdGFyZ2V0LnNlbGVjdGVkT3B0aW9uc1swXTtcbiAgfSBlbHNlIGlmICh0YXJnZXQub3B0aW9ucykge1xuICAgIHNlbGVjdGVkT3B0aW9uID0gdGFyZ2V0Lm9wdGlvbnNbdGFyZ2V0Lm9wdGlvbnMuc2VsZWN0ZWRJbmRleF07XG4gIH1cblxuICByZXR1cm4gc2VsZWN0ZWRPcHRpb24udmFsdWU7XG59XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0Lm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvcHRpb24gPSB0YXJnZXQub3B0aW9uc1tpXTtcbiAgICBpZiAob3B0aW9uLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnNlbGVjdGVkSW5kZXggPSBpO1xufVxuXG5mdW5jdGlvbiBjYXB0aW9uT3B0aW9uc01lbnVUZW1wbGF0ZSgpIHtcbiAgbGV0IHRlbXBsYXRlID0gYDxkaXYgY2xhc3M9XCJ2anMtdHJhY2tzZXR0aW5nc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInZqcy10cmFja3NldHRpbmdzLWNvbG9yc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWZnLWNvbG9yIHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInZqcy1sYWJlbFwiPkZvcmVncm91bmQ8L2xhYmVsPlxuICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPi0tLTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0ZGRlwiPldoaXRlPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMDAwXCI+QmxhY2s8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGMDBcIj5SZWQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwRjBcIj5HcmVlbjwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzAwRlwiPkJsdWU8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGRjBcIj5ZZWxsb3c8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGMEZcIj5NYWdlbnRhPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMEZGXCI+Q3lhbjwvb3B0aW9uPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZqcy10ZXh0LW9wYWNpdHkgdmpzLW9wYWNpdHlcIj5cbiAgICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+LS0tPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj5PcGFxdWU8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMC41XCI+U2VtaS1PcGFxdWU8L29wdGlvbj5cbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PiA8IS0tIHZqcy1mZy1jb2xvciAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInZqcy1iZy1jb2xvciB2anMtdHJhY2tzZXR0aW5nXCI+XG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIj5CYWNrZ3JvdW5kPC9sYWJlbD5cbiAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4tLS08L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGRkZcIj5XaGl0ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzAwMFwiPkJsYWNrPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRjAwXCI+UmVkPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMEYwXCI+R3JlZW48L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwMEZcIj5CbHVlPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkYwXCI+WWVsbG93PC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRjBGXCI+TWFnZW50YTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzBGRlwiPkN5YW48L29wdGlvbj5cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2anMtYmctb3BhY2l0eSB2anMtb3BhY2l0eVwiPlxuICAgICAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+LS0tPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMVwiPk9wYXF1ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjAuNVwiPlNlbWktVHJhbnNwYXJlbnQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCI+VHJhbnNwYXJlbnQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+IDwhLS0gdmpzLWJnLWNvbG9yIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwid2luZG93LWNvbG9yIHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInZqcy1sYWJlbFwiPldpbmRvdzwvbGFiZWw+XG4gICAgICAgICAgICA8c2VsZWN0PlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+LS0tPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkZGXCI+V2hpdGU8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwMDBcIj5CbGFjazwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0YwMFwiPlJlZDwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzBGMFwiPkdyZWVuPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMDBGXCI+Qmx1ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0ZGMFwiPlllbGxvdzwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0YwRlwiPk1hZ2VudGE8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwRkZcIj5DeWFuPC9vcHRpb24+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmpzLXdpbmRvdy1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4tLS08L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+T3BhcXVlPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMC41XCI+U2VtaS1UcmFuc3BhcmVudDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjBcIj5UcmFuc3BhcmVudDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj4gPCEtLSB2anMtd2luZG93LWNvbG9yIC0tPlxuICAgICAgPC9kaXY+IDwhLS0gdmpzLXRyYWNrc2V0dGluZ3MgLS0+XG4gICAgICA8ZGl2IGNsYXNzPVwidmpzLXRyYWNrc2V0dGluZ3MtZm9udFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWZvbnQtcGVyY2VudCB2anMtdHJhY2tzZXR0aW5nXCI+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwidmpzLWxhYmVsXCI+Rm9udCBTaXplPC9sYWJlbD5cbiAgICAgICAgICA8c2VsZWN0PlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjAuNTBcIj41MCU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwLjc1XCI+NzUlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMS4wMFwiIHNlbGVjdGVkPjEwMCU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxLjI1XCI+MTI1JTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEuNTBcIj4xNTAlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMS43NVwiPjE3NSU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyLjAwXCI+MjAwJTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjMuMDBcIj4zMDAlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiNC4wMFwiPjQwMCU8L29wdGlvbj5cbiAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+IDwhLS0gdmpzLWZvbnQtcGVyY2VudCAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInZqcy1lZGdlLXN0eWxlIHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIj5UZXh0IEVkZ2UgU3R5bGU8L2xhYmVsPlxuICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibm9uZVwiPk5vbmU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyYWlzZWRcIj5SYWlzZWQ8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJkZXByZXNzZWRcIj5EZXByZXNzZWQ8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJ1bmlmb3JtXCI+VW5pZm9ybTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImRyb3BzaGFkb3dcIj5Ecm9wc2hhZG93PC9vcHRpb24+XG4gICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PiA8IS0tIHZqcy1lZGdlLXN0eWxlIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmpzLWZvbnQtZmFtaWx5IHZqcy10cmFja3NldHRpbmdcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIj5Gb250IEZhbWlseTwvbGFiZWw+XG4gICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj5EZWZhdWx0PC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibW9ub3NwYWNlU2VyaWZcIj5Nb25vc3BhY2UgU2VyaWY8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJwcm9wb3J0aW9uYWxTZXJpZlwiPlByb3BvcnRpb25hbCBTZXJpZjwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1vbm9zcGFjZVNhbnNTZXJpZlwiPk1vbm9zcGFjZSBTYW5zLVNlcmlmPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicHJvcG9ydGlvbmFsU2Fuc1NlcmlmXCI+UHJvcG9ydGlvbmFsIFNhbnMtU2VyaWY8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjYXN1YWxcIj5DYXN1YWw8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzY3JpcHRcIj5TY3JpcHQ8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzbWFsbC1jYXBzXCI+U21hbGwgQ2Fwczwvb3B0aW9uPlxuICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L2Rpdj4gPCEtLSB2anMtZm9udC1mYW1pbHkgLS0+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidmpzLXRyYWNrc2V0dGluZ3MtY29udHJvbHNcIj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJ2anMtZGVmYXVsdC1idXR0b25cIj5EZWZhdWx0czwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cInZqcy1kb25lLWJ1dHRvblwiPkRvbmU8L2J1dHRvbj5cbiAgICA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0VHJhY2tTZXR0aW5ncztcbiIsImltcG9ydCBUZXh0VHJhY2tDdWVMaXN0IGZyb20gJy4vdGV4dC10cmFjay1jdWUtbGlzdCc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi4vbGliJztcbmltcG9ydCAqIGFzIFRleHRUcmFja0VudW0gZnJvbSAnLi90ZXh0LXRyYWNrLWVudW1zJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQgWEhSIGZyb20gJy4uL3hoci5qcyc7XG5cbi8qXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrXG4gKlxuICogaW50ZXJmYWNlIFRleHRUcmFjayA6IEV2ZW50VGFyZ2V0IHtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIFRleHRUcmFja0tpbmQga2luZDtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBsYWJlbDtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBsYW5ndWFnZTtcbiAqXG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgaWQ7XG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZTtcbiAqXG4gKiAgIGF0dHJpYnV0ZSBUZXh0VHJhY2tNb2RlIG1vZGU7XG4gKlxuICogICByZWFkb25seSBhdHRyaWJ1dGUgVGV4dFRyYWNrQ3VlTGlzdD8gY3VlcztcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIFRleHRUcmFja0N1ZUxpc3Q/IGFjdGl2ZUN1ZXM7XG4gKlxuICogICB2b2lkIGFkZEN1ZShUZXh0VHJhY2tDdWUgY3VlKTtcbiAqICAgdm9pZCByZW1vdmVDdWUoVGV4dFRyYWNrQ3VlIGN1ZSk7XG4gKlxuICogICBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIG9uY3VlY2hhbmdlO1xuICogfTtcbiAqL1xubGV0IFRleHRUcmFjayA9IGZ1bmN0aW9uKG9wdGlvbnM9e30pIHtcbiAgaWYgKCFvcHRpb25zLnRlY2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGVjaCB3YXMgbm90IHByb3ZpZGVkLicpO1xuICB9XG5cbiAgbGV0IHR0ID0gdGhpcztcbiAgaWYgKExpYi5JU19JRTgpIHtcbiAgICB0dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgZm9yIChsZXQgcHJvcCBpbiBUZXh0VHJhY2sucHJvdG90eXBlKSB7XG4gICAgICB0dFtwcm9wXSA9IFRleHRUcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgfVxuICB9XG5cbiAgdHQudGVjaF8gPSBvcHRpb25zLnRlY2g7XG5cbiAgbGV0IG1vZGUgPSBUZXh0VHJhY2tFbnVtLlRleHRUcmFja01vZGVbb3B0aW9uc1snbW9kZSddXSB8fCAnZGlzYWJsZWQnO1xuICBsZXQga2luZCA9IFRleHRUcmFja0VudW0uVGV4dFRyYWNrS2luZFtvcHRpb25zWydraW5kJ11dIHx8ICdzdWJ0aXRsZXMnO1xuICBsZXQgbGFiZWwgPSBvcHRpb25zWydsYWJlbCddIHx8ICcnO1xuICBsZXQgbGFuZ3VhZ2UgPSBvcHRpb25zWydsYW5ndWFnZSddIHx8IG9wdGlvbnNbJ3NyY2xhbmcnXSB8fCAnJztcbiAgbGV0IGlkID0gb3B0aW9uc1snaWQnXSB8fCAndmpzX3RleHRfdHJhY2tfJyArIExpYi5ndWlkKys7XG5cbiAgaWYgKGtpbmQgPT09ICdtZXRhZGF0YScgfHwga2luZCA9PT0gJ2NoYXB0ZXJzJykge1xuICAgIG1vZGUgPSAnaGlkZGVuJztcbiAgfVxuXG4gIHR0LmN1ZXNfID0gW107XG4gIHR0LmFjdGl2ZUN1ZXNfID0gW107XG5cbiAgbGV0IGN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5jdWVzXyk7XG4gIGxldCBhY3RpdmVDdWVzID0gbmV3IFRleHRUcmFja0N1ZUxpc3QodHQuYWN0aXZlQ3Vlc18pO1xuXG4gIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gIGxldCB0aW1ldXBkYXRlSGFuZGxlciA9IExpYi5iaW5kKHR0LCBmdW5jdGlvbigpIHtcbiAgICB0aGlzWydhY3RpdmVDdWVzJ107XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXNbJ3RyaWdnZXInXSgnY3VlY2hhbmdlJyk7XG4gICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgaWYgKG1vZGUgIT09ICdkaXNhYmxlZCcpIHtcbiAgICB0dC50ZWNoXy5vbigndGltZXVwZGF0ZScsIHRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2tpbmQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBraW5kO1xuICAgIH0sXG4gICAgc2V0OiBGdW5jdGlvbi5wcm90b3R5cGVcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnbGFiZWwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9LFxuICAgIHNldDogRnVuY3Rpb24ucHJvdG90eXBlXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2xhbmd1YWdlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbGFuZ3VhZ2U7XG4gICAgfSxcbiAgICBzZXQ6IEZ1bmN0aW9uLnByb3RvdHlwZVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdpZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgc2V0OiBGdW5jdGlvbi5wcm90b3R5cGVcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnbW9kZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKG5ld01vZGUpIHtcbiAgICAgIGlmICghVGV4dFRyYWNrRW51bS5UZXh0VHJhY2tNb2RlW25ld01vZGVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1vZGUgPSBuZXdNb2RlO1xuICAgICAgaWYgKG1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICB0aGlzLnRlY2hfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKCdtb2RlY2hhbmdlJyk7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdjdWVzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1ZXM7XG4gICAgfSxcbiAgICBzZXQ6IEZ1bmN0aW9uLnByb3RvdHlwZVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdhY3RpdmVDdWVzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbJ2N1ZXMnXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUN1ZXM7IC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgIH1cblxuICAgICAgbGV0IGN0ID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgbGV0IGFjdGl2ZSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXNbJ2N1ZXMnXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbGV0IGN1ZSA9IHRoaXNbJ2N1ZXMnXVtpXTtcbiAgICAgICAgaWYgKGN1ZVsnc3RhcnRUaW1lJ10gPD0gY3QgJiYgY3VlWydlbmRUaW1lJ10gPj0gY3QpIHtcbiAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ZVsnc3RhcnRUaW1lJ10gPT09IGN1ZVsnZW5kVGltZSddICYmIGN1ZVsnc3RhcnRUaW1lJ10gPD0gY3QgJiYgY3VlWydzdGFydFRpbWUnXSArIDAuNSA+PSBjdCkge1xuICAgICAgICAgIGFjdGl2ZS5wdXNoKGN1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWN0aXZlLmxlbmd0aCAhPT0gdGhpcy5hY3RpdmVDdWVzXy5sZW5ndGgpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpbmRleE9mLmNhbGwodGhpcy5hY3RpdmVDdWVzXywgYWN0aXZlW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFjdGl2ZUN1ZXNfID0gYWN0aXZlO1xuICAgICAgYWN0aXZlQ3Vlcy5zZXRDdWVzXyh0aGlzLmFjdGl2ZUN1ZXNfKTtcblxuICAgICAgcmV0dXJuIGFjdGl2ZUN1ZXM7XG4gICAgfSxcbiAgICBzZXQ6IEZ1bmN0aW9uLnByb3RvdHlwZVxuICB9KTtcblxuICBpZiAob3B0aW9ucy5zcmMpIHtcbiAgICBsb2FkVHJhY2sob3B0aW9ucy5zcmMsIHR0KTtcbiAgfSBlbHNlIHtcbiAgICB0dC5sb2FkZWRfID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChMaWIuSVNfSUU4KSB7XG4gICAgcmV0dXJuIHR0O1xuICB9XG59O1xuXG5UZXh0VHJhY2sucHJvdG90eXBlID0gTGliLm9iai5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5UZXh0VHJhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dFRyYWNrO1xuXG4vKlxuICogY3VlY2hhbmdlIC0gT25lIG9yIG1vcmUgY3VlcyBpbiB0aGUgdHJhY2sgaGF2ZSBiZWNvbWUgYWN0aXZlIG9yIHN0b3BwZWQgYmVpbmcgYWN0aXZlLlxuICovXG5UZXh0VHJhY2sucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICAnY3VlY2hhbmdlJzogJ2N1ZWNoYW5nZSdcbn07XG5cblRleHRUcmFjay5wcm90b3R5cGUuYWRkQ3VlID0gZnVuY3Rpb24oY3VlKSB7XG4gIGxldCB0cmFja3MgPSB0aGlzLnRlY2hfLnRleHRUcmFja3MoKTtcblxuICBpZiAodHJhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmFja3NbaV0gIT09IHRoaXMpIHtcbiAgICAgICAgdHJhY2tzW2ldLnJlbW92ZUN1ZShjdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY3Vlc18ucHVzaChjdWUpO1xuICB0aGlzWydjdWVzJ10uc2V0Q3Vlc18odGhpcy5jdWVzXyk7XG59O1xuXG5UZXh0VHJhY2sucHJvdG90eXBlLnJlbW92ZUN1ZSA9IGZ1bmN0aW9uKHJlbW92ZUN1ZSkge1xuICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jdWVzXy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZXQgY3VlID0gdGhpcy5jdWVzX1tpXTtcbiAgICBpZiAoY3VlID09PSByZW1vdmVDdWUpIHtcbiAgICAgIHRoaXMuY3Vlc18uc3BsaWNlKGksIDEpO1xuICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbW92ZWQpIHtcbiAgICB0aGlzLmN1ZXMuc2V0Q3Vlc18odGhpcy5jdWVzXyk7XG4gIH1cbn07XG5cbi8qXG4gKiBEb3dubG9hZGluZyBzdHVmZiBoYXBwZW5zIGJlbG93IHRoaXMgcG9pbnRcbiAqL1xudmFyIHBhcnNlQ3VlcyA9IGZ1bmN0aW9uKHNyY0NvbnRlbnQsIHRyYWNrKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93WydXZWJWVFQnXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vdHJ5IGFnYWluIGEgYml0IGxhdGVyXG4gICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcGFyc2VDdWVzKHNyY0NvbnRlbnQsIHRyYWNrKTtcbiAgICB9LCAyNSk7XG4gIH1cblxuICBsZXQgcGFyc2VyID0gbmV3IHdpbmRvd1snV2ViVlRUJ11bJ1BhcnNlciddKHdpbmRvdywgd2luZG93Wyd2dHRqcyddLCB3aW5kb3dbJ1dlYlZUVCddWydTdHJpbmdEZWNvZGVyJ10oKSk7XG5cbiAgcGFyc2VyWydvbmN1ZSddID0gZnVuY3Rpb24oY3VlKSB7XG4gICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gIH07XG4gIHBhcnNlclsnb25wYXJzaW5nZXJyb3InXSA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgTGliLmxvZy5lcnJvcihlcnJvcik7XG4gIH07XG5cbiAgcGFyc2VyWydwYXJzZSddKHNyY0NvbnRlbnQpO1xuICBwYXJzZXJbJ2ZsdXNoJ10oKTtcbn07XG5cbnZhciBsb2FkVHJhY2sgPSBmdW5jdGlvbihzcmMsIHRyYWNrKSB7XG4gIFhIUihzcmMsIExpYi5iaW5kKHRoaXMsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlQm9keSl7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIExpYi5sb2cuZXJyb3IoZXJyKTtcbiAgICB9XG5cblxuICAgIHRyYWNrLmxvYWRlZF8gPSB0cnVlO1xuICAgIHBhcnNlQ3VlcyhyZXNwb25zZUJvZHksIHRyYWNrKTtcbiAgfSkpO1xufTtcblxudmFyIGluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widGhpc1wiIGlzIG51bGwgb3Igbm90IGRlZmluZWQnKTtcbiAgfVxuXG4gIGxldCBPID0gT2JqZWN0KHRoaXMpO1xuXG4gIGxldCBsZW4gPSBPLmxlbmd0aCA+Pj4gMDtcblxuICBpZiAobGVuID09PSAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgbGV0IG4gPSArZnJvbUluZGV4IHx8IDA7XG5cbiAgaWYgKE1hdGguYWJzKG4pID09PSBJbmZpbml0eSkge1xuICAgIG4gPSAwO1xuICB9XG5cbiAgaWYgKG4gPj0gbGVuKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgbGV0IGsgPSBNYXRoLm1heChuID49IDAgPyBuIDogbGVuIC0gTWF0aC5hYnMobiksIDApO1xuXG4gIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgaWYgKGsgaW4gTyAmJiBPW2tdID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICByZXR1cm4gaztcbiAgICB9XG4gICAgaysrO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRUcmFjaztcbiIsImltcG9ydCB7IG9iaiB9IGZyb20gJy4vbGliJztcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBuYW1lc3BhY2VcbiAqIEBuYW1lc3BhY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciB1dGlsID0ge307XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbnMgb2JqZWN0cywgcmVjdXJzaXZlbHkgbWVyZ2luZyBhbnkgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXMgYXNcbiAqIHdlbGwuICBQcmV2aW91c2x5IGBkZWVwTWVyZ2VgXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBvdmVycmlkZSB2YWx1ZXMgaW5cbiAqIEBwYXJhbSAge09iamVjdH0gb2JqMiBPdmVycmlkaW5nIG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgIE5ldyBvYmplY3QgLS0gb2JqMSBhbmQgb2JqMiB3aWxsIGJlIHVudG91Y2hlZFxuICovXG52YXIgbWVyZ2VPcHRpb25zID0gZnVuY3Rpb24ob2JqMSwgb2JqMil7XG4gIHZhciBrZXksIHZhbDEsIHZhbDI7XG5cbiAgLy8gbWFrZSBhIGNvcHkgb2Ygb2JqMSBzbyB3ZSdyZSBub3Qgb3ZlcndyaXRpbmcgb3JpZ2luYWwgdmFsdWVzLlxuICAvLyBsaWtlIHByb3RvdHlwZS5vcHRpb25zXyBhbmQgYWxsIHN1YiBvcHRpb25zIG9iamVjdHNcbiAgb2JqMSA9IG9iai5jb3B5KG9iajEpO1xuXG4gIGZvciAoa2V5IGluIG9iajIpe1xuICAgIGlmIChvYmoyLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhbDEgPSBvYmoxW2tleV07XG4gICAgICB2YWwyID0gb2JqMltrZXldO1xuXG4gICAgICAvLyBDaGVjayBpZiBib3RoIHByb3BlcnRpZXMgYXJlIHB1cmUgb2JqZWN0cyBhbmQgZG8gYSBkZWVwIG1lcmdlIGlmIHNvXG4gICAgICBpZiAob2JqLmlzUGxhaW4odmFsMSkgJiYgb2JqLmlzUGxhaW4odmFsMikpIHtcbiAgICAgICAgb2JqMVtrZXldID0gbWVyZ2VPcHRpb25zKHZhbDEsIHZhbDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqMVtrZXldID0gb2JqMltrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqMTtcbn07XG5cbmV4cG9ydCB7IG1lcmdlT3B0aW9ucyB9O1xuIiwiaW1wb3J0IGRvY3VtZW50IGZyb20gJ2dsb2JhbC9kb2N1bWVudCc7XG5cbmltcG9ydCBNZWRpYUxvYWRlciBmcm9tICcuL3RlY2gvbG9hZGVyLmpzJztcbmltcG9ydCBIdG1sNSBmcm9tICcuL3RlY2gvaHRtbDUuanMnO1xuaW1wb3J0IEZsYXNoIGZyb20gJy4vdGVjaC9mbGFzaC5qcyc7XG5pbXBvcnQgUG9zdGVySW1hZ2UgZnJvbSAnLi9wb3N0ZXItaW1hZ2UuanMnO1xuaW1wb3J0IFRleHRUcmFja0Rpc3BsYXkgZnJvbSAnLi90cmFja3MvdGV4dC10cmFjay1kaXNwbGF5LmpzJztcbmltcG9ydCBMb2FkaW5nU3Bpbm5lciBmcm9tICcuL2xvYWRpbmctc3Bpbm5lci5qcyc7XG5pbXBvcnQgQmlnUGxheUJ1dHRvbiBmcm9tICcuL2JpZy1wbGF5LWJ1dHRvbi5qcyc7XG5pbXBvcnQgQ29udHJvbEJhciBmcm9tICcuL2NvbnRyb2wtYmFyL2NvbnRyb2wtYmFyLmpzJztcbmltcG9ydCBFcnJvckRpc3BsYXkgZnJvbSAnLi9lcnJvci1kaXNwbGF5LmpzJztcblxuaW1wb3J0IHZpZGVvanMgZnJvbSAnLi9jb3JlJztcbmltcG9ydCAqIGFzIHNldHVwIGZyb20gJy4vc2V0dXAnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudCc7XG5pbXBvcnQgKiBhcyBMaWIgZnJvbSAnLi9saWInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IFBsYXllciBmcm9tICcuL3BsYXllcic7XG5pbXBvcnQgZXh0ZW5kc0ZuIGZyb20gJy4vZXh0ZW5kcy5qcyc7XG5pbXBvcnQgcGx1Z2luIGZyb20gJy4vcGx1Z2lucy5qcyc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMuanMnO1xuXG5pZiAodHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XG59XG5cbi8vIFJ1biBBdXRvLWxvYWQgcGxheWVyc1xuLy8gWW91IGhhdmUgdG8gd2FpdCBhdCBsZWFzdCBvbmNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIGFmdGVyIHlvdXIgdmlkZW8gaW4gdGhlIERPTSAod2VpcmQgYmVoYXZpb3Igb25seSB3aXRoIG1pbmlmaWVkIHZlcnNpb24pXG5zZXR1cC5hdXRvU2V0dXBUaW1lb3V0KDEsIHZpZGVvanMpO1xuXG52aWRlb2pzLmdldENvbXBvbmVudCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQ7XG52aWRlb2pzLnJlZ2lzdGVyQ29tcG9uZW50ID0gQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50O1xuXG4vLyBBUElzIHRoYXQgd2lsbCBiZSByZW1vdmVkIHdpdGggNS4wLCBidXQgbmVlZCB0aGVtIHRvIGdldCB0ZXN0cyBwYXNzaW5nXG4vLyBpbiBFUzYgdHJhbnNpdGlvblxudmlkZW9qcy5UT1VDSF9FTkFCTEVEID0gTGliLlRPVUNIX0VOQUJMRUQ7XG52aWRlb2pzLnV0aWwgPSBVdGlsO1xuXG4vLyBQcm9iYWJseSB3YW50IHRvIGtlZXAgdGhpcyBvbmUgZm9yIDUuMD9cbnZpZGVvanMucGxheWVycyA9IFBsYXllci5wbGF5ZXJzO1xuXG52aWRlb2pzLmV4dGVuZHMgPSBleHRlbmRzRm47XG5cbnZpZGVvanMuZ2V0R2xvYmFsT3B0aW9ucyA9ICgpID0+IG9wdGlvbnM7XG52aWRlb2pzLnNldEdsb2JhbE9wdGlvbnMgPSBmdW5jdGlvbihuZXdPcHRpb25zKSB7XG4gIExpYi51dGlsLm1lcmdlT3B0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcbn07XG5cbnZpZGVvanMucGx1Z2luID0gcGx1Z2luO1xuXG4vLyBSRU1PVklORzogV2UgcHJvYmFibHkgc2hvdWxkIG5vdCBpbmNsdWRlIHRoaXMgaW4gNS4wIHRob3VnaHQgaXQgd291bGQgbWFrZSBpdFxuLy8gbW9yZSBiYWNrd2FyZHMgY29tcGF0aWJsZVxuLy8gLy8gRXhwb3NlIGJ1dCBkZXByZWNhdGUgdGhlIHdpbmRvd1tjb21wb25lbnROYW1lXSBtZXRob2QgZm9yIGFjY2Vzc2luZyBjb21wb25lbnRzXG4vLyBMaWIub2JqLmVhY2goQ29tcG9uZW50LmNvbXBvbmVudHMsIGZ1bmN0aW9uKG5hbWUsIGNvbXBvbmVudCl7XG4vLyAgIC8vIEEgZGVwcmVjYXRpb24gd2FybmluZyBhcyB0aGUgY29uc3R1Y3RvclxuLy8gICBtb2R1bGUuZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpe1xuLy8gICAgIExpYi5sb2cud2FybignVXNpbmcgdmlkZW9qcy4nK25hbWUrJyB0byBhY2Nlc3MgdGhlICcrbmFtZSsnIGNvbXBvbmVudCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHZpZGVvanMuZ2V0Q29tcG9uZW50KFwiY29tcG9uZW50TmFtZVwiKScpO1xuLy9cbi8vICAgICByZXR1cm4gbmV3IENvbXBvbmVudChwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcbi8vICAgfTtcbi8vXG4vLyAgIC8vIEFsbG93IHRoZSBwcm90b3R5cGUgYW5kIGNsYXNzIG1ldGhvZHMgdG8gYmUgYWNjZXNzaWJsZSBzdGlsbCB0aGlzIHdheVxuLy8gICAvLyBUaG91Z2ggYW55dGhpbmcgdGhhdCBhdHRlbXB0cyB0byBvdmVycmlkZSBjbGFzcyBtZXRob2RzIHdpbGwgbm8gbG9uZ2VyIHdvcmtcbi8vICAgTGliLm9iai5tZXJnZShtb2R1bGUuZXhwb3J0c1tuYW1lXSwgY29tcG9uZW50KTtcbi8vIH0pO1xuXG5leHBvcnQgZGVmYXVsdCB2aWRlb2pzO1xuIiwiaW1wb3J0ICogYXMgVmpzVXRpbHMgZnJvbSAnLi91dGlsJztcbmltcG9ydCAqIGFzIExpYiBmcm9tICcuL2xpYic7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG4vKipcbiAqIFNpbXBsZSBodHRwIHJlcXVlc3QgZm9yIHJldHJpZXZpbmcgZXh0ZXJuYWwgZmlsZXMgKGUuZy4gdGV4dCB0cmFja3MpXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqICAgICAvLyB1c2luZyB1cmwgc3RyaW5nXG4gKiAgICAgdmlkZW9qcy54aHIoJ2h0dHA6Ly9leGFtcGxlLmNvbS9teWZpbGUudnR0JywgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlLCByZXNwb25zZUJvZHkpe30pO1xuICpcbiAqICAgICAvLyBvciBvcHRpb25zIGJsb2NrXG4gKiAgICAgdmlkZW9qcy54aHIoe1xuICogICAgICAgdXJpOiAnaHR0cDovL2V4YW1wbGUuY29tL215ZmlsZS52dHQnLFxuICogICAgICAgbWV0aG9kOiAnR0VUJyxcbiAqICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnXG4gKiAgICAgfSwgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlLCByZXNwb25zZUJvZHkpe1xuICogICAgICAgaWYgKGVycm9yKSB7XG4gKiAgICAgICAgIC8vIGxvZyB0aGUgZXJyb3JcbiAqICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIC8vIHN1Y2Nlc3NmdWwsIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXNwb25zZVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqXG4gKiBBUEkgaXMgbW9kZWxlZCBhZnRlciB0aGUgUmF5bm9zL3hociwgd2hpY2ggd2UgaG9wZSB0byB1c2UgYWZ0ZXJcbiAqIGdldHRpbmcgYnJvd3NlcmlmeSBpbXBsZW1lbnRlZC5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9SYXlub3MveGhyL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gIG9wdGlvbnMgICBPcHRpb25zIGJsb2NrIG9yIFVSTCBzdHJpbmdcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAgICAgICAgICAgICAgICAgIFRoZSByZXF1ZXN0XG4gKi9cbnZhciB4aHIgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjayl7XG4gIGxldCBhYm9ydFRpbWVvdXQ7XG5cbiAgLy8gSWYgb3B0aW9ucyBpcyBhIHN0cmluZyBpdCdzIHRoZSB1cmxcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IG9wdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgLy8gTWVyZ2Ugd2l0aCBkZWZhdWx0IG9wdGlvbnNcbiAgVmpzVXRpbHMubWVyZ2VPcHRpb25zKHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHRpbWVvdXQ6IDQ1ICogMTAwMFxuICB9LCBvcHRpb25zKTtcblxuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcblxuICBsZXQgWEhSID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xuXG4gIGlmICh0eXBlb2YgWEhSID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFNoaW0gWE1MSHR0cFJlcXVlc3QgZm9yIG9sZGVyIElFc1xuICAgIFhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7IHJldHVybiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpOyB9IGNhdGNoIChlKSB7fVxuICAgICAgdHJ5IHsgcmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2ggKGYpIHt9XG4gICAgICB0cnkgeyByZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpOyB9IGNhdGNoIChnKSB7fVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdC4nKTtcbiAgICB9O1xuICB9XG5cbiAgbGV0IHJlcXVlc3QgPSBuZXcgWEhSKCk7XG4gIC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSB1cmwgb24gdGhlIHJlcXVlc3QgaW5zdGFuY2VcbiAgcmVxdWVzdC51cmkgPSBvcHRpb25zLnVyaTtcblxuICBsZXQgdXJsSW5mbyA9IExpYi5wYXJzZVVybChvcHRpb25zLnVyaSk7XG4gIGxldCB3aW5Mb2MgPSB3aW5kb3cubG9jYXRpb247XG5cbiAgbGV0IHN1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dCk7XG4gICAgY2FsbGJhY2sobnVsbCwgcmVxdWVzdCwgcmVxdWVzdC5yZXNwb25zZSB8fCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gIH07XG5cbiAgbGV0IGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycil7XG4gICAgd2luZG93LmNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpO1xuXG4gICAgaWYgKCFlcnIgfHwgdHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcihlcnIpO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKGVyciwgcmVxdWVzdCk7XG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgdXJsIGlzIGZvciBhbm90aGVyIGRvbWFpbi9vcmlnaW5cbiAgLy8gSUU4IGRvZXNuJ3Qga25vdyBsb2NhdGlvbi5vcmlnaW4sIHNvIHdlIHdvbid0IHJlbHkgb24gaXQgaGVyZVxuICBjb25zdCBjcm9zc09yaWdpbiA9ICh1cmxJbmZvLnByb3RvY29sICsgdXJsSW5mby5ob3N0KSAhPT0gKHdpbkxvYy5wcm90b2NvbCArIHdpbkxvYy5ob3N0KTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCAtLSBVc2UgZm9yIElFIGlmIFhNTEhUVFBSZXF1ZXN0MiBpc24ndCBhdmFpbGFibGVcbiAgLy8gJ3dpdGhDcmVkZW50aWFscycgaXMgb25seSBhdmFpbGFibGUgaW4gWE1MSFRUUFJlcXVlc3QyXG4gIC8vIEFsc28gWERvbWFpblJlcXVlc3QgaGFzIGEgbG90IG9mIGdvdGNoYXMsIHNvIG9ubHkgdXNlIGlmIGNyb3NzIGRvbWFpblxuICBpZiAoY3Jvc3NPcmlnaW4gJiYgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkpIHtcbiAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub25sb2FkID0gc3VjY2Vzc0hhbmRsZXI7XG4gICAgcmVxdWVzdC5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgIC8vIFRoZXNlIGJsYW5rIGhhbmRsZXJzIG5lZWQgdG8gYmUgc2V0IHRvIGZpeCBpZTlcbiAgICAvLyBodHRwOi8vY3lwcmVzc25vcnRoLmNvbS9wcm9ncmFtbWluZy9pbnRlcm5ldC1leHBsb3Jlci1hYm9ydGluZy1hamF4LXJlcXVlc3RzLWZpeGVkL1xuICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCl7fTtcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBYTUxIVFRQUmVxdWVzdFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZpbGVVcmwgPSAodXJsSW5mby5wcm90b2NvbCA9PT0gJ2ZpbGU6JyB8fCB3aW5Mb2MucHJvdG9jb2wgPT09ICdmaWxlOicpO1xuXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QudGltZWRvdXQpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKCd0aW1lb3V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCBmaWxlVXJsICYmIHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgc3VjY2Vzc0hhbmRsZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvckhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICBhYm9ydFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJlcXVlc3QudGltZWRvdXQgPSB0cnVlO1xuICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICAvLyBvcGVuIHRoZSBjb25uZWN0aW9uXG4gIHRyeSB7XG4gICAgLy8gVGhpcmQgYXJnIGlzIGFzeW5jLCBvciBpZ25vcmVkIGJ5IFhEb21haW5SZXF1ZXN0XG4gICAgcmVxdWVzdC5vcGVuKG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCBvcHRpb25zLnVyaSwgdHJ1ZSk7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgcmV0dXJuIGVycm9ySGFuZGxlcihlcnIpO1xuICB9XG5cbiAgLy8gd2l0aENyZWRlbnRpYWxzIG9ubHkgc3VwcG9ydGVkIGJ5IFhNTEh0dHBSZXF1ZXN0MlxuICBpZihvcHRpb25zLndpdGhDcmVkZW50aWFscykge1xuICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSkge1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHRoZSByZXF1ZXN0XG4gIHRyeSB7XG4gICAgcmVxdWVzdC5zZW5kKCk7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgcmV0dXJuIGVycm9ySGFuZGxlcihlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB4aHI7XG4iXX0=
